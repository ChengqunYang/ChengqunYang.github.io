<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[JSP]]></title>
    <url>%2F2019%2F07%2F29%2FJSP%2F</url>
    <content type="text"><![CDATA[JSP1. 概念: Java Server Pages:java服务器端页面 可以理解为一个特殊的页面,其中既可以指定定义html,又可以定义java代码 用于简化书写 JSP本质上就是一个Servlet JSP的脚本:JSP定义Java代码的方式 &lt;% 代码 %&gt;:定义的Java代码,在service方法中.service方法中可以定义什么,该脚本就可以定义什么 &lt;%! 代码 %&gt;:定义的Java代码,在JSP转换后的Java类的成员位置 &lt;%= 代码 %&gt;:定义的Java代码在service方法中,会输出到页面上,输出语句中可以定义什么,该脚本中就可以定义什么 JSP的内置对象: 在JSP页面中不需要获取和创建的,可以直接使用的对象 JSP一共有9个内置对象 request response out:字符输出流.可以将数据输出到页面上,和response.getWriter()类似 response.getWriter()和out.write()的区别: 在tomcat服务器真正给客户端做出相应之前,会先找response缓冲区数据再找out缓冲区数据 response.getWriter()数据输出永远在out.write()之前]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JavaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cookie和Session]]></title>
    <url>%2F2019%2F07%2F28%2FCookie%E5%92%8CSession%2F</url>
    <content type="text"><![CDATA[会话技术 会话：一次会话中包含多次请求和响应 一次会话：浏览器第一次给服务器资源发送请求，会话建立，直到有一方断开为止 功能：在一次会话的范围内的多次请求间，共享数据 方式： 客户端会话技术(数据存在客户端):Cookie 服务器端会话技术(数据存在服务器端)：Session Cookie 概念:客户端会话技术,将数据保存到客户端 快速入门: 创建Cookie对象,绑定数据 new Cookie(String name,String value) 服务器发送Cookie对象给浏览器 response.addCookie(Cookie cookie) 服务器从request中获取Cookie,拿到数据 Cookie[] request.getCookies() 实现原理: 基于响应头set-cookie和请求头cookie实现 cookie的细节 一次可不可以发送多个cookie? 可以 可以创建多个cookie对象,使用response调用多次addCookie方法发送cookie即可 cookie在浏览器中保存多长时间? 默认情况下,当浏览器关闭后,Cookie数据被销毁 持久化存储: setMaxAge(int seconds) 正数:将Cookie数据写到硬盘的文件中.持久化存储.cookie存活时间 负数:默认值,存在浏览器中,浏览器关闭,信息销毁 零:删除cookie信息 cookie能不能存中文? 在tomcat 8 之前,Cookie不能直接存储中文数据 需要将中文数据转码—-一般采用URL编码(%E3) 在tomcat 8 之后,Cookie支持中文数据.特殊字符还是不支持,建议使用URL编码存储,URL解码解析 Cookie获取范围有多大? 假设在一个tomcat服务器中,部署了多个web项目,那么在这些web项目中Cookie能不能共享? 默认情况下Cookie不能共享+ setPath(String path):设置Cookie的获取范围.默认情况下,设置当前的虚拟目录 + 如果要共享,可以将path设置为&quot;/&quot; 不同的tomcat服务器间Cookie数据的共享? setDomain(String path):如果设置一级域名相同, 那么多个服务前间的Cookie可以共享 setDomain(“.baidu.com”),那么tieba.baidu.com和news.baidu.com中的Cookie可以共享 Cookie的特点和作用 特点: Cookie存储数据在客户端浏览器 浏览器对于单个Cookie的大小有限制(4kb),以及对同一个域名下的总的Cookie数量也有限制(20个) 作用: Cookie一般用于存储少量的不太敏感的数据 在不登录的情况下,完成服务器对客户端的身份识别 案例:记住上一次访问时间 需求: 访问一个Servlet,如果是第一次访问,则提示:您好,欢迎您首次访问 如果不是第一次访问,则提示:欢迎回来,您上次访问时间为:显示时间字符串 Session]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JavaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[反射]]></title>
    <url>%2F2019%2F07%2F07%2F%E5%8F%8D%E5%B0%84%2F</url>
    <content type="text"><![CDATA[Java反射反射:框架设计的灵魂 框架:半成品软件.可以在框架的基础上进行软件开发,简化编码 反射:将类的各个组成部分封装为其他对象,这就是反射机制 好处 可以在程序运行过程中,操作这些对象 可以解耦合,提过程序的可扩展性 获取Class对象的三种方式 Object ——&gt; getClass(); 多用于对象的获取字节码的方式 任何数据类型（包括基本数据类型）都有一个“静态”的class属性 多用于参数的传递 通过Class类的静态方法：forName（String className）(常用) 对用于配置文件,将类名定义在配置文件中,读取文件,加载类. 结论: 同一个字节码文件(*.class)在一次程序运行过程中,只会被加载一次,不论通过哪一种方式获取的class对象都是同一个. class类对象功能 获取功能: 获取成员变量们 Fileld[] getFields() :获取所有public修饰的成员变量的 Fileld getField(String name) :获取特定名称的public修饰成员变量 Field[] getDeclaredFields() :获取所有的成员变量 Field getDeclaredField(String name):获取特定名称的成员变量 获取构造方法们 Constructor&lt;?&gt;[] getConstructors() Constructor getConstrucotr(Class&lt;?&gt;…parameterTypes) Constructor getDeclaredConstructor(Class&lt;?&gt;… parameterTypes) Constructor&lt;?&gt;[] getDeclaredConstructors() 获取成员方法们: Method[] getMethods() Method getMethod(String name,Class&lt;?&gt;…parameterTypes) Method[] getDeclaredMethods() Method getDeclaredMethod(String name,Class&lt;?&gt;… parameterTypes) 获取类名: String getName() Filed: 成员变量 操作 设置值 void set(Object obj,Object value) 获取值 get(Object obj) 用于忽略访问权限修饰符的安全检查. setAccsessible(true) //暴力反射 Constructor:构造方法 创建对象: T newInstance(Object…initargs) 如果使用空参构造方法创建对象,操作可以简化:Class对象的newInstance方法 Method:方法对象 执行方法: Object invoke(Object obj, Object… args) 获取方法名称: String getName:获取方法名]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>反射</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Junit测试]]></title>
    <url>%2F2019%2F07%2F07%2FJunit%E6%B5%8B%E8%AF%95%2F</url>
    <content type="text"><![CDATA[Junit测试Junit单元测试: 测试分类: 黑盒测试:不需要写代码,给输入值,看程序是否能够输出预期的值 白盒测试:需要编写代码,关注程序具体的执行流程 Junit使用:白盒测试 步骤 定义一个测试类(测试用例) 建议: 测试类名:被测试的类名Test CalculatorTest 包名:xxx.xxx.xx.test cn.itcast.test 定义测试方法:可以独立运行 建议: 方法名:test测试的方法名 testAdd() 返回值:void 参数列表:空参 给方法加上@Test注解 导入Junit依赖环境 判定结果: 红色:失败 绿色:成功 一般我们会使用断言操作来处理结果 Assert.assertEquals(期望的结果,运算的结果); 补充: @Before: 修饰的方法会在测试方法之前被自动执行 @After: 修饰的方法会在测试方法执行之后被自动执行]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>测试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git命令]]></title>
    <url>%2F2019%2F05%2F14%2Fgit%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[git常用操作：git init:使用 git init 在目录中创建新的 Git 仓库。 你可以在任何时候、任何目录中这么做，完全是本地化的。 git clone: 使用 git clone 拷贝一个 Git 仓库到本地，让自己能够查看该项目，或者进行修改。 git add:使用git add 命令可将该文件添加到缓存。新项目中，添加所有文件很普遍，我们可以使用 git add . 命令来添加当前项目的所有文件。 git status: 使用git status 命令用于查看项目的当前状态。 git diff: 执行 git diff 来查看执行 git status 的结果的详细信息。 git commit:使用 git add 命令将想要快照的内容写入缓存区， 而执行 git commit 将缓存区内容添加到仓库中 git reset HEDA:git reset HEAD 命令用于取消已缓存的内容。执行 git reset HEAD 以取消之前 git add 添加，但不希望包含在下一提交快照中的缓存。 git rm:如果只是简单地从工作目录中手工删除文件，运行 git status 时就会在 Changes not staged for commit 的提示。要从 Git 中移除某个文件，就必须要从已跟踪文件清单中移除，然后提交。git rm 如果删除之前修改过并且已经放到暂存区域的话，则必须要用强制删除选项 -f 即：git rm -f 如果把文件从暂存区域移除，但仍然希望保留在当前工作目录中，换句话说，仅是从跟踪清单中删除，使用 –cached 选项即可 即：git rm –cached git mv:git mv 命令用于移动或重命名一个文件、目录、软连接。 git diff执行 git diff 来查看执行 git status 的结果的详细信息。 git diff 命令显示已写入缓存与已修改但尚未写入缓存的改动的区别。git diff 有两个主要的应用场景。 尚未缓存的改动：git diff 查看已缓存的改动： git diff –cached 查看已缓存的与未缓存的所有改动：git diff HEAD 显示摘要而非整个 diff：git diff –stat Git分支管理:乎每一种版本控制系统都以某种形式支持分支。使用分支意味着你可以从开发主线上分离开来，然后在不影响主线的同时继续工作。 有人把 Git 的分支模型称为必杀技特性，而正是因为它，将 Git 从版本控制系统家族里区分出来。 创建分支命令: git branch (branchname) 切换分支命令:git checkout (branchname) 你切换分支的时候，Git 会用该分支的最后提交的快照替换你的工作目录的内容， 所以多个分支不需要多个目录。 我们也可以使用 git checkout -b (branchname) 命令来创建新分支并立即切换到该分支下，从而在该分支中操作。 合并分支命令: git merge 你可以多次合并到统一分支， 也可以选择在合并之后直接删除被并入的分支 列出分支命令:git branch 删除分支命令:git branch -d (branchname) 分支合并命令:git merge (branchname) 一旦某分支有了独立内容，你终究会希望将它合并回到你的主分支。 你可以使用git merge命令branchname分支合并到当前分支中去 Git远程仓库:git remote:添加远程仓库,git remote add [shortname] [url] 由于你的本地 Git 仓库和 GitHub 仓库之间的传输是通过SSH加密的，所以我们需要配置验证信息： 使用以下命令生成 SSH Key： ssh-keygen -t rsa -C “email@xx.XXX“ git remote:查看当前的远程库 执行时加上 -v 参数，你还可以看到每个别名的实际链接地址。 git fetch:提取远程仓库,从远程仓库下载分支与数据git fetch origin git merge:从远程仓库提取数据并尝试合并到当前分支git merge origin/master git push:推送你的新分支与数据到某个远端仓库命令:,git push [alias] [branch] git push &lt;远程主机名&gt; &lt;本地分支名&gt; &lt;远程分支名&gt; 如果远程分支被省略，则表示将本地分支推送到与之存在追踪关系的远程分支（通常两者同名），如果该远程分支不存在，则会被新建 如果省略本地分支名，则表示删除指定的远程分支，因为这等同于推送一个空的本地分支到远程分支，等同于 git push origin –delete master 如果当前分支与远程分支存在追踪关系，则本地分支和远程分支都可以省略，将当前分支推送到origin主机的对应分支 git push -u origin master 如果当前分支与多个主机存在追踪关系，则可以使用 -u 参数指定一个默认主机，这样后面就可以不加任何参数使用git push，不带任何参数的git push，默认只推送当前分支，这叫做simple方式 git remote rm [别名]:删除远程仓库 git pull 获取并合并其他的厂库，或者本地的其他分支。git pull &lt;远程主机&gt; &lt;远程分支&gt;:&lt;本地分支&gt; 文件夹上传到github库：git init //把这个目录变成Git可以管理的仓库 git add README.md //文件添加到仓库 git add . //不但可以跟单一文件，还可以跟通配符，更可以跟目录。一个点就把当前目录下所有未追踪的文件全部add了 git commit -m “first commit” //把文件提交到仓库 git remote add origin git@github.com:yourname/youremail.git //关联远程仓库 git pull –rebase origin master //代码合并 git push -u origin master //把本地库的所有内容推送到远程库上]]></content>
      <tags>
        <tag>git</tag>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring的相关配置]]></title>
    <url>%2F2019%2F04%2F29%2FSpring%E7%9A%84%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[基本概念 IOC:(Inverse of Control)控制反转 将对象的创建权反转(交给)Spring DI:(Dependency Injection)依赖注入 前提必须得有IOC的环境,Spring管理这个类的时候将类的依赖的属性注入(设置)进来 AOP:(Aspect Oriented Programming)面向切面编程 通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。 AOP是OOP(面相对象编程)的扩展和延伸,解决AOP开发中遇到的一些问题. XML提示的配置​ Scheme的配置 Bean的相关配置(XML) 标签的id和name的配置 大部分情况下作用相同 id :使用了约束中的唯一约束.里面不能出现特殊字符 name: 没有使用约束中的唯一约束(理论上可以出现重复的,但是实际开发不能出现的),name里面可以出现特殊字符 Bean的生命周期的配置 init-method :Bean被初始化的时候执行的方法 destroy :Bean被销毁的时候执行的方法 执行条件（1.Bean是单例创建的（默认就是单例创建的） 2.工厂关闭） 如果是多例模式下不知道销毁哪个所以就不会销毁。 Bean的作用范围的配置 scope :Bean的作用范围 singleton :默认的，Spring会采用单例模式来创建这个对象 prototype :多例模式 request :应用在web项目中，Spring创建这个类以后，将这个类存入到request范围中。 session :应用在web项目中，Spring创建这个类以后，将这个类存入到session范围中。 globalsession:应用在web项目中，必须在porlet环境下使用，如果没有这种环境，相当于session。 开发中常用的就是singleton和prototype Spring的属性注入（给Bean中的属性设置值）的方式 构造方法的方式属性注入: 123456 &lt;!-- Spring属性注入的方式 --&gt; &lt;!-- 构造方法的方式 --&gt; &lt;bean id="car" class="spring.demo3.Car"&gt; &lt;constructor-arg name="name" value="宝马"/&gt; &lt;constructor-arg name="price" value="800000"/&gt;&lt;/bean&gt; Set方法的方式的属性注入: 12345&lt;!-- set方法的方式 --&gt; &lt;bean id="car2" class="spring.demo3.Car2"&gt; &lt;property name="name" value="奔驰"/&gt; &lt;property name="price" value="1000000"/&gt; &lt;/bean&gt; 123456&lt;!-- set方法注入对象类型的属性 --&gt; &lt;bean id="employee" class="spring.demo3.Employee"&gt; &lt;property name="name" value="涛哥"/&gt; &lt;!-- value:设置普通属性类型的值 ref:用来设置其他类的id和name --&gt; &lt;property name="car2" ref="car2"/&gt; &lt;/bean&gt; P名称空间的属性注入(Spring2.0以后) 通过引入p名称空间完成属性的注入 写法: 普通属性: p:属性名=”值” 对象属性: p:属性名-ref=”值” 引入p名称空间 1xmlns:p="http://www.springframework.org/schema/p" 1234 &lt;!-- 改为p名称空间的方式 --&gt; &lt;bean id="car2" class="spring.demo3.Car2" p:name="奇瑞qq" p:price="30000"&gt;&lt;/bean&gt;&lt;!-- p名称空间的方式来注入对象类型 --&gt; &lt;bean id="employee" class="spring.demo3.Employee" p:name="王东" p:car2-ref="car2"&gt;&lt;/bean&gt; SpEL的属性注入(Spring3.0以后) SpEL(Spring Expression Language) :Spring的表达式语言 语法: #{SpEL} 1234567891011121314 &lt;!-- SpEL方式属性注入 --&gt;&lt;bean id="carInfo" class="spring.demo3.CarInfo"&gt;&lt;/bean&gt;&lt;bean id="car2" class="spring.demo3.Car2"&gt; &lt;property name="name" value="#&#123;carInfo.name&#125;"&gt;&lt;/property&gt; &lt;property name="price" value="#&#123;carInfo.calculatorPrice()&#125;"&gt;&lt;/property&gt;&lt;/bean&gt; &lt;bean id="employee" class="spring.demo3.Employee"&gt; &lt;property name="name" value="#&#123;'张三'&#125;"&gt;&lt;/property&gt; &lt;property name="car2" value="#&#123;car2&#125;"&gt;&lt;/property&gt;&lt;/bean&gt; 集合类型属性的注入 数组类型,list类型,set类型,map类型 12345678910111213141516171819202122232425262728293031323334353637383940414243 &lt;!-- Spring的集合属性的注入 --&gt; &lt;bean id="collectionBean" class="spring.demo4.CollectionBean"&gt; &lt;!-- 注入数组类型 --&gt; &lt;property name="arrs" &gt; &lt;list&gt; &lt;!-- &lt;ref/&gt; 引入对象类型 --&gt; &lt;value&gt;王东&lt;/value&gt; &lt;!-- 引入一般类型 --&gt; &lt;value&gt;赵红&lt;/value&gt; &lt;value&gt;李冠希&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;!-- 注入List集合类型 --&gt; &lt;property name="list" &gt; &lt;list&gt; &lt;!-- &lt;ref/&gt; 引入对象类型 --&gt; &lt;value&gt;小明&lt;/value&gt; &lt;!-- 引入一般类型 --&gt; &lt;value&gt;小红&lt;/value&gt; &lt;value&gt;小狗&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;!-- 注入Set集合类型--&gt; &lt;property name="set" &gt; &lt;set&gt; &lt;!-- &lt;ref/&gt; 引入对象类型 --&gt; &lt;value&gt;aaa&lt;/value&gt; &lt;!-- 引入一般类型 --&gt; &lt;value&gt;bbb&lt;/value&gt; &lt;value&gt;ccc&lt;/value&gt; &lt;/set&gt; &lt;/property&gt; &lt;!-- 注入Map集合 --&gt; &lt;property name="map"&gt; &lt;map&gt; &lt;entry key="aaa" value="111"/&gt; &lt;entry key="bbb" value="222"/&gt; &lt;entry key="ccc" value="333"/&gt; &lt;/map&gt; &lt;/property&gt; &lt;/bean&gt; Spring分模块开发的配置 在加载配置文件的时候,加载多个 1ApplicationContext applicationContext = new ClassPathXmlApplicationContext("applicationContext.xml","applicationContext2.xml"); 在一个配置文件中引入多个配置文件 12&lt;!-- 引入多个配置文件 --&gt; &lt;import resource="applicationContext2.xml"/&gt; Spring 的IOC的注解的详解(注解)12&lt;!-- 使用IOC的注解开发，配置组件扫描(要在哪些包下的类使用IOC的注解) --&gt; &lt;context:component-scan base-package="spring"&gt;&lt;/context:component-scan&gt; @Component:组件 修饰一个类，将这个类交给Spring管理相当于 &lt;bean id=&quot;orderDao&quot; class=&quot;spring.demo1.OrderDao&quot;&gt;&lt;/bean&gt; 这个注解有三个衍生注解（功能类似），修饰类 Controller: web层 Service: servcice层 Repository: dao层 属性注入的注解 普通属性： @Value:设置普通属性的值 对象类型属性： @Autowired:设置对象类型的属性的值,但是是按照类型完成属性的注入. 我们习惯是按照名称完成属性的注入,必须让@AutoWired和@Qualifier(value=”id”)一起使用完成按照名称属性注入. @Resource:完成对象类型的属性的注入,按照名称完成属性注入. Bean的其他的注解 生命周期相关的注解 @PostConstruct:初始化方法 @PreDestory: 销毁方法 Bean作用范围的注解 @Scope singleton :默认的，Spring会采用单例模式来创建这个对象 prototype :多例模式 request :应用在web项目中，Spring创建这个类以后，将这个类存入到request范围中。 session :应用在web项目中，Spring创建这个类以后，将这个类存入到session范围中。 globalsession:应用在web项目中，必须在porlet环境下使用，如果没有这种环境，相当于session。 开发中常用的就是singleton和prototype XML模式和注解模式的比较 使用场景 XML:可以适用于任何场景,结构清晰,维护方便 注解:如果这个类不是我们提供的,那么无法使用注解,开发方便 整合开发 XML管理Bean,注解完成属性注入 Spring 的AOP的开发(XML) Spring的AOP的简介 AOP思想最早是由AOP联盟组织提出的,Spring是使用这种框架最好的组织.Spring的AOP自己的实现方式非常繁琐,AspectJ是一个AOP的框架,后来Spring引入AspectJ作为自身AOP的开发. Spring两套AOP开发的方式 Spring传统方式(弃用) Spring基于ASpectJ的AOP的开发(使用) Spring底层的AOP实现原理 动态代理： JDK的动态代理 只能对实现了接口的类产生代理(自动的) Cglib的动态代理 对没有实现接口的类产生代理对象,产生子类对象 AOP开发中相关的术语 JoinPoint(连接点):可以被拦截到的点,增删改查的方法都可以被增强,这些方法就可以被称为是连接点 Pointcut(切入点):真正被拦截到的点,在实际开发中只对save方法进行了增强,所以save方法就称为是切入点 Advice(通知,增强):方法层面的增强.现在对save方法进行权限校验,权限校验的方法称之为通知 Introduction(引介):类层面的增强 Target(目标):被增强的对象,UserDao称之为是目标 weaving(织入):将通知应用到目标的过程,将权限校验的方法的代码应用到UserDao的save方法的过程,织入后产生结果代理类(Proxy) Aspect(切面):多个通知和多个切入点组合!!! AspectJ的XML的方式 引入基本的开发包(6个) 引入AOP开发的相关Jar包(4个) 引入Spring的配置文件 引入aop的约束 123456789101112131415161718192021222324252627282930&lt;aop:config&gt; &lt;!-- expression=表达式的配置来决定哪些类的那些方法需要进行增强(切入点) --&gt; &lt;aop:pointcut expression="execution(* spring.demo2.ProductDaoImpl.save(..))" id="pointcut1"/&gt; &lt;aop:pointcut expression="execution(* spring.demo2.ProductDaoImpl.delete(..))" id="pointcut2"/&gt; &lt;aop:pointcut expression="execution(* spring.demo2.ProductDaoImpl.update(..))" id="pointcut3"/&gt; &lt;aop:pointcut expression="execution(* spring.demo2.ProductDaoImpl.find(..))" id="pointcut4"/&gt; &lt;!-- 配置切面 --&gt; &lt;aop:aspect ref="myAspect"&gt; &lt;!-- 前置通知 --&gt; &lt;!-- 在pointcut1这个切入点的前面应用checkPri方法 --&gt; &lt;aop:before method="checkPri" pointcut-ref="pointcut1"/&gt; &lt;!-- 后置通知 --&gt; &lt;!-- 在pointcut2这个切入点的后面应用writelog方法 --&gt; &lt;aop:after-returning method="writelog" pointcut-ref="pointcut2" returning="result"/&gt; &lt;!-- 环绕通知 --&gt; &lt;!-- 在pointcut3这个切入点环绕around方法 --&gt; &lt;aop:around method="around" pointcut-ref="pointcut3"/&gt; &lt;!-- 异常抛出通知 --&gt; &lt;!-- 在pointcut3这个切入点加入异常抛出通知afterThrowing方法 --&gt; &lt;aop:after-throwing method="afterThrowing" pointcut-ref="pointcut4" throwing="ex"/&gt; &lt;!-- 最终通知 --&gt; &lt;!-- 在pointcut3这个切入点加入异常抛出通知afterThrowing方法 --&gt; &lt;aop:after method="after" pointcut-ref="pointcut4"/&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt; Spring中的通知类型 前置通知 在目标方法执行之前进行操作 配置前置通知 12345&lt;!-- 配置切面 --&gt; &lt;aop:aspect ref="myAspect"&gt; &lt;!-- 在pointcut1这个切入点的前面应用checkPri方法 --&gt; &lt;aop:before method="checkPri" pointcut-ref="pointcut1"/&gt; &lt;/aop:aspect&gt; * 可以获得切入点信息 * 12public void checkPri(JoinPoint joinpoint)&#123;System.out.println("权限校验..."+joinpoint); 后置通知 在目标方法执行之后进行操作 配置后置通知 123&lt;!-- 后置通知 --&gt; &lt;!-- 在pointcut2这个切入点的后面应用writelog方法 --&gt; &lt;aop:after-returning method="writelog" pointcut-ref="pointcut2" returning="result"/&gt; * 可以获得方法返回值 * 123public void writelog(Object result)&#123; System.out.println("日志记录..."+result); &#125; 环绕通知 在目标方法执行前和后进行操作 配置环绕通知 123&lt;!-- 环绕通知 --&gt; &lt;!-- 在pointcut3这个切入点环绕around方法 --&gt; &lt;aop:around method="around" pointcut-ref="pointcut3"/&gt; * 可以阻止目标方法的执行 异常抛出通知 在程序出现异常的时候进行的操作 配置异常抛出通知 123&lt;!-- 异常抛出通知 --&gt; &lt;!-- 在pointcut3这个切入点加入异常抛出通知afterThrowing方法 --&gt; &lt;aop:after-throwing method="afterThrowing" pointcut-ref="pointcut4" throwing="ex"/&gt; * 123public void afterThrowing(Throwable ex)&#123; System.out.println("异常抛出通知..."+ex.getMessage()); &#125; 最终通知 无论代码是否有异常总是会执行的操作 配置最终通知 123&lt;!-- 最终通知 --&gt; &lt;!-- 在pointcut3这个切入点加入异常抛出通知afterThrowing方法 --&gt; &lt;aop:after method="after" pointcut-ref="pointcut4"/&gt; * 12345/** *最终通知:相当于finally代码块中的内容 */ public void after()&#123; System.out.println("最终通知..."); Spring的切入点表达式写法 基于execution的函数完成的 语法 [访问修饰符] 方法返回值 包名.类名.方法名(参数) public void spring.demo2.ProductDaoImpl.save(..) *为通配符 +表示该类和子类 ..表示该包和子包 Spring 的AOP的开发(注解) AspectJ的注解的方式 引入基本的6个jar包 引入aspectJ相关的4个jar包 引入配置文件 编写目标类并配置 编写切面类并配置 使用注解的AOP对目标类进行增强 在配置文件中去打开注解的AOP开发 &lt;aop:aspectj-autoproxy/&gt; 1234567@Aspectpublic class MyAspectAnno &#123; @Before(value="execution(* spring.demo1.OrderDao.save(..))" ) public void before()&#123; System.out.println("前置增强..."); &#125;&#125; 1234567891011121314@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration("classpath:applicationContext.xml")public class SpringDemo1 &#123; @Resource(name="orderDao") private OrderDao orderDao; @Test public void demo1()&#123; orderDao.save(); orderDao.update(); orderDao.find(); orderDao.delete(); &#125;&#125; Spring的注解的AOP的通知类型 @Before: 前置通知 @AfterReturning:后置通知 @Around: 环绕通知 @AfterThrowing: 异常抛出通知 @After: 最终通知 Spring的AOP的切入点的配置 123//切入点注解: @Pointcut(value="execution(* spring.demo1.OrderDao.find(..))") private void pointcut1()&#123;&#125; Spring的JDBC的模板的使用 Spring的JDBC的模板 Spring是EE开发的一站式的框架,有EE开发的每层的解决方案,Spring对持久层也提供了解决方案,ORM模块和JDBC的模板. JDBC模板的使用 引入基本的6的jar包 引入数据库驱动jar包 引入Spring的JDBC模板的jar包 引入单元测试的jar包 创建数据库和表springt.account 使用JDBC的模板:保存数据 123456789101112131415public class JdbcDemo1 &#123; @Test public void demo1()&#123; //创建连接池 DriverManagerDataSource dataSource = new DriverManagerDataSource(); dataSource.setDriverClassName("com.mysql.jdbc.Driver"); dataSource.setUrl("jdbc:mysql:///springt"); dataSource.setUsername("root"); dataSource.setPassword("975864"); //创建jdbc模板 JdbcTemplate jdbcTemple = new JdbcTemplate(dataSource); jdbcTemple.update("insert into account values (null,?,?)", "xiaohu",10000d); &#125;&#125; 将连接池和模板都交给Spring管理 引入Spring的配置文件 123456789101112&lt;!-- 配置Spring内置的连接池 --&gt; &lt;bean id="dataSource" class="org.springframework.jdbc.datasource.DriverManagerDataSource"&gt; &lt;!-- 属性注入 --&gt; &lt;property name="driverClassName" value="com.mysql.jdbc.Driver"/&gt; &lt;property name="url" value="jdbc:mysql:///spring5"/&gt; &lt;property name="username" value="root"/&gt; &lt;property name="password" value="975864"/&gt; &lt;/bean&gt; &lt;!-- 配置SpringJDBC的模板 --&gt; &lt;bean id="jdbcTemplate" class="org.springframerwork.jdbc.core.JdbcTemplate"&gt; &lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt; &lt;/bean&gt; 使用Spring 的数据库连接池和jdbc模板 1234567891011@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration("classpath:applicationContext.xml")public class JdbcDemo2 &#123; @Resource(name="jdbcTemplate") private JdbcTemplate jdbcTemple; @Test public void demo1()&#123; jdbcTemple.update("insert into account values (null,?,?)", "小天",100d); &#125;&#125; 使用开源的数据库连接池 DBCP的使用 引入两个jar包(dbcp和pool) 配置DBCP连接池 1234567&lt;!-- 配置DBCP连接池 --&gt;&lt;bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource"&gt; &lt;property name="driverClassName" value="com.mysql.jdbc.Driver"/&gt; &lt;property name="url" value="jdbc:mysql:///springt"/&gt; &lt;property name="username" value="root"/&gt; &lt;property name="password" value="975864"/&gt;&lt;/bean&gt; C3P0的使用 引入c3p0的jar包 配置C3P0连接池 123456789&lt;!-- 配置C3P0连接池 --&gt; &lt;bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource"&gt; &lt;property name="driverClass" value="com.mysql.jdbc.Driver"/&gt; &lt;property name="jdbcUrl" value="jdbc:mysql:///springt"/&gt; &lt;property name="user" value="root"/&gt; &lt;property name="password" value="975864"/&gt; &lt;/bean&gt; 抽取配置到属性文件 定义一个属性文件 1234jdbc.driverClass=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql:///springtjdbc.username=rootjdbc.password=975864 在Spring的配置文件中引入属性文件 123456&lt;!-- 第一种方式通过一个bean标签引入(很少用) --&gt;&lt;!-- &lt;bean class="org.springframework.beans.factory.config.PropertyPlaceholderConfigurer"&gt; &lt;property name="location" value="classpath:jdbc.properties"&gt;&lt;/property&gt; &lt;/bean&gt; --&gt; &lt;!-- 第二种方式通过context标签引入 --&gt; &lt;context:property-placeholder location="calsspath:jdbc.properties"/&gt; 引入属性文件的值 123456&lt;bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource"&gt; &lt;property name="driverClass" value="$&#123;jdbc.driverClass&#125;"/&gt; &lt;property name="jdbcUrl" value="$&#123;jdbc.url&#125;"/&gt; &lt;property name="user" value="$&#123;jdbc.username&#125;"/&gt; &lt;property name="password" value="$&#123;jdbc.password&#125;"/&gt; &lt;/bean&gt; 使用JDBC的模板完成CRUD的操作 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration("classpath:applicationContext.xml")public class JdbcDemo2 &#123; @Resource(name="jdbcTemplate") private JdbcTemplate jdbcTemple; //增删改的操作相同 @Test //保存操作 public void demo1()&#123; jdbcTemple.update("insert into account values (null,?,?)", "小水",1000d); &#125; @Test //修改操作 public void demo2()&#123; jdbcTemple.update("update account set name=?,money=? where id=?","李四",2000d,5); &#125; @Test //删除操作 public void demo3()&#123; jdbcTemple.update("delete from account where id=?",6); &#125; @Test //查询操作:查询名称 public void demo4()&#123; String name = jdbcTemple.queryForObject("select name from account where id=?", String.class,5); System.out.println(name); &#125; @Test //查询操作:查询记录总条数 public void demo5()&#123; Long count = jdbcTemple.queryForObject("select count(*) from account", Long.class); System.out.println(count); &#125; @Test //查询操作:查询一条记录封装到一个对象中 public void demo6()&#123; Account account = jdbcTemple.queryForObject("select * from account where id=?", new MyRowMapper(), 5); System.out.println(account); &#125; @Test //查询操作:查询多条记录封装到一个List集合中 public void demo7()&#123; List&lt;Account&gt; list = jdbcTemple.query("select * from account ", new MyRowMapper()); for (Account account : list) &#123; System.out.println(account); &#125; &#125; class MyRowMapper implements RowMapper&lt;Account&gt;&#123; @Override public Account mapRow(ResultSet rs, int rowNum) throws SQLException &#123; Account account = new Account(); //通过account属性的set方法里利用查询到的数据,封装成一个account对象并返回 account.setId(rs.getInt("id")); account.setName(rs.getString("name")); account.setMoney(rs.getDouble("money")); return account; &#125; &#125;&#125; Spring的事务管理 事物的回顾: 事务:逻辑上的一组操作,组成这组操作的各个单元,要么全部成功,要么全部失败 事务的特性 原子性:事务不可分割 一致性:事务执行前后数据完整性保持一致 隔离性:一个事务的执行不应该受到其他事务的干扰 持久性:一旦事务结束,数据就持久化到数据库 如果不考虑隔离性将会引发安全性问题 读问题: 脏读:一个事务读到另一个事务未提交的数据 不可重复读:一个事务读到另一个事务已经提交的Update的数据,导致一个事务中多次查询的结果不一致 虚读,幻读:一个事务读到另一个事务已经提交的insert的数据,导致一个事务中多次查询的结果不一致 写问题: 丢失更新 解决读问题 设置事务的隔离级别: Read uncommitted:未提交读,任何读问题都解决不了但是效率高 Read committed:已提交读,解决脏读,但是不可重复读和虚读可能发生 Repeatable:重复读,解决脏读和不可重复读,但是虚读可能发生 Serializable:解决所有读问题,但是效率低,一般设置问2,3两个级别 Spring事务管理的API Platform TransactionManager:平台事务管理器 平台事务管理器:接口,是Spring用于管理事务的真正的对象 DataSourceTransactionManager:底层使用JDBC管理事务 HibernateTransactionManager:底层使用Hibernat管理事务 TransactionDefinition:事务定义信息 事务定义:用于定义事务的相关的信息,隔离级别,超时信息,传播行为,是否只读 TransactionStatus:事务的状态 事务状态:用于管理事务运行过程中,事务的状态的对象 事务管理的 API 的关系 Spring进行事务管理的时候,首先平台事务管理器根据事务定义信息进行事务的管理 ,在事务管理过程中,产生各种状态,将这些状态信息记录到事务状态的对象 Spring的事务的传播行为 Spring中提供了七种传播行为 保证多个操作在同一个事务中 propagation: 增殖, 广传, 繁殖 PROPAGATION_REQUIRED :默认值,如果A中有事务就会使用A中的事物,如果A中没有事务,创建一个新事物,将操作包含进来 PROPAGATION_SUPPORTS:支持事务,如果A中有事务,使用A中的事务,如果A中没有事务,不使用事务 PROPAGATION_MANDATORY:如果A中有事务,使用A中的事务,如果A中没有事务,抛出异常 保证多个操作不在同一个事务中 PROPAGATION_REQUIRES_NEW:如果A中有事务,将A的事务挂起(暂停),创建新事务,只包含自身操作,如果A中没有事务,创建一个新事务,包含自身的操作 PROPAGATION_NOT_SUPPORTED:如果A中有事务,将A的事务挂起,不使用事务管理 PROPAGATION_NEVER:如果A中有事务,报异常 嵌套式事务 PROPAGATION_NESTED:如果A中有事务,按照A的事务执行,执行完之后设置一个保存点,执行B中的操作,如果没有异常,执行通过,如果有异常,可以选择回滚到最初始的位置也可以选择回滚到保存点 事务的传播行为主要用来解决业务层方法相互调用的问题 Spring事务管理 搭建Spring事务管理的环境 创建Service的接口和实现类 1234567891011121314151617181920public class AccountServiceImpl implements AccountService&#123; //注入DAO private AccountDao accountDao; public void setAccountDao(AccountDao accountDao) &#123; this.accountDao = accountDao; &#125; @Override /** * from:转出账号 * to:转入账号 * money:转账金额 */ public void transfer(String from, String to, Double money) &#123; accountDao.outMoney(from,money); accountDao.inMoney(to, money); &#125;&#125; * 创建DAO的接口和实现类 12345678910111213public class AccountDaoImpl extends JdbcDaoSupport implements AccountDao&#123; @Override public void outMoney(String from, Double money) &#123; this.getJdbcTemplate().update("update account set money = money - ? where name = ?", money,from); &#125; @Override public void inMoney(String to, Double money) &#123; this.getJdbcTemplate().update("update account set money = money + ? where name = ?", money,to); &#125;&#125; * 配置Service和DAO交给Spring管理 12345678910&lt;!-- 配置Service======= --&gt;&lt;bean id="accountService" class="tx.demo1.AccountServiceImpl"&gt; &lt;property name="accountDao" ref="accountDao"/&gt;&lt;/bean&gt; &lt;!-- 配置Dao======= --&gt;&lt;bean id="accountDao" class="tx.demo1.AccountDaoImpl"&gt;&lt;/bean&gt; * 在DAO中写SQL语句控制 * 配置连接池 1234567&lt;!-- 配置C3P0连接池 --&gt; &lt;bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource"&gt; &lt;property name="driverClass" value="$&#123;jdbc.driverClass&#125;"/&gt; &lt;property name="jdbcUrl" value="$&#123;jdbc.url&#125;"/&gt; &lt;property name="user" value="$&#123;jdbc.username&#125;"/&gt; &lt;property name="password" value="$&#123;jdbc.password&#125;"/&gt; &lt;/bean&gt; * 在DAO中注入Jdbc的模板 12345&lt;!-- 配置Dao======= --&gt;&lt;bean id="accountDao" class="tx.demo1.AccountDaoImpl"&gt;&lt;!-- &lt;property name="jdbcTemplate" ref="jdbcTemple"&gt;&lt;/property&gt; --&gt;&lt;!-- 因为我们的类继承了JdbcDaoSupport所以我们需要JDBC模板的时候只要传给他一个连接池,他就会自动生成一个模板给我们 --&gt;&lt;property name="dataSource" ref="dataSource"/&gt; 编程式事务管理(需要手动编写代码) 配置平台事务管理器: 1234&lt;!-- 配置平台事务管理器====== --&gt;&lt;bean id="transactionManager" class="org.springframework.jdbc.darasource.DataSourceTransactionManager"&gt;&lt;property name="dataSource" ref="dataSource"/&gt;&lt;/bean&gt; 配置事务管理的模板类 1234&lt;!-- 配置事务管理的模板 --&gt;&lt;bean id="transactionTemplate" class="org.springframework.transaction.support.TransactoinTemplate"&gt; &lt;property name="transactionManager" ref="transactionManager"/&gt;&lt;/bean&gt; 在业务层注入事务管理的模板 12345//注入事务管理的模板 private TransactionTemplate transactionTemplate; public void setTransactionTemplate(TransactionTemplate transactionTemplate) &#123; this.transactionTemplate = transactionTemplate; &#125; 1234567&lt;!-- 配置Service======= --&gt; &lt;bean id="accountService" class="tx.demo1.AccountServiceImpl"&gt; &lt;property name="accountDao" ref="accountDao"/&gt; &lt;!-- 注入事务管理的模板 --&gt; &lt;property name="transactionTemplate" ref="transactionTemplate"/&gt; &lt;/bean&gt; 声明式事务管理 XML方式的声明式事务管理 引入AOP的四个开发包 配置事务管理器 1234&lt;!-- 配置事务管理器=== --&gt;&lt;bean id="transactionManager" class="org.springframework.jdbc.datasource.DatasourceTransactionManager"&gt; &lt;property name="dataSource" ref="dataSource"/&gt;&lt;/bean&gt; 配置事务的增强 123456&lt;!-- 配置事务的增强=== --&gt; &lt;tx:advice transaction-manager="transactionManager"&gt; &lt;tx:attributes&gt; &lt;tx:method name="transfer" propagation="REQUIRED"/&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt; AOP的配置 12345&lt;!-- AOP的配置==== --&gt; &lt;aop:config&gt; &lt;aop:pointcut expression="execution(* tx.demo2.AccountServiceImpl.*(..))" id="pointcut1"/&gt; &lt;aop:advisor advice-ref="txAdvice" pointcut-ref="pointcut1"/&gt; &lt;/aop:config&gt; 注解方式的声明式事务管理 引入aop开发的jar包 配置事务管理器 开启注解事务 12&lt;!-- 开启注解事务==== --&gt; &lt;tx:annotation-driven transaction-manager="transactionManager"/&gt; 添加注解 12@Transactionalpublic class AccountServiceImpl implements AccountService&#123;]]></content>
      <categories>
        <category>Java</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux使用心得]]></title>
    <url>%2F2019%2F04%2F27%2FLinux%E4%BD%BF%E7%94%A8%E5%BF%83%E5%BE%97%2F</url>
    <content type="text"><![CDATA[Linux中的常用命令Linux下权用户组/用户/权限管理命令groupadd:添加用户组groupadd命令格式: ​ groupadd [选项] 组名 选项: -g GID:指定组ID groupdel:删除用户组groupdel命令格式: ​ groupdel 组名 但这个组中要没有初始用户,因为不能让一个用户没有初始组 useradd:添加用户useradd命令格式: ​ useradd [选项] 用户名 选项: -u UID:手工指定用户的UID号 -d 家目录:手工指定用户的家目录 -c 用户说明:手工指定用户的说明 -g 组名:手工指定用户的初始组 -G 组名:指定用户的附加组 -s shell:手工指定用户的登录shell,默认是/bin/bash usermod:修改用户信息usermod命令格式: ​ usermod [选项] 用户名 选项: -u UID:修改用户的UID号 -c 用户说明:修改用户的说明信息 -G 组名:修改用户的附加组 -L:临时锁定用户(Lock) -U:解锁用户锁定(Unlock) userdel:删除用户userdel命令格式: ​ userdel [-r] 用户名 选项: -r:删除用户的同时删除用户家目录 passwd:修改用户密码passwd命令格式: ​ passwd [选项] 用户名 选项: -s: 查询用户密码的密码状态.仅root用户可用 -l:暂时锁定用户,仅root用户可用 -u:解锁用户,仅root用户可用 –stdin: 可以通过管道符输出的数据作为用户的密码 如不加用户名,则默认修改当前用户 chage:修改用户密码状态chage命令格式: ​ chage [选项] 用户名 选项: -l:列出用户的详细密码状态 -d 日期:修改密码最后一次更改日期 -m 天数:两次密码修改间隔 -M 天数:密码有效期 -W 天数:密码过期前警告天数 -I 天数:密码过期后宽限天数 -E 日期:账号失效时间 chown:改变文件或者目录的所有者命令英文原意:change file ownership 执行权限:所有用户 chown命令格式: ​ chown [用户] [文件或目录] chmod:权限管理命令命令英文原意:change the permissions mode of a file 执行权限:所有用户 chmod命令格式: ​ chmod [{ugoa} {+-=}{rwx}] [文件或目录] ​ chmod [mode=421] [文件或目录] 选项: ​ -R 递归修改]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式]]></title>
    <url>%2F2019%2F04%2F25%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[设计原则 找出应用中可能需要变化之处，把他们独立出来，不要和那些不需要变化的代码混在一起。 针对接口编程，而不是针对实现编程。 多用组合，少用继承。 为了交互对象之间的松耦合设计而努力。 类应该对扩展开放,对修改关闭。 设计模式策略模式 定义了算法族,分别封装起来,让他们之间可以互相替换,此模式让算法的变换独立于使用算法的客户。 观察者模式 定义了对象之间的一对多依赖，这样一来，当一个对象改变状态时，它的所有依赖者都会收到通知并自动更新。 装饰者模式​ 动态地将责任附加到对象上,若要扩展功能,装饰者提供了比继承更有弹性的替代方案。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>DesignMode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于java中的注解]]></title>
    <url>%2F2019%2F04%2F23%2F%E5%85%B3%E4%BA%8Ejava%E4%B8%AD%E7%9A%84%E6%B3%A8%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[什么是注解?定义 注解（Annotation），也叫元数据。一种代码级别的说明。它是JDK1.5及以后版本引入的一个特性，与类、接口、枚举是在同一个层次。它可以声明在包、类、字段、方法、局部变量、方法参数等的前面，用来对这些元素进行说明，注释。 练习代码 JDK中的三种注解 @Override 它的作用是对覆盖超类中方法的方法进行标记，如果被标记的方法并没有实际覆盖超类中的方法，则编译器会发出错误警告。 @Deprecated 它的作用是对不应该再使用的方法添加注解，当编程人员使用这些方法时，将会在编译时显示提示信息，它与javadoc里的@deprecated标记有相同的功能，准确的说，它还不如javadoc @deprecated，因为它不支持参数，使用@Deprecated的示例代码示例如下： @SuppressWarnings 其参数有：deprecation，使用了过时的类或方法时的警告unchecked，执行了未检查的转换时的警告fallthrough，当 switch 程序块直接通往下一种情况而没有 break 时的警告path，在类路径、源文件路径等中有不存在的路径时的警告serial，当在可序列化的类上缺少serialVersionUID 定义时的警告finally ，任何 finally 子句不能正常完成时的警告all，关于以上所有情况的警告12//以下注解的含义为: 抑制编译器发生警告信息(如果变量未使用或者未遵循泛型格式错误的不报警告) @SuppressWarnings(&#123; "unused", "rawtypes" &#125;) 注解的特点 注解和接口,类一样都是数据类型. 注解可以加在变量,方法,类上. 注解可以有属性也可以没有属性@override @Test(timeout=1000) 注解是有作用范围的(源码期间有效,编译期间有效,运行期间有效) 源码期间有效: String 类上的@Author,@Since,@See 作用:使用命令 javadoc 命令将当前的源码生成帮助文件,可以识别String类上的相关的注解. 编译期间有效:@Override,@Deprecated,@Suppresswarning 作用:告诉编译器部分信息 运行期间有效:@Test 作用当我们在我们当前的代码上以Junit方式运行时,Junit会运行方法上包含@Test注解的方法 自定义注解 格式: 12345678910public @interface 注解名称 &#123; //在注解中定义一个属性 public long timeout() default -1; //only primitive type, String, Class, annotation, enumeration are permitted or 1- dimensional arrays thereof //报错,原因是属性不支持自定义类类型 //public TestAnnotation aa(); //注解的属性支持的类型有:基本数据类型(4类8种),String,Class,Annotation(注解类型),枚举类型,以及以上类型的一维数组类型 &#125; 注解作用: 配置作用 配置:开发的时候部分信息不希望写死在程序中,例如数据库的用户名和密码,可以将用户名和密码存放在.txt,.properties,.xml文件中,利用程序来读取文件中的内容. 什么时候用注解来做配置 如果配置信息不会发生频繁的改动,例如Servlet路径,建议使用注解的形式. 如果配置信息需要发生频繁的修改,例如数据库的用户名和密码信息,建议采用传统方法(.txt,.xml,.properties).]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Java注解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ajax]]></title>
    <url>%2F2019%2F04%2F19%2FAjax%2F</url>
    <content type="text"><![CDATA[Ajax:是什么? 使用css和XHTML来表示。 使用DOM模型来交互和动态显示。 使用XMLHttpRequest来和服务器进行异步通信。 使用JavaScript来绑定和调用。 练习代码 有什么用? 咱们的网页如果想要刷新局部内容,那么需要重新载入整个网页,用户体验不是很好.就是为了解决局部刷新问题,其他部分不动,只改变更新了的地方. GET 还是 POST？与 POST 相比，GET 更简单也更快，并且在大部分情况下都能用。 然而，在以下情况中，请使用 POST 请求： 无法使用缓存文件（更新服务器上的文件或数据库） 向服务器发送大量数据（POST 没有数据量限制） 发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠 数据请求: Get 创建对象: 123456789101112131415161718function ajaxFunction()&#123; var xmlHttp; try&#123; // Firefox, Opera 8.0+, Safari xmlHttp=new XMLHttpRequest(); &#125; catch (e)&#123; try&#123;// Internet Explorer xmlHttp=new ActiveXObject("Msxml2.XMLHTTP"); &#125; catch (e)&#123; try&#123; xmlHttp=new ActiveXObject("Microsoft.XMLHTTP"); &#125; catch (e)&#123;&#125; &#125; &#125;return xmlHttp;&#125; 发送请求: 123456789101112131415//执行get请求 function get() &#123; //1.创建xmlhttprequest 对象 var request = ajaxFunction(); //2.发送请求 /* 参数1:请求类型 GET or POST 参数2:请求的路径 参数3:是否同步 true or false */ request.open("GET","/ajax/DemoServlet01",true); request.send(); &#125; ​ 如果发送请求的同时,还想获取数据,那么代码如下: 12345678910111213141516 //执行get请求function get() &#123; //1.创建xmlhttprequest 对象 var request = ajaxFunction(); //2.发送请求 request.open("GET","/ajax/DemoServlet01?name=aa&amp;age=18",true); //3.获取响应数据 注册监听的意思,一会儿准备的状态发生了改变,那么就执行等号右边的方法 request.onreadystatechange = function()&#123; //前半段表示已经能够正常处理,再判断状态码是否是200 if(request.readyState == 4 &amp;&amp; request.status == 200) &#123; //弹出响应的信息 alert(request.responseText); &#125; &#125; request.send();&#125; 数据请求: Post 创建对象: 123456789101112131415161718function ajaxFunction()&#123; var xmlHttp; try&#123; // Firefox, Opera 8.0+, Safari xmlHttp=new XMLHttpRequest(); &#125; catch (e)&#123; try&#123;// Internet Explorer xmlHttp=new ActiveXObject("Msxml2.XMLHTTP"); &#125; catch (e)&#123; try&#123; xmlHttp=new ActiveXObject("Microsoft.XMLHTTP"); &#125; catch (e)&#123;&#125; &#125; &#125;return xmlHttp;&#125; 发送请求: 1234567891011121314151617181920212223 function post() &#123; //1.创建对象 var request = ajaxFunction(); //2.发送请求 request.open("POST","/ajax/DemoServlet01",true); request.send();&#125; 如果发送请求的同时要带数据过去: function post() &#123; //1.创建对象 var request = ajaxFunction(); //2.发送请求 request.open("POST","/ajax/DemoServlet01",true); //如果使用的是post方式带数据,那么要添加头,说明提交的数据类型是一个经过url编码的form表单数据 request.setRequestHeader("Content-type","application/x-www-form-urlencoded"); //要将数据发送到服务器 在send方法里写表单数据 request.send("name=bb&amp;age=19");&#125; ​ 如果发送请求的同时,还想获取数据,那么代码如下: 12345678910111213141516171819202122//执行post请求 有响应的function post() &#123; //1.创建对象 var request = ajaxFunction(); //2.发送请求 request.open("POST","/ajax/DemoServlet01",true); //获取服务器传送过来的数据,加一个状态的监听. request.onreadystatechange=function() &#123; if(request.readyState == 4 &amp;&amp; request.status == 200)&#123; alert("post:"+ request.responseText); &#125; &#125; //如果使用的是post方式带数据,那么要添加头,说明提交的数据类型是一个经过url编码的form表单数据 request.setRequestHeader("Content-type","application/x-www-form-urlencoded"); //要将数据发送到服务器 在send方法里写表单数据 request.send("name=bb&amp;age=19");&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JavaWeb</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[servlet学习笔记]]></title>
    <url>%2F2019%2F04%2F16%2Fservlet%2F</url>
    <content type="text"><![CDATA[sevlet详细连接菜鸟教程 servlet相关概念 Servlet 为创建基于 web 的应用程序提供了基于组件、独立于平台的方法，可以不受 CGI 程序的性能限制。Servlet 有权限访问所有的 Java API，包括访问企业级数据库的 JDBC API. Java Servlet 是运行在 Web 服务器或应用服务器上的程序，它是作为来自 Web 浏览器或其他 HTTP 客户端的请求和 HTTP 服务器上的数据库或应用程序之间的中间层。 使用 Servlet，您可以收集来自网页表单的用户输入，呈现来自数据库或者其他源的记录，还可以动态创建网页。 架构图: Servlet任务 读取客户端（浏览器）发送的显式的数据。这包括网页上的 HTML 表单，或者也可以是来自 applet 或自定义的 HTTP 客户端程序的表单。 读取客户端（浏览器）发送的隐式的 HTTP 请求数据。这包括 cookies、媒体类型和浏览器能理解的压缩格式等等。 处理数据并生成结果。这个过程可能需要访问数据库，执行 RMI 或 CORBA 调用，调用 Web 服务，或者直接计算得出对应的响应。 发送显式的数据（即文档）到客户端（浏览器）。该文档的格式可以是多种多样的，包括文本文件（HTML 或 XML）、二进制文件（GIF 图像）、Excel 等。 发送隐式的 HTTP 响应到客户端（浏览器）。这包括告诉浏览器或其他客户端被返回的文档类型（例如 HTML），设置 cookies 和缓存参数，以及其他类似的任务。 servlet执行原理 当服务器接收到客户端浏览器的请求后,会解析请求url路径,获取访问的servlet的资源路径 查找web.xml文件,是否有对应的标签体内容 如果有,则找到对应的全类名 tomcat会将字节码文件加载进内存,并且创建其对象 调用方法 Servlet 生命周期Servlet生命周期可被定义为从创建到毁灭的整个过程.以下是Servlet遵循的过程: Servlet 通过调用 init () 方法进行初始化。 servlet的init方法只执行一次,说明一个servlet在内存中只存在一个对象,servlet是单例的 多个用户同时访问时可能会出现线程安全的问题 解决:尽量不要在servelt中定义成员变量,即使定义了成员变量也不要对其修改值 Servlet 调用 service() 方法来处理客户端的请求。 Servlet 通过调用 destroy() 方法终止（结束）。 最后，Servlet 是由 JVM 的垃圾回收器进行垃圾回收的 Servlet 表单数据:很多情况下，需要传递一些信息，从浏览器到 Web 服务器，最终到后台程序。浏览器使用两种方法可将这些信息传递到 Web 服务器，分别为 GET 方法和 POST 方法。 http协议:基本概念: http: Hyper Text Transfer Protocol 超文本传输协议 传输协议:定义了,客户端和服务端通信时,发送数据的格式 特点: 基于TCP/IP的高级协议 默认端口号:80 基于请求/响应模型的:一次请求对应一次响应 无状态的:每次请求之间相互独立,不能交互数据 历史版本: 1.0: 每一次请求都会建立新的连接 1.1:复用连接 请求消息数据格式: 请求行 请求方式 请求url 请求协议/版本 GET /login.html HTTP/1.1 请求方式: http协议有七种请求方式,常用的有两种 GET: 请求参数在请求行中,在url后 请求的url长度是有限制的 不太安全的 POST: 请求参数在请求体中 请求的url的长度是没有长度的 相对安全的 请求头 作用:客户端浏览器告诉服务器一些信息 请求头名称: 请求头值 常见的请求头: User-Agent: 浏览器告诉服务器,我访问你使用的浏览器版本信息 可以在服务器端获取该头的信息,解决浏览器的兼容性问题 referer:http://localhost/login.html 告诉服务器我(当前请求)从哪儿来? 作用: 防盗链: 统计工作: 请求空行 空行,分割请求头和请求体 请求体(正文) 封装post请求消息的请求参数的 响应消息数据格式: 响应行 组成:协议/版本 响应状态码 状态码描述 HTTP/1.1 200 OK 响应状态码: 服务器告诉客户端浏览器请求和响应的一个状态 状态码都是三位数字 分类: 一百多:服务器接收客户端消息,但没有接收完成,等待一段时间后,发送一百多的状态码 二百多:成功 三百多:302:重定向 304: 访问缓存 四百多:客户端错误 404:请求路径没有对应的资源 405:请求方式没有对应的doxxx方法 五百多:服务器端错误 响应头 组成:响应头名称: 响应头值 常见的响应头: Content-Type:服务器告诉客户端本次响应体数据格式以及编码格式 Content-disposition:服务器告诉客户端以什么样的格式打开响应体数据 值: in-line:默认值,在当前页面内打开 attachment;filename=xxx:以附件形式打开响应体,文件下载 响应空行 响应体:传输的数据 GET方法:GET 方法向页面请求发送已编码的用户信息。页面和已编码的信息中间用 ? 字符分隔，如下所示： http://www.test.com/hello?key1=value1&amp;key2=value2 GET 方法是默认的从浏览器向 Web 服务器传递信息的方法，它会产生一个很长的字符串，出现在浏览器的地址栏中。如果您要向服务器传递的是密码或其他的敏感信息，请不要使用 GET 方法。GET 方法有大小限制：请求字符串中最多只能有 1024 个字符。 这些信息使用 QUERY_STRING 头传递，并可以通过 QUERY_STRING 环境变量访问，Servlet 使用 doGet() 方法处理这种类型的请求。 post方法:另一个向后台程序传递信息的比较可靠的方法是 POST 方法。POST 方法打包信息的方式与 GET 方法基本相同，但是 POST 方法不是把信息作为 URL 中 ? 字符后的文本字符串进行发送，而是把这些信息作为一个单独的消息。消息以标准输出的形式传到后台程序，您可以解析和使用这些标准输出。Servlet 使用 doPost() 方法处理这种类型的请求。 request: request对象和response对象的原理: request和response对象是由服务器创建的,我们来使用它们 request对象是获取请求消息,response对象是用来设置响应消息 request对象继承体系结构: ServletRequest –接口 ​ | 继承 HttpServletRequest –接口 ​ |实现 org.apache.catalina.connector.RequestFacade类(tomcat) request功能: 获取请求消息数据 获取请求行数据 GET /day14/demo1?name=zhangsan HTTP/1.1 方法: 获取请求方式:GET String getMethod() 获取虚拟目录: /day14 String getContextPath() 获取Servlet路径: /demo1 String getServletPath() 获取get方式的请求参数:name=zhangsan String getQueryString() 获取请求URL：/day14/demo1 String getRequestURI :/servlet01/RequestDemo1 StringBuffer getRequestURL() :http://localhost:8080/servlet01/RequestDemo1 URL:统一资源定位符 :http://localhost:8080/servlet01/RequestDemo1 URI:统一资源标识符 :/servlet01/RequestDemo1 获取协议及版本：HTTP/1.1 String getProtocol() 获取客户机的IP地址: String getRemoteAddr() 获取请求头数据 方法: 通过请求头的名称获取请求头的值 String getHeader(String name) 获取所有的请求头名称 Enumeration get HeaderNames() 获取请求体数据 请求体:只有post请求方式,才有请求体,在请求体中封装了POST请求的请求参数 步骤: 获取流对象 BufferedReader getReader():获取字符输入流,只能操作字符数据 ServletInputStream getInputStream():获取字节输入流,可以操作所有数据类型 再从流对象中获取数据 其他功能 获取请求参数通用方式(get和post通用) String getParameter(String name):根据参数名称获取参数值 username=zs&amp;password=123 String[] getParameterValues(String name):根据参数名称获取参数值的数组 hobby=xx&amp;hobby=game Enumeration getParameterNames():获取所有请求的参数名称 Map&lt;String,String[]&gt; getParameterMap():获取所有参数的map集合 中文乱码问题: get方式:tomcat8已经将get方式乱码问题解决了 post方式:会乱码 解决:在获取参数前,设置request的编码为utf-8 1request.setCharacterEncoding("utf-8"); 请求转发:一种在服务器内部的资源跳转方式 步骤 通过request对象获取请求转发器对象:RequestDispatcher getRequestDispatcher(String path) 使用RequestDispatcher对象来进行转发:forward(ServletRequest request,ServletResponse response) 特点: 浏览器地址栏路径不发生变化 只能转发到当前服务器内部资源中 转发是一次请求 共享数据: 域对象:一个有作用范围的对象,可以在范围内共享数据 request域:代表一次请求的范围,一般用于请求转发的对个资源中共享数据 方法: void setAttribute(String name,Object obj):存储数据 Object getAttribute(String name):通过键来获取值 void removeAttribute(String name):通过键来移除键值对 获取ServletContext: ServletContext getServletContext() response: response对象继承体系结构: ServletResponse –接口 ​ | 继承 HttpServletResponse –接口 ​ |实现 org.apache.catalina.connector.ResponseFacade@3b2b20f1(tomcat) 功能:设置相应消息 设置响应行 HTTP/1.1 200 OK 设置状态码:setStatus(int sc) 设置响应头 setHeader(String name,String value) 设置响应体 使用步骤: 获取输出流 字符输出流:PrintWriter getWriter() 字节输出流:ServletOutputStream getOutPutStream() 使用输出流,将数据输出到客户端浏览器 案例: 完成重定向(资源跳转的方式): 代码实现 1234//1.设置状态码:302 response.setStatus(302); //2.设置响应头location response.setHeader("location","/servlet01/ResponseDemo2"); response.sendRedirect(&quot;/servlet01/ResponseDemo2&quot;); 重定向的特点 地址栏发生变化 重定向可以访问其他站点(服务器)的资源 重定向是两次请求,不可以使用request对象来共享数据 路径的写法 相对路径:通过相对路径不可以确定唯一资源 规则:找到当前资源和目标资源之间的相对位置关系 以./或../开头或者直接写名称 绝对路径:通过绝对路径可以确定唯一资源,以/开头 规则:判断定义的路径是给谁用的,判断请求将从哪儿发出 给客户端浏览器使用:需要加虚拟目录(项目的访问路径) 建议虚拟目录动态获取:request.getContextPath() \,\,重定向 给服务器使用:不需要加虚拟目录 转发路径 服务器输出字符数据到浏览器 步骤: 获取字符输出流 输出数据 注意: 乱码问题: PrintWriter pw = response.getWriter();获取的流的默认编码是ISO-8859-1 设置该流的默认编码 告诉浏览器应该使用什么编码来解析 解决方法: 简单形式,设置编码,在获取流之前 response.setContentType(&quot;text/html;charset=utf-8&quot;); 服务器输出字节数据到浏览器 步骤: 获取字节输出流 输出数据 验证码 本质:图片 目的:防止恶意表单注册 ServletContext对象 概念:代表整个web应用,可以和程序的容器(服务器)来通信 获取: 通过request对象获取 request.getServletContext(); 通过HtpServlet获取 this.getServletContext(); 功能 获取MIME类型: 在互联网通信过程中定义的一种文件数据类型 格式:大类型/小类型 text/html image/jpeg 获取:String getMimeType(String file) 域对象:共享数据 setAttribute(String name,Object value) getAttribute(String name) removeAttribute(String name) ServletContext对象范围:所有用户所有请求的数据 获取文件的真实路径(服务器路径) 方法:String getRealPath(String path)]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JavaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql事务]]></title>
    <url>%2F2019%2F04%2F15%2Fmysql%E4%BA%8B%E5%8A%A1%2F</url>
    <content type="text"><![CDATA[事务练习代码 概念代码里面的事务主要是针对连接来的，是用来防止当出现异常时对数据库的增删改操作只完成了一般，另一半未做，造成数据的错误。关闭自动提交后，当出现异常时，已完成的一般也会被恢复。 设置方法 通过conn.setAutocommit (false)；来关闭自动提交的设置。 提交事务 conn.commit()。 回滚事务 conn.rollback(); 在catch中写明当出现问题时回滚。 事务的特性事务的特性：（ACID） 原子性： 指的是事务中包含的逻辑不可分割。 一致性： 指的是事务执行前后，数据的完整性保持一致。 隔离性： 指的是事务在执行期间不应该受到其他事务的影响。 持久性： 指的是事务执行成功，那么数据应该持久保持在磁盘上。 事务的安全隐患不考虑隔离级别设置，那么会出现以下问题 读： 脏读，不可重复读，幻读 脏读：一个事务读到了另一个事物还未提交的数据。 隔离级别为：读未提交不可重复读：一个事务可以读到另一个事务提交的数据（产生两次读出不一样的问题）。 隔离级别：读已提交隔离级别：可重复读，即使一个事务已提交数据的更改，但在另一个事务里数据仍不会变化，这是为了让事务与事务之间不产生相对影响。 幻读：一个事务读到了另一个事务已提交的插入的数据，导致多次查询结果不一样。 隔离级别：可串行化：最高达隔离级别.当一个事务要操作一个表时，必须得等之前的事务提交了数据或者回滚了才能执行，否则会等待。 丢失更新： 如果a和b事务都对同一个表进行了操作，那么第二次对数据的更新可能会导致第一次更新丢失。 解决方法: 悲观锁：可以在查询的时候给查询语句后面加上 for update （数据库的锁机制： 排他锁） 乐观锁：需要程序员自己控制，自己写代码比对，先前的事务有没有对数据进行更新，如果更新了，要重新查询。]]></content>
      <categories>
        <category>SQL</category>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>事务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Use Markdown]]></title>
    <url>%2F2019%2F04%2F13%2Fhardly%2F</url>
    <content type="text"><![CDATA[Welcome to my first blog .I am very happy. 从这里开始markdown简介 Markdown是一种纯文本格式的标记语言。通过简单的标记语法，它可以使普通文本内容具有一定的格式。优点 因为是纯文本，所以只要支持Markdown的地方都能获得一样的编辑效果，可以让作者摆脱排版的困扰，专心写作。 操作简单。比如:WYSIWYG编辑时标记个标题，先选中内容，再点击导航栏的标题按钮，选择几级标题。要三个步骤。而Markdown只需要在标题内容前加#即可缺点 需要记一些语法（当然，是很简单。五分钟学会）。 有些平台不支持Markdown编辑模式。 语法一.标题在想要设置为标题的文字前面加#来表示 一个#是一级标题,有几个#就是几级标题 示例: 这是一级标题 这是二级标题 这是三级标题 这是四级标题 这是五级标题 这是六级标题二.字体 加粗 要加粗的文字左右分别用两个*包裹起来 斜体要倾斜的文字左右分别用一个*包裹起来 斜体加粗 要倾斜和加粗的文字和左右分别用三个*号包裹起来 删除线 要加删除线的文字左右分别用两个~~包裹起来 示例:这是加粗的文字这是倾斜的文字`这是斜体加粗的文字这是加删除线的文字 三.引用 在引用的文字前加&gt;即可。引用也可以嵌套，如加两个&gt;&gt;三个&gt;&gt;&gt;n个…貌似可以一直加下去，但没神马卵用 示例: 这是引用的内容 这是引用的内容 这是引用的内容 四.分割线 三个或者三个以上的 - 或者 * 都可以。 示例: 五.图片 图片alt就是显示在图片下面的文字,相当于对图片内容的解释. 图片title就是图片的标题,当鼠标移动到图片上时显示的内容,title可加可不加 示例: 六.超链接 超链接名 title可加可不加 示例:简书百度 注：Markdown本身语法不支持链接在新页面中打开，如果想要在新页面中打开的话可以用html语言的a标签代替。 github官网 七.列表 无序列表:无序列表用 - + * 任何一种都可以 有序列表:数字加点示例: 列表内容 列表内容 列表内容 注意：- + * 跟内容之间都要有一个空格 列表内容 列表内容 列表内容 注意：序号跟内容之间要有空格 列表嵌套 上一级和下一级之间敲三个空格即可 一级无序列表内容 二级无序列表内容 二级无序列表内容 二级无序列表内容 一级有序列表内容 级有序列表内容 级有序列表内容 级有序列表内容 八.表格语法加示例: 表头 表头 表头 内容 内容 内容 内容 内容 内容 第二行分割表头和内容。 有一个就行，为了对齐，多加了几个文字默认居左-两边加：表示文字居中-右边加：表示文字居右注：原生的语法两边都要用 | 包起来。此处省略 九.代码 单行代码：代码之间分别用一个反引号包起来 &apos;代码内容&apos; 代码块:代码之间分别用三个反引号包起来，且两边的反引号单独占一行 1234function fun()&#123; echo &quot;这是一句非常牛逼的代码&quot;;&#125;fun(); 十.流程图1234567st=&gt;start: 开始op=&gt;operation: My Operationcond=&gt;condition: Yes or No?e=&gt;endst-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op]]></content>
      <categories>
        <category>标记语言</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
</search>
