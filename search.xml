<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[各种排序算法]]></title>
    <url>%2F2019%2F10%2F03%2F%E5%90%84%E7%A7%8D%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[各种排序算法解析和源码选择排序将一个序列中最小的元素同未排序序列的第一个进行交换 123456789101112131415161718192021222324252627282930package selectSort;import java.util.Arrays;public class SelectSort &#123; public static void main(String[] args) &#123; int arr[] = new int[] &#123;2,1,3,6,4,8,5,9,7&#125;; selectSort(arr); System.out.println(Arrays.toString(arr)); &#125; public static void selectSort(int[] arr)&#123; //遍历所有的数 for (int i = 0; i &lt; arr.length; i++) &#123; int minIndex = i; //把当前遍历的数和后面所有的数依次进行比较,记录下最下的那个数的下标 for (int j = i + 1; j &lt; arr.length; j++) &#123; if (arr[j] &lt; arr[minIndex]) &#123; minIndex = j; &#125; &#125; //如果最小的和当前遍历的数的下标不一样(当前遍历的数字不是后面的数字中最小的) if(i!= minIndex)&#123; int temp = arr[i]; arr[i] = arr[minIndex]; arr[minIndex] = temp; &#125; &#125; &#125;&#125; 插入排序如果当前遍历的元素比已完成排序的序列的最后一个大，则遍历下一个，如果当前遍历的元素比已完成排序的序列的最后一个元素小，则遍历已经排序完的序列，将这个这个元素，插入到对应的位置 12345678910111213141516171819202122232425262728package insertSort;import java.util.Arrays;public class InsertSort &#123; public static void main(String[] args) &#123; int[] arr = new int[] &#123;9,3,4,1,5,8,2,7,6&#125;; insertSort(arr); System.out.println(Arrays.toString(arr)); &#125; private static void insertSort(int[] arr) &#123; //遍历所有数字 for (int i = 1; i &lt; arr.length; i++) &#123; if (arr[i]&lt;arr[i-1])&#123; int temp = arr[i]; int j; //遍历前i-1个已经有序的数字 for (j = i-1; j &gt;=0&amp;&amp;temp&lt;arr[j]; j--) &#123; //如果遍历到当前数字比temp的数字大,则将这些数字都往后移动一位 arr[j + 1] = arr[j]; &#125; //把外层for循环的当前元素放到前一个数字小于它的位置上 arr[j+1] = temp; &#125; &#125; &#125;&#125; 希尔排序根据步长将待排序的序列分为多个组，对每一个组进行排序，排完后将步长减小，继续进行分组排序，当步长变为一时，就是对整个序列进行排序，这样做最后一次查询的时候，序列中的数据已经基本有序了，此时再进行插入排序，就变得快多了 123456789101112131415161718192021222324252627282930package shellSort;import java.util.Arrays;public class ShellSort &#123; public static void main(String[] args) &#123; int[] arr = new int[] &#123;8,4,2,5,1,6,9,3,7&#125;; shellSort(arr); System.out.println(Arrays.toString(arr)); &#125; private static void shellSort(int[] arr) &#123; //遍历所有的步长,步长的规则为:初始值为长度/2,后每次除2 for (int d = arr.length / 2; d &gt; 0; d /= 2) &#123; //遍历所有的元素: for (int i = d; i &lt; arr.length; i++) &#123; //遍历当前组的所有元素 for (int j = i - d; j &gt;= 0; j -= d) &#123; //如果当前元素大于加上步长的那个元素 if (arr[j] &gt; arr[j + d]) &#123; int temp = arr[j]; arr[j] = arr[j+d]; arr[j+d] = temp; &#125; &#125; &#125; //System.out.println(d); &#125; &#125;&#125; 冒泡排序将数据两两比较，将大的往序列的后面进行交换（如果当前遍历的元素比后一个元素小则位置不变，继续向后遍历，如果当前遍历的元素比后一个元素大，则将当前元素同后一个元素进行交换） 1234567891011121314151617181920212223package bubbleSort;import java.util.Arrays;public class BubbleSort &#123; public static void main(String[] args) &#123; int[] arr = new int[] &#123;5,3,6,1,7,2,8,9,4&#125;; bubbleSort(arr); System.out.println(Arrays.toString(arr)); &#125; private static void bubbleSort(int[] arr) &#123; for (int i = 0; i &lt; arr.length - 1; i++) &#123; for (int j = 0; j &lt; arr.length - i - 1; j++) &#123; if (arr[j]&gt;arr[j+1])&#123; int temp = arr[j]; arr[j] = arr[j + 1]; arr[j+1] = temp; &#125; &#125; &#125; &#125;&#125; 快速排序选择一个基准数，每次将比基准数大的元素放到基准数的后面，将比基准数小的元素放到基准数的前面，这样整个序列就被分为了两半，然后再分别对这两半进行同样的操作，递归下去，直到这两半中都只有一个元素 12345678910111213141516171819202122232425262728293031323334353637383940414243package quickSort;import java.util.Arrays;public class QuickSort &#123; public static void main(String[] args) &#123; int[] arr = new int[]&#123;5, 3, 6, 8, 1, 9, 2, 4, 7&#125;; quickSort(arr,0,arr.length-1); System.out.println(Arrays.toString(arr)); &#125; private static void quickSort(int[] arr, int start, int end) &#123; //满足排序的条件有数字可以排序 if (start &lt; end) &#123; //把数组中的第一个元素作为基准数 int flag = arr[start]; int low = start; int high = end; //当高低指针不重合的情况下一直比较 while (low &lt; high) &#123; //高指针指向的位置的数比基准数大,高指针向低移动一位 while (low &lt; high &amp;&amp; flag &lt;= arr[high]) &#123; high--; &#125; //高指针位置元素比基准数小,使用高指针元素覆盖低指针元素 arr[low] = arr[high]; //如果低指针位置的元素比基准数小,低指针向高移动一位 while (low &lt; high &amp;&amp; arr[low] &lt;= flag) &#123; low++; &#125; //低指针位置的元素比基准数大,使用低指针的元素覆盖高指针元素 arr[high] = arr[low]; &#125; //高低指针重合后,将基准数赋给任意指针所指向的位置 arr[low] = flag; //一次排序完成,递归排序 //处理前半部分 quickSort(arr,start,low); //处理后半部分 quickSort(arr,low+1,end); &#125; &#125;&#125; 归并排序将待排序的队列进行递归分解，分解为两部分，直到每个部分中都只有一个元素时，再将这两个部分进行归并，知道最后，将两半归并为一个序列 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162package mergeSort;import java.util.Arrays;public class MergeSort &#123; public static void main(String[] args) &#123; int[] arr = new int[]&#123;7,3,9,5,2,1,4,6,8&#125;; mergeSort(arr,0,arr.length-1); System.out.println(Arrays.toString(arr)); &#125; public static void mergeSort(int[] arr, int low, int high) &#123; int middle = (high+low)/2; if (low&lt;high) &#123; //处理左边 mergeSort(arr, low, middle); //处理右边 mergeSort(arr, middle + 1, high); //归并 merge(arr, low, middle, high); &#125; &#125; public static void merge(int[] arr, int low, int middle, int high) &#123; //用于存储归并后的临时数组 int[] temp = new int[high-low+1]; //记录第一个数组中需要开始遍历的下标 int i = low; //记录第二个数组中需要开始遍历的下标 int j = middle+1; //记录下一个要放入临时数组中的元素应该放到哪个下标 int index = 0; //遍历两个数组取出最小的数字,放入临时数组中 //条件为两个数组中的元素都没被遍历完 while (i &lt;= middle&amp;&amp;j&lt;=high) &#123; if (arr[i] &lt;= arr[j]) &#123; temp[index] = arr[i]; i++; index++; &#125;else&#123; temp[index] = arr[j]; j++; index++; &#125; &#125; //其中有一个数组中的元素已经遍历完成,处理另一个数组中多于的数据 while (i &lt;= middle) &#123; temp[index] = arr[i]; i++; index++; &#125; while (j &lt;= high) &#123; temp[index] = arr[j]; j++; index++; &#125; //把临时数组中的数据重新存入原数组 for (int k = 0; k &lt; temp.length; k++) &#123; arr[k + low] = temp[k]; &#125; &#125;&#125; 基数排序将数字按照各个位的大小进行排序,并按先进先出的规则,这样排序的结果为:最高位按照顺序排序,最高位相同,按照次高位的顺序排序,一直到按照最低位排序 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package radixSort;import java.util.Arrays;public class RadixSort &#123; public static void main(String[] args) &#123; int[] arr = new int[]&#123;921, 334, 63, 22, 15,89,77, 475, 875, 54, 76&#125;; radixSort(arr); System.out.println(Arrays.toString(arr)); &#125; private static void radixSort(int[] arr) &#123; //先找到最大的元素,决定排序多少轮 int max = Integer.MIN_VALUE; for (int i = 0; i &lt;arr.length ; i++) &#123; if (arr[i] &gt; max) &#123; max = arr[i]; &#125; &#125; //求最大数字的位数 int maxLength = (max+"").length(); //用于临时存储数据的数组 int[][] temp = new int[10][arr.length]; //定义变量存储数组中已经存储的元素的个数(用于确定将下一个数字放到数组中的什么位置) int[] counts = new int[10]; //根据最大长度决定比较的次数,每一轮根据n的值取出不同位的数 for (int i = 0, n = 1; i &lt; maxLength; i++, n *= 10) &#123; //对每一个数分别计算余数 for (int j = 0; j &lt; arr.length; j++) &#123; int ys = arr[j]/n%10; temp[ys][counts[ys]]=arr[j]; //让数组中的元素个数加1 counts[ys]++; &#125; //对每一位排完序后,把数字取出来 for (int k = 0, s = 0; k &lt; counts.length; k++) &#123; //如果对应位里面有数字,将其取出 if (counts[k] != 0) &#123; for (int l = 0; l &lt; counts[k]; l++) &#123; arr[s] = temp[ k][l]; s++; &#125; //把计数数组清空 counts[k] = 0; &#125; &#125; &#125; &#125;&#125; 堆排序将序列构建为一个大顶堆或者小顶堆,然后将堆顶元素放到已排序序列的第一个,然后再将前面的元素进行重新构建,直到所有的元素都有序 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package heapSort;import java.util.Arrays;public class HeapSort &#123; public static void main(String[] args) &#123; int[] arr = new int[] &#123;5,2,6,8,1,9,4,3,7&#125;; heapSort(arr); System.out.println(Arrays.toString(arr)); &#125; public static void maxHeap(int[] arr,int size,int index) &#123; //左子节点 int leftNode = 2*index+1; //右子节点 int rightNode = 2*index+2; int max = index; //和两个子节点进行对比,找出最大的节点 if (leftNode&lt;size &amp;&amp; arr[leftNode] &gt; arr[max]) &#123; max = leftNode; &#125; if (rightNode&lt;size &amp;&amp; arr[rightNode] &gt; arr[max]) &#123; max = rightNode; &#125; //交换位置 if (max != index) &#123; int temp = arr[index]; arr[index] = arr[max]; arr[max] = temp; //调整完该节点后,可能会对已经调整好的堆造成影响,所以需要重新调整 maxHeap(arr, size, max); &#125; &#125; private static void heapSort(int[] arr) &#123; //从最后一个非叶子节点开始进行调整,调整到根节点 int start = (arr.length - 1) * 2; for (int i = start; i &gt;= 0; i--) &#123; maxHeap(arr,arr.length,i); &#125; //先把数组中的第0个和堆中的最后一个数进行位置交换,再把前面的处理为大顶堆 for (int i = arr.length - 1; i &gt; 0; i--) &#123; int temp =arr[0]; arr[0] = arr[i]; arr[i] = temp; maxHeap(arr,i,0); &#125; &#125;&#125; 与数组初始状态无关的排序算法首先，与初始状态无关分为几种情况 算法复杂度与初始状态无关； 元素总比较次数与初始状态无关； 元素总移动次数与初始状态无关。 以下四种排序方法的算法复杂度与数组的初试状态无关： 一堆（堆排序）乌龟（归并排序）选（选择排序）基（基数排序）友 稍加判断得到，以上三种情况2、3是必定包含在情况1中间的。 堆排序 思想：首先对初始数组建立最小堆，然后取堆顶元素与堆尾交换，再此堆元素（不含堆尾）再重新构建最小堆，依次循环。 分析：由于建立最小堆其实就是将初始元素按照规定的准则进行一系列排序（包括层级向下比较、交换），所以如果元素一开始就已经是最小堆则不需要此时的交换且大大减少向下比较次数， 所以堆排序不属于情况二也不属于情况三。 归并排序 思想：将初试数组划分成N个子数组，两两进行合并排序，然后结果再和其他同级合并后的数组合并知道合并完所有。 分析：外层递归与初始无关，主要思考合并排序中的比较和交换即可。合并排序思想：将数组A第一个与数组B第一个比较，较小的那一个直接进入result数组并且指针向下移动再与对面数组第一个比较，依次类推，然后将还有剩余的数组内元素全放入result，最后用result将原数组中对应的值一一替换。因此，假设初始数组就是有序的，那么每次合并排序的时的比较次数都仅仅是一个待合并的数组的长度，因此比较次数与初始状态有关，归并排序不属于情况二。 然而，不论一开始的状态如何，最后都是两个数组进入result，移动次数都为两个待合并数组的长度和，然后再将result内元素全部移动到原来数组进行替换。所以元素移动次数与初始状态无关，归并排序属于情况三。 选择排序 思想：i 从头开始，每次遍历之后所有的元素，k 从 i 开始，向后标记最小的元素，循环后如果大于 i ，则与 i 位置元素交换，一直到最后。 分析：比较次数都是N-1的阶乘，与初始状态无关，所以选择排序属于情况二。 交换次数当全部已经排序好时则不发生交换，所以选择排序不属于情况三。 基数排序 思想：将数组从低位到高位，每到一位对应分入10个桶（0-9）中，依次到最高位，由于每上升一位，处于“0号桶”中的数据都会将此位之前的数字排好，以此达到排序效果。 分析：基数排序中并不发生任何元素之间的比较，所以基数排序属于情况二。 不论初始数组如何排列，都是从个位开始，各自进入自己个位对应的位置，之后也都是一样，所以元素移动次数一样，所以基数排序属于情况三。 综上所述： 1、算法复杂度与初始状态无关的有：选择排序、堆排序、归并排序、基数排序。 2、元素总比较次数与初始状态无关的有：选择排序、基数排序。 3、元素总移动次数与初始状态无关的有：归并排序、基数排序。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中各种集合的扩充机制]]></title>
    <url>%2F2019%2F10%2F02%2FJava%E4%B8%AD%E5%90%84%E7%A7%8D%E9%9B%86%E5%90%88%E7%9A%84%E6%89%A9%E5%85%85%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[JAVA中的部分需要扩容的内容总结如下：HashMap： 初始容量定义：默认为1 &lt;&lt; 4（16）。最大容量为1&lt;&lt; 30 扩容加载因子为(0.75)，第一个临界点在当HashMap中元素的数量大于table数组长度加载因子（16*0.75=12），则按oldThr &lt;&lt; 1（原长度*2）扩容。 HashSet: 初始容量定义：16。因为构造一个HashSet，其实相当于新建一个HashMap，然后取HashMap的Key。 扩容机制和HashMap一样。 Hashtable: 初始容量定义：capacity (11)。 扩容加载因子(0.75)，当超出默认长度（int）（110.75）=8时，扩容为old\2+1。 int newCapacity = (oldCapacity &lt;&lt; 1) + 1;HashTable和HashMap区别: 继承不同。public class Hashtable extends Dictionary implements Mappublic class HashMap extends AbstractMap implements Map Hashtable 中的方法是同步的，而HashMap中的方法在缺省情况下是非同步的。在多线程并发的环境下，可以直接使用Hashtable，但是要使用HashMap的话就自己增加同步处理了。 Hashtable中，key和value都不允许出现null值。在HashMap中，null可以作为键，这样的键只有一个；可以有一个或多个键所对应的值为null。当get()方法返回null值时，即可以表示 HashMap中没有该键，也可以表示该键所对应的值为null。因此，在HashMap中不能由get()方法来判断HashMap中是否存在某个键， 而应该用containsKey()方法来判断。 两个遍历方式的内部实现上不同。Hashtable、HashMap都使用了 Iterator。而由于历史原因，Hashtable还使用了Enumeration的方式 。 哈希值的使用不同，HashTable直接使用对象的hashCode。而HashMap重新计算hash值。 Hashtable和HashMap它们两个内部实现方式的数组的初始大小和扩容的方式。HashTable中hash数组默认大小是11，增加的方式是 old*2+1。HashMap中hash数组的默认大小是16， 增加的方式是 old*2。 ArrayList: 初始容量定义：10。 扩容：oldCapacity + (oldCapacity &gt;&gt; 1)，即原集合长度的1.5倍。 int newCapacity = (oldCapacity * 3)/2 + 1; CopyOnWriteArrayList：CopyOnWriteArrayList在做修改操作时，每次都是重新创建一个新的数组，在新数组上操作，最终再将新数组替换掉原数组。因此，在做修改操作时，仍可以做读取操作，读取直接操作的原数组。读和写操作的对象都不同，因此读操作和写操作互不干扰。只有写与写之间需要进行同步等待。另外，原数组被声明为volatile，这就保证了，一旦数组发生变化，则结果对其它线程(读线程和其它写线程)是可见的。 CopyOnWriteArrayList并不像ArrayList一样指定默认的初始容量。它也没有自动扩容的机制，而是添加几个元素，长度就相应的增长多少。CopyOnWriteArrayList适用于读多写少，既然是写的情况少，则不需要频繁扩容。并且修改操作每次在生成新的数组时就指定了新的容量，也就相当于扩容了，所以不需要额外的机制来实现扩容。 ArrayList与Vector初始容量都为10。 扩容机制不同，当超出当前长度时ArrayList扩展为原来的1.5倍，而若不考虑扩容因子Vector扩展为原来的2倍。 ArrayList为非线程安全的，处理效率上较Vector快，若同时考虑线程安全和效率，可以使用 CopyOnWriteArrayList。 StringBuffer: 初始容量定义：16。 扩容：因为StringBuffer extends AbstractStringBuilder，所以实际上是用的是AbstractStringBuilder的扩容方法，当用append(str)添加字符串时，假设字符串中已有字符长度为count的字符串,初始长度value=16,若要添加的字符串长度（count+str.length()）&lt;=(value*2+2)则按value2+2长度扩容，并且value=value\2+2，若（count+str.length()）&gt;(value*2+2)，则按count+str.length()长度扩容，并且value=count+str.length()。下次超出时再按以上方法与value*2+2比较扩容。 12345private int newCapacity(int minCapacity) &#123;// overflow-conscious codeint newCapacity = (value.length &lt;&lt; 1) + 2;if (newCapacity - minCapacity &lt; 0) &#123;newCapacity = minCapacity; StringBuilder:1234567891011public final class StringBuilderextends AbstractStringBuilderimplements java.io.Serializable, CharSequencepublic StringBuilder() &#123;super(16);&#125;private int newCapacity(int minCapacity) &#123;// overflow-conscious codeint newCapacity = (value.length &lt;&lt; 1) + 2;if (newCapacity - minCapacity &lt; 0) &#123;newCapacity = minCapacity; StringBuilder是jdk1.5引进的，而StringBuffer在1.0就有了 StringBuilder和StringBuffer都是可变的字符串。能够通过append或者insert等方法改动串的内容； StringBuffer是线程安全的而StringBuilder不是，因而在多线程的环境下优先使用StringBuffer，而其它情况下推荐使用StringBuilder，由于它更快。 StrngBuilder和StringBuffer都继承自AbstractStringBuilder类，AbStractStringBuilder主要实现了扩容、append、insert方法。StrngBuilder和StringBuffer的相关方法都直接调用的父类。 StringBuilder和StringBuffer的初始容量都是16,程序猿尽量手动设置初始值。以避免多次扩容所带来的性能问题； StringBuilder和StringBuffer的扩容机制是这种：首先试着将当前数组容量扩充为原数组容量的2倍加上2，假设这个新容量仍然小于预定的最小值（minimumCapacity），那么就将新容量定为（minimumCapacity），最后推断是否溢出，若溢出，则将容量定为整型的最大值0x7fffffff。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>集合扩充</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络相关内容]]></title>
    <url>%2F2019%2F09%2F29%2F%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3%E5%86%85%E5%AE%B9%2F</url>
    <content type="text"><![CDATA[TCP的三次握手与四次挥手理解及面试题 序列号seq：占4个字节，用来标记数据段的顺序，TCP把连接中发送的所有数据字节都编上一个序号，第一个字节的编号由本地随机产生；给字节编上序号后，就给每一个报文段指派一个序号；序列号seq就是这个报文段中的第一个字节的数据编号。 确认号ack：占4个字节，期待收到对方下一个报文段的第一个数据字节的序号；序列号表示报文段携带数据的第一个字节的编号；而确认号指的是期望接收到下一个字节的编号；因此当前报文段最后一个字节的编号+1即为确认号。 确认ACK：占1位，仅当ACK=1时，确认号字段才有效。ACK=0时，确认号无效 同步SYN：连接建立时用于同步序号。当SYN=1，ACK=0时表示：这是一个连接请求报文段。若同意连接，则在响应报文段中使得SYN=1，ACK=1。因此，SYN=1表示这是一个连接请求，或连接接受报文。SYN这个标志位只有在TCP建产连接时才会被置1，握手完成后SYN标志位被置0。 终止FIN：用来释放一个连接。FIN=1表示：此报文段的发送方的数据已经发送完毕，并要求释放运输连接 PS：ACK、SYN和FIN这些大写的单词表示标志位，其值要么是1，要么是0；ack、seq小写的单词表示序号。 三次握手过程理解 第一次握手：建立连接时，客户端发送syn包（syn=j）到服务器，并进入SYN_SENT状态，等待服务器确认；SYN：同步序列编号（Synchronize Sequence Numbers）。 第二次握手：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态； 第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1），此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。 四次挥手过程理解 客户端进程发出连接释放报文，并且停止发送数据。释放数据报文首部，FIN=1，其序列号为seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，客户端进入FIN-WAIT-1（终止等待1）状态。 TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。 服务器收到连接释放报文，发出确认报文，ACK=1，ack=u+1，并且带上自己的序列号seq=v，此时，服务端就进入了CLOSE-WAIT（关闭等待）状态。TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。 客户端收到服务器的确认请求后，此时，客户端就进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）。 服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN=1，ack=u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq=w，此时，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。 客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，ack=w+1，而自己的序列号是seq=u+1，此时，客户端就进入了TIME-WAIT（时间等待）状态。注意此时TCP连接还没有释放，必须经过2∗∗MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态。 服务器只要收到了客户端发出的确认，立即进入CLOSED状态。同样，撤销TCB后，就结束了这次的TCP连接。可以看到，服务器结束TCP连接的时间要比客户端早一些。 常见的面试题【问题1】为什么连接的时候是三次握手，关闭的时候却是四次握手？ 答：因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，”你发的FIN报文我收到了”。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。 【问题2】为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态？ 答：虽然按道理，四个报文都发送完毕，我们可以直接进入CLOSE状态了，但是我们必须假象网络是不可靠的，有可以最后一个ACK丢失。所以TIME_WAIT状态就是用来重发可能丢失的ACK报文。在Client发送出最后的ACK回复，但该ACK可能丢失。Server如果没有收到ACK，将不断重复发送FIN片段。所以Client不能立即关闭，它必须确认Server接收到了该ACK。Client会在发送出ACK之后进入到TIME_WAIT状态。Client会设置一个计时器，等待2MSL的时间。如果在该时间内再次收到FIN，那么Client会重发ACK并再次等待2MSL。所谓的2MSL是两倍的MSL(Maximum Segment Lifetime)。MSL指一个片段在网络中最大的存活时间，2MSL就是一个发送和一个回复所需的最大时间。如果直到2MSL，Client都没有再次收到FIN，那么Client推断ACK已经被成功接收，则结束TCP连接。 【问题3】为什么不能用两次握手进行连接？ 答：3次握手完成两个重要的功能，既要双方做好发送数据的准备工作(双方都知道彼此已准备好)，也要允许双方就初始序列号进行协商，这个序列号在握手过程中被发送和确认。 现在把三次握手改成仅需要两次握手，死锁是可能发生的。作为例子，考虑计算机S和C之间的通信，假定C给S发送一个连接请求分组，S收到了这个分组，并发 送了确认应答分组。按照两次握手的协定，S认为连接已经成功地建立了，可以开始发送数据分组。可是，C在S的应答分组在传输中被丢失的情况下，将不知道S 是否已准备好，不知道S建立什么样的序列号，C甚至怀疑S是否收到自己的连接请求分组。在这种情况下，C认为连接还未建立成功，将忽略S发来的任何数据分 组，只等待连接确认应答分组。而S在发出的分组超时后，重复发送同样的分组。这样就形成了死锁。 【问题4】如果已经建立了连接，但是客户端突然出现故障了怎么办？ TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。 端对端和点对点数据传输的可靠性是通过数据链路层和网络层的点对点和传输层的端对端保证的。端到端与点到点是针对网络中传输的两端设备间的关系而言的。 端到端通信端到端通信是针对传输层来说的，它是一个网络连接，指的是在数据传输之前，在发送端与接收端之间（忽略中间有多少设备）为数据的传输建立一条链路，链路建立以后，发送端就可以发送数据，知道数据发送完毕，接收端确认接收成功。 也就是说在数据传输之前，先为数据的传输开辟一条通道，然后在进行传输。从发送端发出数据到接收端接收完毕，结束。 端到端的优点：链路建立之后，发送端知道接收端一定能收到，而且经过中间交换设备时不需要进行存储转发，因此传输延迟小。 端到端传输的缺点：（1）直到接收端收到数据为止，发送端的设备一直要参与传输。如果整个传输的延迟很长，那么对发送端的设备造成很大的浪费。 （2）如果接收设备关机或故障，那么端到端传输不可能实现。 点到点通信点到点通信是针对数据链路层或网络层来说的，点对点是基于MAC地址和或者IP地址，是指一个设备发数据给与该这边直接连接的其他设备，这台设备又在合适的时候将数据传递给与它相连的下一个设备，通过一台一台直接相连的设备把数据传递到接收端。 点到点的优点：（1）发送端设备送出数据后，它的任务已经完成，不需要参与整个传输过程，这样不会浪费发送端设备的资源。 （2）即使接收端设备关机或故障，点到点传输也可以采用存储转发技术进行缓冲。 点到点的缺点：点到点传输的缺点是发送端发出数据后，不知道接收端能否收到或何时能收到数据。 在一个网络系统的不同分层中，可能用到端到端传输，也可能用到点到点传输。如Internet网，IP及以下各层采用点到点传输，4层以上采用端到端传输。 TCP和UDP的区别CP和UDP都是传输层协议，但是两者具有不同的特性和应用场景 TCP UDP 可靠性 可靠 不可靠 连接性 面向连接 面向无连接 报文 面向字节流 面向报文 效率 低 高 双工性 全双工 一对一、一对多、多对一、多对多 流量控制 滑动窗口 无 拥塞控制 慢开始、拥塞避免、快重传、快恢复 无 传输速度 慢 快 应用场景 对效率要求低，对准确度要求高或者要求有连接的场景。比如：电子邮件(SMTP)、万维网(HTTP)、文件传输(FTP) 对效率要求高，对准确度要求低的场景。比如：域名转换(DNS)、远程文件服务器(NFS) 面向报文和面向字节流面向报文的传输方式是应用层交给UDP多长的报文，UDP就发送多长的报文，即一次发送一个报文。因此应用程序必须选择大小合适的报文。报文太长，则IP层需要分片，降低效率。 面向字节流的传输方式是应用程序和TCP的交互是一次一个数据块（大小不等），TCP把这些数据块看成是一连串无结构的字节流。TCP有一个缓冲，当应用程序传送的数据块太长，TCP就会把它分割成多块传送。 双工性全双工：是指在发送数据的同时也能够接收数据，两者同步进行，这好像我们平时打电话一样，说话的同时也能够听到对方的声音。目前的网卡一般都支持全双工。 半双工：所谓半双工就是指一个时间段内只有一个动作发生，举个简单例子，一条窄窄的马路，同时只能有一辆车通过，当目前有两量车对开，这种情况下就只能一辆先过，等到头儿后另一辆再开，这个例子就形象的说明了半双工的原理。 层级协议]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多线程相关内容]]></title>
    <url>%2F2019%2F09%2F28%2F%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3%E5%86%85%E5%AE%B9%2F</url>
    <content type="text"><![CDATA[多线程我们在之前，学习的程序在没有跳转语句的前提下，都是由上至下依次执行，那现在想要设计一个程序，边打游戏边听歌，怎么设计？ 要解决上述问题,咱们得使用多进程或者多线程来解决. 1 并发与并行 并发：指两个或多个事件在同一个时间段内发生。 并行：指两个或多个事件在同一时刻发生（同时发生）。 在操作系统中，安装了多个程序，并发指的是在一段时间内宏观上有多个程序同时运行，这在单 CPU 系统中，每一时刻只能有一道程序执行，即微观上这些程序是分时的交替运行，只不过是给人的感觉是同时运行，那是因为分时交替运行的时间是非常短的。 而在多个 CPU 系统中，则这些可以并发执行的程序便可以分配到多个处理器上（CPU），实现多任务并行执行，即利用每个处理器来处理一个可以并发执行的程序，这样多个程序便可以同时执行。目前电脑市场上说的多核 CPU，便是多核处理器，核 越多，并行处理的程序越多，能大大的提高电脑运行的效率。 注意：单核处理器的计算机肯定是不能并行的处理多个任务的，只能是多个任务在单个CPU上并发运行。同理,线程也是一样的，从宏观角度上理解线程是并行运行的，但是从微观角度上分析却是串行运行的，即一个线程一个线程的去运行，当系统只有一个CPU时，线程会以某种顺序执行多个线程，我们把这种情况称之为线程调度。 2 线程与进程 进程：是指一个内存中运行的应用程序，每个进程都有一个独立的内存空间，一个应用程序可以同时运行多个进程；进程也是程序的一次执行过程，是系统运行程序的基本单位；系统运行一个程序即是一个进程从创建、运行到消亡的过程。 线程：线程是进程中的一个执行单元，负责当前进程中程序的执行，一个进程中至少有一个线程。一个进程中是可以有多个线程的，这个应用程序也可以称之为多线程程序。 简而言之：一个程序运行后至少有一个进程，一个进程中可以包含多个线程 我们可以再电脑底部任务栏，右键—–&gt;打开任务管理器,可以查看当前任务的进程： 进程 线程 线程调度: 分时调度 所有线程轮流使用 CPU 的使用权，平均分配每个线程占用 CPU 的时间。 抢占式调度 优先让优先级高的线程使用 CPU，如果线程的优先级相同，那么会随机选择一个(线程随机性)，Java使用的为抢占式调度。 设置线程的优先级 抢占式调度详解 大部分操作系统都支持多进程并发运行，现在的操作系统几乎都支持同时运行多个程序。比如：现在我们上课一边使用编辑器，一边使用录屏软件，同时还开着画图板，dos窗口等软件。此时，这些程序是在同时运行，”感觉这些软件好像在同一时刻运行着“。 实际上，CPU(中央处理器)使用抢占式调度模式在多个线程间进行着高速的切换。对于CPU的一个核而言，某个时刻，只能执行一个线程，而 CPU的在多个线程间切换速度相对我们的感觉要快，看上去就是在同一时刻运行。其实，多线程程序并不能提高程序的运行速度，但能够提高程序运行效率，让CPU的使用率更高。 3 创建线程类Java使用java.lang.Thread类代表线程，所有的线程对象都必须是Thread类或其子类的实例。每个线程的作用是完成一定的任务，实际上就是执行一段程序流即一段顺序执行的代码。Java使用线程执行体来代表这段程序流。Java中通过继承Thread类来创建并启动多线程的步骤如下： 定义Thread类的子类，并重写该类的run()方法，该run()方法的方法体就代表了线程需要完成的任务,因此把run()方法称为线程执行体。 创建Thread子类的实例，即创建了线程对象 调用线程对象的start()方法来启动该线程 代码如下： 测试类： 123456789101112public class Demo01 &#123; public static void main(String[] args) &#123; //创建自定义线程对象 MyThread mt = new MyThread("新的线程！"); //开启新线程 mt.start(); //在主方法中执行for循环 for (int i = 0; i &lt; 10; i++) &#123; System.out.println("main线程！"+i); &#125; &#125;&#125; 自定义线程类： 12345678910111213141516public class MyThread extends Thread &#123; //定义指定线程名称的构造方法 public MyThread(String name) &#123; //调用父类的String参数的构造方法，指定线程的名称 super(name); &#125; /** * 重写run方法，完成该线程执行的逻辑 */ @Override public void run() &#123; for (int i = 0; i &lt; 10; i++) &#123; System.out.println(getName()+"：正在执行！"+i); &#125; &#125;&#125; 线程在java中，每次程序运行至少启动2个线程。一个是main线程，一个是垃圾收集线程。因为每当使用 java命令执行一个类的时候，实际上都会启动一个JVM，每一个JVM其实在就是在操作系统中启动了一个进 程。 1 多线程原理自定义线程类： 1234567891011121314151617181920public class MyThread extends Thread&#123; /* * 利用继承中的特点 * 将线程名称传递 进行设置 */ public MyThread(String name)&#123; super(name); &#125; /* * 重写run方法 * 定义线程要执行的代码 */ public void run()&#123; for (int i = 0; i &lt; 20; i++) &#123; //getName()方法 来自父亲 System.out.println(getName()+i); &#125; &#125;&#125; 测试类： 12345678910public class Demo &#123; public static void main(String[] args) &#123; System.out.println("这里是main线程"); MyThread mt = new MyThread("小强"); mt.start();//开启了一个新的线程 for (int i = 0; i &lt; 20; i++) &#123; System.out.println("旺财:"+i); &#125; &#125; &#125; 流程图： 程序启动运行main时候，java虚拟机启动一个进程，主线程main在main()调用时候被创建。随着调用mt的对象的 start方法，另外一个新的线程也启动了，这样，整个应用就在多线程下运行。 通过这张图我们可以很清晰的看到多线程的执行流程，那么为什么可以完成并发执行呢？我们再来讲一讲原理。 多线程执行时，到底在内存中是如何运行的呢？以上个程序为例，进行图解说明： 多线程执行时，在栈内存中，其实每一个执行线程都有一片自己所属的栈内存空间。进行方法的压栈和弹栈。 当执行线程的任务结束了，线程自动在栈内存中释放了。但是当所有的执行线程都结束了，那么进程就结束了。 2 Thread类获取线程的名称： 使用Thread类中的方法getName() String getName(); 返回该线程的名称 可以先获取到当前正在执行的线程，使用线程中的方法getName获取线程的名称 static Thread currentThread(); 返回当前正在执行的线程对象的引用 Thread.currentThread().getName(); 设置线程的名称： 使用Thread类中的setName方法： void setName(String name);改变线程名称，使之与参数name相同 创建一个带参数的构造方法，参数传递线程的名称，调用父类的构造方法，把线程名称传递给父类，让父类（Thread）给线程起一个名字 让当前正在执行的线程暂停（暂时停止执行）： public static void sleep(long millis):使当前正在执行的线程以指定的毫秒数暂停 3 创建多线程的方式 继承Thread类，重写run方法（其实Thread类本身也实现了Runnable接口） 每次创建一个新的线程，都要新建一个Thread子类的对象 启动线程，new Thread子类（）.start（） 创建线程实际调用的是父类Thread空参的构造器 实现Runnable接口，重写run方法 不论创建多少个线程，只需要创建一个Runnable接口实现类的对象 启动线程，new Thread（Runnable接口实现类的对象）.start() 创建线程调用的是Thread类Runable类型参数的构造器 实现Runable接口创建多线程程序的好处： 避免了单继承的局限性 一个类只能继承一个类，类继承了Thread类就不能再继承别的类了 增强了程序的扩展性，降低了程序的耦合性（解耦） 实现Runnable接口的方式，把设置线程任务和开启线程进行了分离（解耦） 设置线程任务的是Runnable接口的实现类，开启线程的是Thread类对象 线程池只能放入实现Runnable或者Callable类线程，不能直接放入继承Thread的类 实现Callable接口，重写call方法（有返回值） 自定义类实现Callable接口时，必须指定泛型，该泛型即返回值的类型 每次创建一个新的线程，都要创建一个新的Callable接口的实现类、 如何启动线程？ 1. 创建一个Callable接口的实现类的对象 2. 创建一个FutureTask对象，传入Callable类型的参数 public FutureTask(Callable&lt;V&gt; callable){……} 3. 调用Thread类重载的参数为Runnable的构造器创建Thread对象 将FutureTask作为参数传递 public class FutureTask&lt;V&gt; implements RunnableFuture&lt;V&gt; public interface RunnableFuture&lt;V&gt; extends Runnable, Future&lt;V&gt; 如何获取返回值？ 调用FutureTask类的get()方法 使用线程池（有返回值） 线程安全1 线程安全如果有多个线程在同时运行，而这些线程可能会同时运行这段代码。程序每次运行结果和单线程运行的结果是一样 的，而且其他的变量的值也和预期的是一样的，就是线程安全的。 原因： 线程安全问题都是由全局变量及静态变量引起的。若每个线程中对全局变量、静态变量只有读操作，而无写 操作，一般来说，这个全局变量是线程安全的；若有多个线程同时执行写操作，一般都需要考虑线程同步， 否则的话就可能影响线程安全。 2 线程同步当我们使用多个线程访问同一资源的时候，且多个线程中对资源有写的操作，就容易出现线程安全问题。要解决上述多线程并发访问一个资源的安全性问题:也就是解决重复票与不存在票问题，Java中提供了同步机制 (synchronized)来解决。 解决方案： 同步代码块。 synchronized 关键字可以用于方法中的某个区块中，表示只对这个区块的资源实行互斥访问。 123synchronized(同步锁)&#123; 需要同步操作的代码&#125; 同步方法。 同步方法:使用synchronized修饰的方法,就叫做同步方法,保证A线程执行该方法的时候,其他线程只能在方法外 等着。 123public synchronized void method()&#123; 可能产生线程安全问题的代码&#125; 锁机制。 java.util.concurrent.locks.Lock 接口提供了比synchronized代码块和synchronized方法更广泛的锁定操作, 同步代码块/同步方法具有的功能Lock都有,除此之外更强大,更体现面向对象。 Lock锁也称同步锁，加锁与释放锁方法化了，如下： public void lock() :加同步锁 public void unlock() :释放同步锁。 因为Lock是接口，所以我们在使用里面的方法是时候首先要创建他的一个实现类如ReentrantLock类的对象，通过这个对象来调用它里面的方法 3 volatile实现线程间可见给变量加上volatile关键字后，可以保证该变量在线程之间可见，具有可见性，但是并不保证原子性 可见性:当全局变量的值在一线程内被修改后（修改的是栈当中的方法区中的变量的副本），可以马上将这个值刷新到主内存（更新方法区中的原本），这个刷新的动作本来会自动执行，但是如果有延迟，有等待的话，就不会马上刷新，此时就必须使用volatile来马上刷新，来保证该变量在多个线程之间的值是相同的（可见性） 原子性：AtomicInteger 保证计数的原子性，在1.5之后的并发包中 public AtomicInteger count = new AtomicInteger(0); count.inctementAndGet(); count.get(); 线程状态1 线程状态概述当线程被创建并启动以后，它既不是一启动就进入了执行状态，也不是一直处于执行状态。在线程的生命周期中， 有几种状态呢？在API中 java.lang.Thread.State 这个枚举中给出了六种线程状态： 线程状态 导致状态发生的条件 NEW(新建) 线程刚被创建，但是并未启动，还没调用start方法 Runnable(可运行的) 线程可以在java虚拟机中运行的状态，可能正在运行自己的代码，也可能没有，这取决与操作系统处理器 Blocked(锁阻塞) 当一个线程在等待另一个线程执行一个（唤醒）动作时，该线程进入Blocked状态，当该线程持有锁时，该线程变成Runnable状态 Waiting(无限等待) 一个线程在等待另一个线程执行一个（唤醒)动作的时,该线程进入Waiting状态，进入这个状态后是不能自动唤醒的，必须等待另一个线程调用notify()或者notifyAll()方法才能够唤醒 Timed Waiting(计时等待) 同waiting状态，有几个方法有超时参数，调用他们将进入Timed Waiting状态，这一状态将一直保持到超时期满或者接收到唤醒通知，带有超时参数的常用方法有Thread.sleep、Object.Wait Teminated(被终止) 因为run方法正常退出而死亡，或者因为没有捕获的异常终止了run方法而死亡 等待唤醒机制1 线程间通信 为什么要线程间通信： 多个线程并发执行，那么在默认情况下cpu是随机切换线程的，但是我们如果需要这多个线程来共同完成一个事情，并且我们希望他们有规律的执行，那么多个线程间就需要通信，以此来实现多个线程操作同一份数据 如何保证线程间通信有效利用资源： 多个线程在处理同一个资源时，并且任务不同时，需要线程间通信来解决线程之间对同一个变量的使用和操作，就是多个线程在操作同一份数据时，避免对同一共享数据的争夺，这就是我们需要通过等待唤醒机制来实现多个线程能有效的利用资源 2 等待唤醒机制 什么是等待唤醒机制： 这是多个线程间的一种协作机制，谈到线程我们经常想到的是线程间的竞争，比如说去争夺锁，但这并不是故事的全部，线程之间也会有协作机制 就是在一个线程进行了规定操作后，就进入等待状态，等待其他线程执行完他们的代码后，再将其唤醒，在多个线程进行等待时，如果需要可以使用notifyAll方法来唤醒所有的等待线程 wait/notify就是线程间的一种通信机制 等待唤醒方法： 等待唤醒机制就是用于解决线程间通信的问题的，使用的三个方法含义如下： wait:线程不再活动，不再参与调度，进入wait set 中，因此也不会浪费cpu资源，也不会去竞争锁，这时线程的状态就是waiting，他还要等着别的线程执行一个特别的动作，也就是notify()通知，在这个对象上等待的线程从wait set中释放出来，重新进入到调度队列中 notify:选取所通知对象的wait set中的一个线程（随机的）释放 notifyAll:释放所通知对象的wait set上的全部线程 哪怕只通知了一个在等待的线程，被通知的线程也不能立即恢复执行，因为当初中断的位置实在同步块内，而此刻他已经失去了锁，所以他需要再次去尝试获取锁，成功后才能在当初调用wait方法之后的地方恢复执行 wait和notify方法使用细节 wait方法与notify方法必须由同一个锁对象调用：因为对应的锁对象可以通过notify唤醒使用同一个锁对象调用的wait方法后的线程 wait方法与notify方法是属于objcet类的方法：因为锁对象是任意的对象，而任意的对象都还是继承了object类的 wait方法和notify方法必须要在同步代码块或者是同步函数中使用，因为必须要通过锁对象调用这个方法（同步代码块或者函数中可以保证锁对象唯一） sleep方法是 Thread类的方法，static void sleep(long millis) 在指定的毫秒数内让当前正在执行的线程休眠（暂停执行），此操作受到系统计时器和调度程序精度和准确性的影响。他的作用等同于Object类的wait(long millis)方法，wait()方法如果在毫秒值结束之后,还没有被notify唤醒,就会自动唤醒,线程进入Runnable或者Blocked状态 3 wait和sleep方法的区别 这两个方法来自不同的类分别是Thread和Object 最主要是sleep方法没有释放锁，而wait方法释放了锁，使得其他线程可以使用同步控制块或者方法(锁代码块和方法锁)。 wait，notify和notifyAll只能在同步控制方法或者同步控制块里面使用，而sleep可以在任何地方使用(使用范围) sleep必须捕获异常，而wait，notify和notifyAll不需要捕获异常 sleep方法属于Thread类中方法，表示让一个线程进入睡眠状态，等待一定的时间之后，自动醒来进入到可运行状态，不会马上进入运行状态，因为线程调度机制恢复线程的运行也需要时间，一个线程对象调用了sleep方法之后，并不会释放他所持有的所有对象锁，所以也就不会影响其他进程对象的运行。但在sleep的过程中过程中有可能被其他对象调用它的interrupt(),产生InterruptedException异常，如果你的程序不捕获这个异常，线程就会异常终止，进入TERMINATED状态，如果你的程序捕获了这个异常，那么程序就会继续执行catch语句块(可能还有finally语句块)以及以后的代码。 注意sleep()方法是一个静态方法，也就是说他只对当前对象有效，通过t.sleep()让t对象进入sleep，这样的做法是错误的，它只会是使当前线程被sleep 而不是t线程 wait属于Object的成员方法，一旦一个对象调用了wait方法，必须要采用notify()和notifyAll()方法唤醒该进程;如果线程拥有某个或某些对象的同步锁，那么在调用了wait()后，这个线程就会释放它持有的所有同步资源，而不限于这个被调用了wait()方法的对象。wait()方法也同样会在wait的过程中有可能被其他对象调用interrupt()方法而产生 waite()和notify()因为会对对象的“锁标志”进行操作，所以它们必须在synchronized函数或synchronized block中进行调用。如果在non-synchronized函数或non-synchronizedblock中进行调用，虽然能编译通过，但在运行时会发生illegalMonitorStateException的异常。 4 yield()和join()方法yield方法 暂停当前正在执行的线程对象。 yield()方法是停止当前线程，让同等优先权的线程或更高优先级的线程有执行的机会。如果没有的话，那么yield()方法将不会起作用，并且由可执行状态后马上又被执行。 join方法是用于在某一个线程的执行过程中调用另一个线程执行，等到被调用的线程执行结束后，再继续执行当前线程。如：t.join();主要用于等待t线程运行结束，若无此句，main则会执行完毕，导致结果不可预测。 线程池1 线程池的概念线程池:jdk1.5之后提供的 线程池其实就是一个容纳多个线程的容器，其中的线程可以反复使用，省去了频繁创建线程对象的操作，无需反复创建线程而消耗过多的资源 合理使用线程池的好处： 降低资源消耗，减少了创建和销毁线程的次数，每个工作线程都可以被重复利用，可执行多个任务 提高响应速度，当任务到达时，任务可以不需要等到线程创建就能立即执行 提高线程的可管理性，可以根据系统的承受能力，调整线程池中工作线程的数量，防止因为消耗过多的内存，导致把服务器累趴下 2 线程池的使用java里面线程池的顶级接口是java.util.concurrent.Executor,但是严格意义上来讲Executor并不是一个线程池，而是一个可以执行线程的工具，真正的线程池接口是java.util.concurrent.ExecutorService java.util.concurrent.Executors是一个操作线程池的工具类 12345678910111213141516Executors中的静态方法: static ExectuorsService newFixedThreadPool(int nThread)创建一个可重复使用的固定数量的线程池 参数: int nThreads:创建的线程池中包含的线程的数量 返回值: ExecutorService接口,返回的是ExecutorService接口的实现类对象,我们可以使用ExecutorService接口接收 java.util.concurrent.ExecutorService:线程池接口 用来从线程池中获取线程,调用start方法,执行线程任务 submit(Runnable task) 提交一个Runnable 任务用于执行 关闭/销毁线程池的方法 void shutdown() 线程池的使用步骤: 1.使用线程池工厂类Executors里面提供的静态方法newFixedThreadPool生产一个指定线程数量的线程池 2.创建一个类,实现Runnable接口,重写run方法,设置线程任务 3.调用ExecutorService中的方法submit,传递线程任务(实现类),开启线程,执行run方法 4.调用ExecutorService中的方法shutdown方法来销毁线程池(不建议执行)]]></content>
      <categories>
        <category>Java</category>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[异常相关内容]]></title>
    <url>%2F2019%2F09%2F27%2F%E5%BC%82%E5%B8%B8%E7%9B%B8%E5%85%B3%E5%86%85%E5%AE%B9%2F</url>
    <content type="text"><![CDATA[异常java.lang.Throwable:类是Java语言中所有异常和错误的超类 ​ Exception:编译期异常,进行编译(写代码)java程序出现的异常 ​ RuntimeException:运行期异常,java程序运行过程中出现问题 ​ 异常就相当于程序得了一个小毛病,把异常处理掉,程序就可以继续执行了 ​ Error:错误​​ 错误相当于程序得了一个无法治愈的毛病,必须要修改源代码,程序才能继续执行 Throw:throw是语句抛出一个异常，一般是在代码块的内部，当程序出现某种逻辑错误时由程序员主动抛出某种特定类型的异常 ​ 作用:可以使用Throw关键字在指定的方法中抛出指定的异常 ​ 使用格式:throw new xxxException(“异常产生的原因”); ​ 注意: throw关键字必须写在方法的内部 throw关键字后面new的对象必须是Exception或者Exception的子类对象 throw关键字输出指定的异常对象,我们就必须处理这个异常对象 throw关键字后面创建的是RuntimeException或者是RuntimeException的子类对象,我们可以不处理,默认交给JVM处理(打印异常对象,中断程序) throw关键字后面创建的是编译异常(写代码的时候出现的异常),我们就必须要处理这个异常,要么throws要么try…catch Throws:throws是方法可能抛出异常的声明。是异常处理的第一种方式 (用在声明方法时，表示该方法可能要抛出异常)向调用该类的位置抛出异常，不在该类解决 ​ 作用: ​ 当方法内部抛出异常对象的时候,我们就必须处理这个异常对象 ​ 可以使用throws关键字处理异常对象,会把异常对象声明抛出给方法的调用者处理(自己不处理,给别人处理),最终交给JVM处理(中断处理) ​ 使用格式: 1234修饰符 返回值类型 方法名 (参数列表) throws aaaException,bbbException...&#123; throw new aaaException; throw new bbbException;&#125; 格式: throws关键字必须写在方法声明处 throws关键字后面声明的异常,那么throws后面必须也声明多个异常 方法内部如果抛出了多个异常对象,那么throws后面必须声明多个异常 如果抛出的多个异常之间有字符类关系,则只需要声明父类即可 调用一个声明了抛出异常的方法,我们就必须处理声明的异常 要么直接使用throws声明抛出,交给方法的调用者处理,最终交给JVM 要么try…catch自己,处理异常 try…catch:异常处理的第二种方式,自己处理异常 格式: 12345678910try&#123; 可能出现异常的代码&#125;catch (定义一个异常的变量,用来接收try中抛出的异常对象)&#123; 异常的处理逻辑,出现异常对象之后,怎么处理异常对象 一般在工作中,会把异常的信息记录到一个日志中&#125;...catch (异常类名 变量名) &#123; 异常的处理逻辑&#125; 注意: try中可能会抛出多个异常对象,那么就可以使用多个catch来处理异常对象,此时如果catch里面定义的异常变量有子父类关系,那么子类的异常变量必须写在上面,否则就会出错 如果try中产生了异常,那么就会执行catch中的异常处理逻辑,执行完毕catch中的处理逻辑,继续执行try…catch之后的代码 如果try中没有出现异常,那么就不会执行catch中异常的处理逻辑,执行完try中的代码,继续执行try…catch之后的代码 finally finally代码块中的代码无论是否出现异常都会执行 finally不能单独使用,必须和try一起使用 finally一般用于资源释放,无论程序是否出现异常最后都要释放资源 异常处理的方式 运行时异常可以不处理,即不捕获也不声明抛出 如果父类抛出了多个异常,子类覆盖父类方法时,只能抛出相同的异常或者是其他的子类 父类方法没有抛出异常,子类覆盖父类方法时也不可抛出异常,此时子类产生该异常,只能捕获异常,不能声明抛出 finally有return语句,永远返回finally中的结果,要避免这种情况出现 获取异常信息的方法Throwable类中定义了一些查看方法: public String getMessage():获取异常的描述信息,原因(提示用户的时候,就提示错误原因)信息最简略 public String toString():获取异常的类型和异常描述信息(不用) public void printStackTrace():打印异常的跟踪栈信息并输出到控制台(包含了异常的类型,异常的原因,还包括异常出现的位置,在开发和调试阶段都得用printStackTrace),JVM打印异常对象,默认此方法,打印的异常信息是最全面的 自定义异常自定义一个类继承Exception或者RuntimeException,添加两个构造方法, 一个空参数的构造方法(调用父类的空参构造方法),一个带异常信息的构造方法(调用父类的带异常信息的构造方法,让父类来处理这个异常信息) 如果继承的是Exception:那么定义的异常类就是一个编译时异常,如果方法内部抛出了编译期异常,就必须处理这个异常,要么throws要么try…catch 如果继承的是RuntimeException:那么定义的异常就是一个运行时异常,无需处理,交给虚拟机处理(中断处理)]]></content>
      <categories>
        <category>Java</category>
        <category>Exception</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>异常</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[I/O相关内容]]></title>
    <url>%2F2019%2F09%2F26%2FIO%E7%9B%B8%E5%85%B3%E5%86%85%E5%AE%B9%2F</url>
    <content type="text"><![CDATA[Java中的IOIO解决的问题解决设备与设备之间的数据传输问题，比如 硬盘—-&gt;内存 内存—–&gt;硬盘 字节流什么情况使用字节流：读取到数据不需要经过编码或者解码的情况下这时候使用字节流，比如：图片数据 输入字节流InputStream 所有输入字节流的基类，抽象类 FileInputStream 读取文件的输入字节流 BufferedInputStream 缓冲输入字节流，该类内部其实就是维护一个8KB字节数组而已。该类出现的目的是为了提高读取文件数据的效率 输出字节流OutputStream 所有输出字节流的基类，抽象类 FileOutputStream 向文件输出数据的输出字节流 BufferedOutputStream 缓冲输出字节流，该类出现的目的是为了提高向文件写数据的效率，该类内部其实也是维护了一个8KB的字节数据而已 字符流字符流=字节流+编码(解码)，如果读写的都是字符数据，这时候我们就使用字符流 输入字符流Reader 所有输入字符流的基类，抽象类 FileReader 读取文件字符的输入字符流 BufferedReader 缓冲输入字符流，该类出现的目的是为了提高读取文件字符的效率并且拓展了功能(readLine())，它内部其实就是维护了一个8192个长度的数组 输出字符流Writer 所有输出字符流的基类，抽象类 FileWriter 向文件输出字符数据的输出字符流 BufferedWriter 缓冲输出字符流，该类出现的目的是为了提高写文件字符的效率并且拓展了功能(newLine())，它内部其实就是维护了一个8192个长度的数组 转换流输入字节流的转换流 ： 输入字节流 转换成输入字符流InputStreamReader 输出字节流的转换流OutputStreamWriter 转换流的作用 可以把对应的字节流转换成字符流使用 可以指定码表进行读写文件的数据 FileReader FileWriter这2个类默认是使用的是gbk编码表，不能由你指定码表 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778package cn.xlucas.io; import java.io.BufferedReader;import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.FileOutputStream;import java.io.FileReader;import java.io.IOException;import java.io.InputStream;import java.io.InputStreamReader;import java.io.OutputStream;import java.io.OutputStreamWriter;import java.net.InetAddress;import java.net.Socket; public class IoDemo1 &#123; public static void main(String[] args) throws IOException &#123; //testInput(); writeFile(); readFile(); &#125; //将文件的内容读取出来 public static void readFile() throws IOException&#123; //建立文件与程序的输入数据通道 FileInputStream filein=new FileInputStream("F:\\a.txt"); //创建输入字节流的转换流并且指定码表进行读取 InputStreamReader inputin=new InputStreamReader(filein,"utf-8"); //FileReader filein =new FileReader("F:\\a.txt");//这种会出现乱码的情况 int context=0; while((context=inputin.read())!=-1)&#123; System.out.print((char)context); &#125; //关闭资源 inputin.close(); filein.close(); &#125; //将内容用utf-8的格式写入文件中 public static void writeFile() throws IOException&#123; //建立了文件与程序的数据 通道 FileOutputStream fileout=new FileOutputStream("F:\\a.txt"); //创建一个输出字节流的转换流并且指定码表进行写数据 OutputStreamWriter output=new OutputStreamWriter(fileout,"utf-8"); output.write("中国"); output.close(); fileout.close(); &#125; public static void testOutput() throws Exception&#123; Socket socket = new Socket(InetAddress.getLocalHost(),9090); //获取到socket的输出流对象。 OutputStream outputStream = socket.getOutputStream(); //把输出字节流转换成输出字符流 OutputStreamWriter outputStreamWriter = new OutputStreamWriter(outputStream); outputStreamWriter.write("不饿!"); &#125; public static void testInput() throws IOException&#123; InputStream in=System.in; //输入转换流 InputStreamReader input=new InputStreamReader(in); BufferedReader buffer=new BufferedReader(input);//用来做缓冲 //int context =in.read();// 每次只会读取到一个字节的数据 System.out.print(buffer.readLine());//读取一行数据 //关闭字眼 buffer.close(); input.close(); &#125; &#125;]]></content>
      <categories>
        <category>Java</category>
        <category>I/O</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>I/O</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[接口相关内容]]></title>
    <url>%2F2019%2F09%2F23%2F%E6%8E%A5%E5%8F%A3%E7%9B%B8%E5%85%B3%E5%86%85%E5%AE%B9%2F</url>
    <content type="text"><![CDATA[接口:定义：接口，是Java语言中一种引用类型，是方法的集合，如果说类的内部封装了成员变量、构造方法和成员方法，那么接口的内部主要就是封装了的方法，包含抽象方法和常量（JDK 7及以前），默认方法和静态方法（JDK 8），私有方法（JDK 9）。 格式：123public interface 接口名称&#123; //接口内容&#125; 备注:换成了interface关键字之后,编译生成的字节码文件仍然是:.java-&gt;.class 接口的使用:接口不能直接使用,如要使用接口则必须有一个实现类来实现该接口 123public class 实现类名称 implements 接口名称&#123; //...&#125; 创建实现类的对象,进行使用 抽象方法的使用:格式: 1public abstract 返回值类型 方法名称(参数列表); 注意事项: 接口中的抽象方法,修饰符必须是两个固定的关键字,public abstract 这两个关键字修饰符,可以选择性的省略 接口中的抽象方法就是供子类(实现类),重写的,接口的实现类如果是普通类,那么必须重写接口中的所有抽象方法,如果不完全重写接口中的抽象方法,那么那么该实现类必须是一个抽象类 默认方法的使用:从Java8开始,接口里允许定义默认方法,它可以解决接口升级的问题(当接口升级,里面需要添加新的方法时,已经实现了该接口的实现类就会报错,此时我们将这个新添加的方法设置为默认方法,就可以解决这个问题) 格式: 123public default 返回值类型 方法名称(参数列表) &#123; //方法体&#125; 注意事项: 接口的默认方法,可以通过接口实现类对象,直接调用 接口的默认方法,可以被接口实现类进行覆盖重写 静态方法的使用:从Java8开始,接口里允许定义静态方法,通过接口名称直接调用 格式: 123public static 返回值类型 方法名(参数列表)&#123; //方法体&#125; 注意事项; 不能通过接口实现类的对象来调用接口当中的静态方法 通过接口名称,直接调用其中的静态方法 私有方法的使用:从Java9开始,接口里面允许定义私有的方法,当接口中的多个默认方法(静态方法)有重复代码的时候,抽取公共部分,形成一个方法,但该方法不应该让实现类使用,所以将其定义为私有的. 格式: 普通私有方法: 123private 返回值类型 方法名称(参数列表)&#123; //方法体&#125; 静态私有方法: 123private static 返回值类型 方法名称(参数列表)&#123; //方法体&#125; 常量的使用:接口当中也可以定义”成员变量”,但是必须使用public static final三个关键字修饰 格式: 1public static final 数据类型 常量名称 = 数据值; 注意事项: ,接口中的常量,可以省略public static final,省略了默认也是这三个关键字 接口中的常量,必须进行赋值,不能不赋值,而且一旦赋值,不能改变 接口中常量的名称,使用完全大写的字母,用下划线进行分割(推荐命名规则) 使用时直接使用接口名称进行调用 抽象类和接口的区别: 概念不一样。 接口是对动作的抽象，抽象类是对本质的抽象。抽象类表示的是，这个对象是什么。接口表示的是，这个对象能做什么。比如，男人，女人，这两个类（如果是类的话……），他们的抽象类是人。说明，他们都是人。人可以吃东西，狗也可以吃东西，你可以把“吃东西”定义成一个接口，然后让这些类去实现它。所以，在高级语言上，一个类只能继承一个类（抽象类）(正如人不可能同时是生物和非生物)，但是可以实现多个接口(吃饭接口、走路接口)。 使用不一样： 抽象类 和 接口 都是用来抽象具体对象的. 但是接口的抽象级别最高 抽象类可以有具体的方法 和属性, 接口只能有抽象方法和不可变常量 抽象类主要用来抽象类别,接口主要用来抽象功能. 抽象类中，且不包含任何实现，派生类必须覆盖它们。接口中所有方法都必须是未实现的。 接口是设计的结果 ，抽象类是重构的结果 使用方向： 当你关注一个事物的本质的时候，用抽象类； 当你关注一个操作的时候，用接口。 注意：抽象类的功能要远超过接口，但是，定义抽象类的代价高。因为高级语言来说（从实际设计上来说也是）每个类只能继承一个类。在这个类中，你必须继承或编写出其所有子类的所有共性。虽然接口在功能上会弱化许多，但是它只是针对一个动作的描述。而且你可以在一个类中同时实现多个接口。在设计阶段会降低难度的。 使用接口的注意事项: 接口是没有静态代码块或者构造方法的 一个类的直接父类是唯一的,但是一个类可以实现多个接口 格式: 123public class MyInterfaceImpl implements MyInterfaceA,MyInterfaceB&#123; //覆盖重写所有的抽象方法&#125; 如果实现类所实现的多个接口当中, 存在重复的抽象方法,那么只需要覆盖重写一次即可 如果实现类没有重写所实现的所有接口当中的所有方法,那么实现类就必须是一个抽象类 如果实现类所实现的接口当中,存在重复的默认方法,那么实现类一定要对冲突的默认方法进行重写 一个类如果:直接父类中的方法和接口当中的默认方法产生了冲突,优先使用父类当中的方法 继承与实现关系: 类与类之间是单继承的,直接父类只能有一个 类与接口之间是多实现的,一个类可以实现多个接口 接口与接口之间是多继承的 注意事项: 多个父接口当中的抽象方法如果重复,没关系(因为抽象方法没有方法体,子接口一定会继承这个相同的抽象方法,不存在冲突,子接口的非抽象实现类将会重写该相同的抽象方法) 多个父接口当中的默认方法如果重复,那么子接口必须进行默认方法的重写和覆盖,而且必须带着default关键字]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Interface</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[操作系统相关内容]]></title>
    <url>%2F2019%2F09%2F23%2F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9B%B8%E5%85%B3%E5%86%85%E5%AE%B9%2F</url>
    <content type="text"><![CDATA[进程进程PCB的含义，进程如何表示的？ PCB（进程控制块）是一个随进程存在而存在的进程描述和进程控制信息的集合。进程就是由进程控制块这个灵魂和程序，数据这个这个实体表示的。 进程与程序的本质区别？ 程序是永存的；进程是暂时的，是程序在数据集上的一次执行，有创建有撤销，存在是暂时的； 程序是静态的观念，进程是动态的观念； 进程具有并发性，而程序没有； 进程是竞争计算机资源的基本单位，程序不是。（进程是一个可拥有资源的独立单位，进程同时又是一个可独立调度和分派的基本单位 进程和程序不是一一对应的：一个进程可以执行一个或多个程序；反之，同一个程序可能由几个进程同时执行。 进程与线程的区别与关系？ 线程是进程内的一个可调度的实体 线程是进程的一个组成部分。每个进程在创建时通常只有一个线程，需要时这个线程可以创建其他线程。 进程的多线程都在进程的地址空间活动。 资源是分给进程的，而不是分给线程的。线程在执行中需要资源时，系统从进程的资源配额中扣除并分配给它。 处理机调度的基本单位是线程，线程之间竞争处理机，真正在处理机上运行的是线程。 线程在执行过程中，需要同步。 举实例解释进程的同步与互斥的涵义。 进程的同步： 两个进程相互协作共同完成一个任务。Z=func1(x)*func2(y),进程P1执行func1,进程P2执行func2。进程P1和进程P2各自计算，完成后将P1和P2的计算结果相乘即可。 进程的互斥： 进程P1和进程P2在执行的过程中都需要资源A，但是A同一时间内只能由一个进程占有，所以假设进程P1先占用了A，则P2在运行时需要A时，只有当进程P1释放了A资源后，进程P2才可继续执行。 死锁死锁的概念：当某一进程提出资源的使用要求后，使得系统中一些进程处于无休止的阻塞状态，在无外力的作用下，这些进程永远也不能继续前进，我们称这种现象为死锁。 死锁的起因：一个进程在其运行的过程中可以提出使用多个资源的要求,仅当指定的全部资源都满足时,进程才能继续运行而到达终点,否则该进程因为得不到所要求的资源而处于阻塞状态,当两个或两个以上的进程同时对多个互斥的资源提出使用要求时,就有可能导致死锁 产生死锁的必要条件: 互斥控制:进程对其所要求的资源进行排它控制,一个资源仅能被一个进程独占 非剥夺控制:进程所获得的资源在未被释放之前,不能被其他的进程剥夺,即使该进程出于阻塞状态,它所占用的资源也不能被其他进程使用,而其他进程只能等待该资源的释放 逐次请求:进程以随意的零星方式逐次获得资源,而不是集中性的一次请求,这样有利于提高资源的利用率 环路条件:在发生死锁时,其有向图必构成环路,即前一进程保持者后一进程所要求的资源 处理死锁的四种策略预防死锁:破坏四个必要条件中的一个或者多个来预防死锁 破坏互斥控制,可以采用资源共享法,即允许一个资源可由多个进程同时使用, 破坏非剥夺控制,可以采用剥夺控制,也可以当一个进程获得某种不可抢占资源,提出新的资源申请,若不能满足资源条件则得不到资源分配,以后需要,再次重新申请 破坏逐次请求:1.一次性的申请所有资源,之后不再申请资源,如果不满足资源条件则得不到资源分配2.只获得初期资源后运行,之后将运行完的资源释放,请求新的资源 破坏环路条件:对资源进行排序,按照序号递增的顺序请求资源,若进程获得序号高的资源想要获取序号低的资源,就需要先释放序号高的资源 避免死锁:在资源动态分配的过程中,用某种方式防止系统进入不安全的状态(银行家算法) 检测死锁:运行时产生死锁,及时发现死锁,将程序解脱出来 解除死锁:发生死锁后,撤销进程,回收资源,分配给正在阻塞状态的进程,或者抢占资源 进程间通信的方式进程间通信（IPC，InterProcess Communication）是指在不同进程之间传播或交换信息。 IPC的方式通常有管道（包括无名管道和命名管道）、消息队列、信号量、共享存储、Socket、Streams等。其中 Socket和Streams支持不同主机上的两个进程IPC。 进程间数据共享的方式进程通信是指进程之间的信息交换 共享存储器系统 基于共享数据结构的通信方式 （仅适用于传递相对少量的数据，通信效率低，属于低级通信） 基于共享存储区的通信方式 管道通信系统 管道是指用于连接一个读进程和一个写进程以实现它们之间通信的一个共享文件（pipe文件） 管道机制需要提供一下几点的协调能力 互斥，即当一个进程正在对pipe执行读/写操作时，其它进程必须等待 同步，当一个进程将一定数量的数据写入，然后就去睡眠等待，直到读进程将数据取走，再去唤醒。读进程与之类似 确定对方是否存在 消息传递系统 直接通信方式 发送进程利用OS所提供的发送原语直接把消息发给目标进程 间接通信方式 发送和接收进程都通过共享实体（邮箱）的方式进行消息的发送和接收 客户机服务器系统 套接字 – 通信标识型的数据结构是进程通信和网络通信的基本构件 基于文件型的 （当通信进程都在同一台服务器中）其原理类似于管道 基于网络型的（非对称方式通信，发送者需要提供接收者命名。通信双方的进程运行在不同主机环境下被分配了一对套接字，一个属于发送进程，一个属于接收进程） 远程过程调用和远程方法调用]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>进程管理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[集合相关内容]]></title>
    <url>%2F2019%2F09%2F15%2F%E9%9B%86%E5%90%88%E7%9B%B8%E5%85%B3%E5%86%85%E5%AE%B9%2F</url>
    <content type="text"><![CDATA[数组和集合的比较数组不是面向对象的，存在明显的缺陷，集合弥补了数组的缺点，比数组更灵活更实用，而且不同的集合框架类可适用不同场合。如下: 数组能存放基本数据类型和对象，而集合类存放的都是对象的引用，而非对象本身！ 数组容易固定无法动态改变，集合类容量动态改变。 数组无法判断其中实际存有多少元素，length只告诉了数组的容量，而集合的size()可以确切知道元素的个数 集合有多种实现方式和不同适用场合，不像数组仅采用顺序表方式 集合以类的形式存在，具有封装、继承、多态等类的特性，通过简单的方法和属性即可实现各种复杂操作，大大提高了软件的开发效率 Java集合整体图 Collection和Map是集合框架的根接口 Collection的子接口Set接口—&gt;实现类：HashSet、LinkedHashSet ​ Set的子接口SortedSet接口—&gt;实现类：TreeSet List接口—&gt;实现类：LinkedList、Vector、ArrayList List集合 有序的集合，允许存放重复的元素，有索引，元素可以为null 实现类： ArrayList：数组实现，查询快，增删慢，轻量级（线程不安全的） LinkedList:双向循环列表实现，增删快，查询慢（线程不安全） Vector:数组实现，重量级（线程安全，不经常使用） List常用方法： void add (int index,Object element):添加对象element到位置index上 boolean addAll(int index,Collection collection):在index位置后添加容器collection中所有的元素 Object get (int index):取出下标为index的位置的元素 int indexOf(Object element):查找对象element在List中第一次出现的位置 int lastIndexOf(Object element):查找对象element在List中最后出现的位置 Object remove(int index):删除index位置上的元素 ListIterator listIterator(int startIndex):返回一个ListIterator迭代器，开始位置为startIndex List subList(int fromIndex,int toIndex):返回一个子列表，元素存放为fromIndex到toIndex之前的所有元素 利用LinkedList实现栈（stack)、队列（queue）、双向队列（double-ended queue)。LinkedList具有addFirst()、addLast()、getFirst()、getLast()、removeFirst()、removeLast()等方法。 用LinkedList实现队列： 队列是限定所有的插入只能在表的一端进行，而所有的删除都在表的另一端进行的线性表。表中允许插入的一端称为队尾，允许删除的一端称为对头，队列的操作是按照先进先出的原则进行的，队列的物理存储可以用顺序存储结构也可以用链式存储结构 用LinkedList实现栈： 栈也是一种特殊的线性表，是一种先进后出的结构，栈是限定在表尾进行插入和删除运算的线性表，表尾称为栈顶，表头称为栈底，栈的物理存储可以用顺序结构，也可以使用链式存储结构 Set集合 不允许存放重复的元素，没有索引，允许使用null元素，但是不能重复，所以只能有一个空元素 实现类: HashSet:不仅不能保证元素插入的顺序，而且元素在以后的顺序中也可能发生变化（这是由于HashSet按照Hash’Code存储对象单元决定的，对象变化可能也会导致HashCode变化），HashSet是线程非安全的。HashSet的后台有一个HashMap初始化后台容量，而HashMap的底层是哈希表(数组+单向链表+红黑树(链表的长度超过8)),只不过生成一个HashSet的话，系统只提供key的访问，如果有两个key相同，那么会覆盖之前 的。 LinkedHashSet:此实现与HashSet的不同之处在于它维护这一个运行于所有条目的双重连接列表，存储的数据是有序的 TreeSet:TreeSet实现了SortedSet接口，顾名思义，这是一种排序的Set集合，查看jdk源码发现底层是用TreeMap实现的，本质上是一个红黑树原理。正因为他是排了序的，所以相对HashSet来说，TreeSet提供了一些额外的按照排序位置访问元素的方法，例如first()、last()、lower()、higher()、subSet()、headSet()、tailSet()。TreeSet的排序分为两种，一种是自然排序，一种是定制排序。 HashSet常用的方法： public boolean contaions(Object o):如果Set包含指定的元素，返回True public Iterator iterator()：返回Set集合中元素的迭代器 public Object[] toArray():返回包含Set中所有元素的数组 public Object[] toArray(Object[] a):返回包含Set中所有元素的数组，返回数组的运行时类型是指定数组的运行时类型。 public boolean add(Object o):如果set中不存在指定元素，则向set中添加 public boolean remove(Object o):如果set中存在指定的元素，则从set中删除 public boolean removeAll(Collection c):如果set中包含指定的集合，则从set中删除指定集合的所有元素 public boolean containsAll(Collection c):如果set包含指定集合的所有元素，返回true，如果指定的集合也是一个set，只有是当前set的子集时，返回true HastSet的equals和HashCode 前面说过Set集合是不允许重复元素的，否则将会引发各种各样的问题，那么HashSet如何判断元素重复呢？ HashSet集合通过equals和HashCode连个方法来判断两个元素是否相等，具体规则是： 调用元素HashCode方法获得哈希码，判断哈希码是否相等，不相等则录入 相等的话，再判断equals方法是否返回true，如果为true则不录入，如果为false则录入 所以如果要将自定义的类装入Set集合中，需要重写HashCode和equals方法，这样才能保证装入Set中的元素具有独一性 LinkedHashSet的特性： LinkedHashSet是HashSet的一个子类，LinkedHashSet也根据HashCode的值来决定元素的存储位置，但同时它还用一个链表来维护元素的插入顺序，插入的时候既要计算HashCode的值，又要维护链表，而遍历的时候只需要按照链表来访问元素，查看LinkedHashSet的源码发现它是一样的。由此可知，LinkedHashSet本质上也是从LinkedHashMap而来，LinkedHashSet的所有方法都继承自HashSet,他能维持元素的插入顺序的性质则继承自LinkedHashMap TreeSet的特性： TreeSet会调用compareTo方法比较两个元素的大小，然后按照升序排序，所以自然排序中的元素对象，都必须 实现了CompareTo接口，否则会抛出异常，对于TreeSet判断元素是否重复的标准，也是调用元素从Comparable接口继承而来的compareTo方法，如果放回0，则是重复元素。Java中常见的类都已经实现了Comparable接口。并且TreeSet中只允许存入同一类的元素。 TreeSet是依靠TreeMap实现的，TreeSet集合中元素将按照升序排列，缺省是按照自然顺序进行排列，以为着TreeSet中元素要实现Comparable接口，我们可以在构造TreeSet对象时，传递实现了Comparator接口的比较器对象。 几种Set的比较： HashSet外部无序的遍历成员。成员可为任意Object类型的子类的对象，但如果覆盖了equals方法，同时注意修改hashCode方法。 TreeSet外部有序的遍历成员。附加实现了SortedSet，支持子集等要求顺序的操作 成员要求实现Comparable接口，或者使用Comparator构造TreeSet。成员一般都为同一类型。 LinkedHashSet外部按成员的插入顺序遍历成员。成员和HashSet成员类似 HashSet是基于Hash算法实现的，其性能通常都优于TreeSet。我们通常都应该使用HashSet，在我们需要排序的功能的时候，我们才使用TreeSet HashSet的元素存放顺序和我们添加进去的顺序没有任何关系，而LinkedHashSet则保持元素的添加顺序。TreeSet则是对我们的Set中的元素进行排序存放。 几种Set集合性能分析 HashSet和TreeSet是Set集合中用的最多的集合。HashSet总是比TreeSet集合性能更好，因为HashSet不需要额外维护元素的顺序。 LinkedHashSet需要用额外的链表维护元素的插入顺序，因此在插入时性能比HashSet低，但在迭代访问是想能更高，因为插入的时候既要计算ha’sh’Code又要维护链表，而访问的时候只需要按照链表来访问元素。 EnumSet元素是所有Set元素中性能最好的，但是它只能保存Enum类型的元素。 Map的子接口Map接口—&gt;实现类：HashMap、TreeMap、LinkedHashMap、Hashtable等 它提供了一组键值的映射。其中存储的每个对象都有一个相应的关键字（key)，关键字决定了对象在Map集合中的存储位置。 关键字应该是唯一的，每一个key只能映射一个value。 Map集合 实现类： HashMap：键值对，key不能重复，但是value可以重复，key的实现就是HashSet；value对应着放；允许null的键或者值。 HashTable：线程安全的，不允许null的键或者值。 Properties：key和value都是String类型，用来读配置文件。 TreeMap：对key排好序的Map，key就是TreeSet，value对应每一个key，key要实现Comparable接口或者TreeMap有自己的构造器。 LinkedHashMap：此实现与HashMap的不同之处在于，后者维护着一个运行于所有条目的双重链接列表。存储的数据是有顺序的。 HashMap： Map主要存储键值对，根据键得到值，因此键不允许重复，但允许值重复。 HashMap是一个最常用的Map，它根据键的HashCode值存储数据，根据键可以直接获取它的值，具有很快的访问速度。 HashMap：最多只允许一条记录的键为null。允许多条记录的值为null。 HashMap：不支持线程的同步，即任一时刻可以有多个线程同时写HashMap；可能会导致数据的不一致，如果需要同步，可以用Collections的synchronizedMap方法使HashMap具有同步的能力。 HashMap实现原理: Hash哈希算法的意义在于提供了一种快速存储数据的方法，它用一种算法建立键值与真实值之间的对应关系。散列表又称为哈希表。散列表算法的基本思想是：以结点的关键字为变量，通过一定的函数关系（散列函数）计算出对应的函数值，以这个值作为该结点存储在散列表中的地址。 当散列表中的元素存放太满，就必须进行再散列，将产生一个新的散列表，所有元素存放到新的散列表中，原先的散列表将被删除，在Java语言中通过负载因子来决定何时对散列表进行再散列。 Map集合比较： HashMap的存入顺序和输出顺序无关。 LinkedHashMap则保留了键值对的存入顺序。 TreeMap则是对Map中的元素进行了排序 因为HashMap和LinkedHashMap存储数据的速度比直接使用TreeMap要快，存取效率要高。当我们完成了所有的元素的存放之后，我们再对整个的Map集合进行排序，这样可以提高整个程序的运行的效率，缩短执行时间。 HashMap与TreeMap联系与区别 HashMap通过hashcode对其内容进行快速查找，而TreeMap中所有的元素都保持着某种固定的顺序，如果你需要得到一个有序的结果你就应该使用TreeMap（HashMap中元素的排列顺序是不固定的）。 在Map 中插入、删除和定位元素，HashMap是最好的选择。但如果您要按自然顺序或自定义顺序遍历键，那么TreeMap会更好。使用HashMap要求添加的键类明确定义了hashCode()和 equals()的实现。两个map中的元素一样，但顺序不一样，导致hashCode()不一样。 Map常用的方法： Object put(Object key,Object value):用来存放一个键值对到Map中 Object remove(Object key):根据key(键),移除键值对,并将值返回 void clear():清空当前Map中的元素 Object get(Object key):根据key取得对应的值 boolean containsKey(Object key):判断Map中是否存在某键(key) boolean containsValue(Object value):判断Map中是否存在某值 public Set keySet():返回所有的键,并使用Set容器存放 public Collection values():返回所有的值,并使用Collection存放 public Set entrySet():返回一个实现Map.Entry接口的元素Set 集合的遍历 List集合的遍历: 使用普通for循环,每次调用get()方法获取每一个索引的值的方式遍历整个集合 增强for循环遍历整个集合(本质上还是调用的Iterator迭代器) 迭代器的方式Iterator&lt;String&gt; it = list.iterator();while(it.hasNext()){it.next();} 转数组进行遍历list.toArray();for(); Set集合的遍历: 三种方式:因为Set集合是无序的所以比List集合少了第一种通过普通for循环方式遍历的方法 Map集合的遍历: 通过获取所有的Key的Set集合,按照key来遍历:map.keySet();然后遍历整个Set集合,通过get方法获取value 直接遍历所有的value,但不能遍历key:map.values() Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()返回此映射中包含的映射关系的 Set 视图,然后遍历整个Set集合,得到每一个entrySet对象,通过每一个entrySet对象的getKey()和getValue()方法获取对应的值 获取集合中最大的元素12345678910111213141516171819202122232425import java.util.ArrayList;import java.util.List; public class Test &#123; public static void main(String[] args) &#123; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); list.add(12); list.add(34); list.add(5); list.add(123); list.add(89); int min = Integer.MAX_VALUE; // 用于记录列表中的最小值 int max = Integer.MIN_VALUE;// 用于记录列表中的最大值 for (Integer integer : list) &#123; if (integer &lt; min) &#123; min = integer; // 遍历找出最小值 &#125; if (integer &gt; max) &#123; max = integer; // 遍历找出最大值 &#125; &#125; System.out.println("最小值是：" + min + "，最大值是：" + max); &#125;&#125; ArrayList list = new Arraylist(); ArrayList获取最大元素？ int maxElement = Collections.max(list); ArrayList获取最大元素索引？//此处注意，当list为空时，会抛出空指针异常，因此需要先进行list是否为空的判断 int indexOfMaxElement = list.indexOf(Collections.max(list)); 集合简记]]></content>
      <categories>
        <category>Java</category>
        <category>集合</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>集合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用的API]]></title>
    <url>%2F2019%2F09%2F15%2F%E5%B8%B8%E7%94%A8%E7%9A%84API%2F</url>
    <content type="text"><![CDATA[概述API(APPlication Programming Interface),应用程序编程接口,Java API 是一本程序员的字典,是JDK提供给我们使用的类的说明文档,这些类将底层的代码实现封装了其阿里,我们不需要关心这些类是如何实现的,只需要学习这些类如何使用即可,所以我们可以通过查询API的方式,来学习Java提供的类,并得知如何使用它们 使用步骤 导包 import 包路径.类名称 如果需要使用的目标类,和当前类位于同于个包下,可以省略导包语句不写,只有java.long包下的内容不需要导包,其他的包都需要import语句 创建 类名称 对象名 = new 类名称(); 使用 对象名.成员方法名(); Scanner类 一个可以辨析基本类型和字符串的简单文本扫描器 可以实现键盘输入数据,到程序中 System.in代表从键盘进行输入 常用方法: int mun = sc.nextInt(); String str = sc.next(); Java输入一行数据并转存到数组中 123456789101112131415161718import java.io.*;import java.util.*;public class Main&#123; public static void main(String[] args)throws IOException&#123; Scanner cin=new Scanner(System.in); String str=cin.nextLine();//读入一行数据 int []a=new int[10]; String []str1=str.split(" ");//以空格为分割，注意用双引号 int length=0; for(String s : str1)&#123; //使用foreach依次将字符串数组的元素转换为整型，也可以转换为其他类型 a[length++]=Integer.parseInt(s); &#125; for(int i=0;i&lt;length;i++)&#123; System.out.println(a[i]); &#125; &#125;&#125; Random类 Random用来生成随机数字 常用方法: nextInt()返回下一个随机的int类型的数 nextlong()返回下一个随机的long类型的数 nextInt(int n)返回一个随机数范围在0-不包括n之间 Arrays类java.util.Arrays类是一个与数组相关的工具类,里面提供了大量静态方法,用来实现数组常见的操作 public static String toString(数组),将参数数组变成字符串(按照默认格式:[元素1,元素2,元素3]) public static void sort(数组),按照默认升序(从下到大)对数组的元素进行排序 如果是数值,sort默认按照升序从小到大 如果是字符串,sort默认按照字母升序 如果是自定义类型,那么这个自定义的类需要有Comparable或者Comparator接口的支持 Math类java.util.Math类是一个与数学相关的工具类,里面提供了大量静态方法,完成与数学运算相关的操作 public static double abs(double num):获取绝对值 public static double ceil(double num):向上取整 public static double floor(double num):向下取整 public static long round(double num):四舍五入 public static double pow(double a,double b): 返回第一个参数的第二个参数次幂的值。 public static double sqrt(double a): 返回正确舍入的 double 值的正平方根 Math.PI:代表近似的圆周率常量(double) Object类java.long.Object类是类层次结构的父(根)类，每个类都使用Object类作为超类（父类），所有对象都实现这个类的方法 public String toString()：返回该对象的字符串表示形式，如果没有重写，那么返回的是该对象的地址值 public boolean equals(object obj): 指示其他对象是否与此对象“相等”，如果没有重写，那么比较的是两个对象的地址值 Objcets类java.util.Object类,java1,7后java加入,该类中提供了一些方法来操作对象,它由一些静态的方法组成,这些方法是空指针安全的,用于计算对象的hashcode(),返回对象的字符串表示形式toString(),比较两个对象equals() 在它的源码中,对对象为null的值进行了弹出异常操作 public static \&lt;T> requireNonNull(T obj):查看指定引用对象不是null,源码如下: 12345public static &lt;T&gt; T requireNonNull(T obj)&#123; if(obj == null) throw new NullPointerException(); return obj;&#125; Date类java.util.Date表示日期和事件的类,类date表示特定的瞬间,精确到毫秒值,可以对日期和时间进行计算,计算完再转化为日期 把日期转化为毫秒: 当前的日期:System.currentTimeMillis(); 时间原点:19701月1日00:00:00,中国为东八区所以为1970年1月1日08:00:00 1天 = 24*60*60=86400秒 = 86400*1000毫秒 Date类的空参构造方法 Date()获取当前系统的日期和事件 Date(long date):传递的是毫秒值,把毫秒值转化为Date日期 Date类的普通方法 Long getTime():把日期转化为毫秒值 DateFormat类java.text.DateFormat类是日期/时间格式化子类的抽象类,我们通过这个类可以帮我们实现日期和文本之间的转化,也就是可以在Date对象和String对象之间相互转化 DateFormat类是一个抽象类,无法直接创建对象使用,可以使用DateFormat类的子类 java.text.simpleDateFormat extends DateFormat 构造方法: SimpleDateFormat(String pattern):用给定的模式和默认语言环境的日期格式符号,构造SimpleDateFormat 参数:String pattern:传递指定的模式 模式:区分大小写的 Y:年 M:月 d:日 H:时 m:分 s:秒 写对应的模式,会将模式替换为对应的日期和时间 格式化:按照指定的格式,从Date对象转化为String对象 解析:按照指定的格式,从String对象转化为Date对象 成员方法: String fromat(Date date):按照指定的格式,把日期格式化为符合模式的字符串 Date parse(String str):把符合构造方法中模式的字符串转化为Date日期,parse声明了一个解析异常,如果我们的字符串和构造方法的模式不一样,那么程序就会抛出此异常 Calendar类java.util.Calendar类:日历类 Calendar类是一个抽象类,里边提供了很多操作日历字段的方法(YEAR,MONTH,DAY_OF_MONTH,HOUR),无法直接创建对象使用,但是Calendar类当中有一个静态方法getInstance()使用默认时区和语言环境获取一个日历Calendar c = Calendar getInstance(); 常用方法: publilc int get(int field):返回给定日历字段的值 public void set(int field,int value):将给定的日历字段设置为给定值 public abstract void add(int field,int amount):根据日历的规则,为给定的日历字段添加或者减去指定的时间量 public Date getTime():返回一个表示此Calendar时间值的Date对象 int field:日历类的字段,可以使用calendar类的静态成员变量获取 calendar.YEAR, calendar.MONTH,calendar.DATE,calendar.DAY_OF_MONTH,calendar.HOUR,calendar.MINUTE,calendar.SECOND System类java.lang.System类中提供了大量的静态方法,可以获取与当前系统有关的信息或系统级操作,在System类中常用的方法有: public static long currentTimeMillis():返回当前系统的时间毫秒值 public static void arraycopy(Object src,int srcPos,Object dest,int destPos,int length):将数组中指定的数据拷贝到另一个数组中 src:源数组 secPos:源数组中的起始位置dest:目标索引destPos:目标数据中的起始位置length:要复制的数组元素的数量 StringBuilder类String类:字符串是常量,他们的值在创建后不能改变,字符串的底层是一个被final修饰的字符数组,不能改变,是一个常量 进行字符串的相加,内存中就会有多个字符串,占用空间多,效率低下 java.lang.StringBuilder类,字符串缓冲区,可以提高字符串的操作效率(看成一个长度可以变化的字符串),底层也是一个字符数组,但是没有被final修饰,可以改变长度,初始长度为16,当长度不够时,可以自动扩容 构造方法: public StringBuilder();构造一个不带任何字符的字符串缓冲区,其初始容量为16个字符 public StringBuilder(String str):构造一个字符串缓冲区,它初始化为指定的字符串 普通方法: public StringBuilder append(…): 添加任意类型数据的字符串形式,并返回当前对象本身 public String toString(): 将当前对象StringBuilder对象转换位String对象 包装类:java.long.Integer,基本数据类型,使用起来非常方便,但是没有对应的方法来操作这些基本类型的数据,可以使用一个类,把基本类型的数据包装起来,在类中定义一些方法,这个类就称为包装类,我们可以使用这个类中的方法来操作这些基本类型的数据 int:Integer char:Character Collections类:java.utils.Collections是集合工具类,用来对集合进行操作,常用方法如下: public static\&lt;T> boolean addAll(Collection\&lt;T> c,T…elements):往集合中添加一些元素 public static void shuffle(List \&lt;?> list) : 打乱集合顺序 public static void sort(List\&lt;T> list) : 将集合中元素按照默认规则排序 public static void sort(List\&lt;T> list,Comparator\&lt;? super T>):将集合中元素按照指定规则排序 自定义比较的规则: 升序就是我减它(前减后 ),降序就是他减我]]></content>
      <categories>
        <category>Java</category>
        <category>API</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>API</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM相关内容]]></title>
    <url>%2F2019%2F09%2F14%2FJVM%E7%9B%B8%E5%85%B3%E5%86%85%E5%AE%B9%2F</url>
    <content type="text"><![CDATA[JVM: 作用:从软件层面屏蔽不同操作系统在底层硬件与指令上的区别 组成:运行时数据区域+类装载子系统（加载字节码文件到方法区当中）+执行引擎 JVM内存划分: 栈(stack):存放的都是方法中的局部变量,方法的运行一定要在栈当中 局部变量:方法的参数,或者是方法内部的变量 作用域:一旦超出范围,立即从栈内存当中消失 当程序运行过程中有一个线程运行时,JVM会在内存当中给这个线程分配出一块内存空间,这块儿内存空间就是栈,这个线程运行过程当中运行到的每一个方法都会进入这个栈,并且Jvm会给这个这个方法在当前这个线程的栈空间中分配一块儿栈内存空间,这一块儿内存空间就被称为栈帧,栈帧中存放的就是当前方法的局部变量表（用来存放当前方法的局部变量）,操作数栈(用来临时存放程序运行过程中的数据),动态链接（在程序运行的过程中把符号引用，转变为符号对应的指令码的直接引用地址）和方法出口（保存现场的作用，里面保存的是当前方法执行完要回到什么位置）,当这个方法运行结束后,这个栈帧也就出栈了 堆(heap):凡是new出来的东西,都在堆当中，这个对象的引用存放在栈当中 堆内存里面的东西都有一个地址值 堆内存里面的数据,都有默认值,规则: 如果是整数 默认为0; 如果是浮点数 默认为0.0; 如果是字符 默认为’\u0000’ 如果是布尔 默认为false 如果是引用类型 默认为null new出来的对象最先存放在Eden区,当Eden区被不断生成的对象占满时,会执行minorGC(垃圾收集),收集堆中游离的对象(没有GC Roots指针指向的对象),并将存活的对象存放到from区,当from区也满了之后,也会触发JVM执行引擎的垃圾收集(minorGC),并将存活的对象放到To区(并将分代年龄加一),当To区又被放满时,JVM又会执行(minorGC),将存活的对象存放到from区(并将分代年龄加一),默认当分代年龄为15时,如果这个对象还没有被销毁,就会将该对象放到老年代中,当老年代放满之后会执行(fullGC)垃圾收集,当垃圾收集没有从老年代中收集到什么对象时(老年代没有空间了),会产生OutOfMemoryError错误 GC Roots根节点:类加载器,Thread,虚拟机栈的本地变量表,static成员,常量引用,本地方法栈的变量等 finalize()方法最终判定对象是否存活: 即使在可达性分析算法中不可到达的对象,也并非是”非死不可” 的,这时候它们暂时存储于缓刑阶段,要真正宣告一个对象死亡,至少要经过两次标记过程,标记的前提是对象在进行可达性分析后,发现没有与GC Roots相链接的引用链 第一次标记进行一次筛选:筛选的条件是此对象是否有必要执行finalize()方法,当对象没有覆盖finalize方法,或者finalize方法已经被虚拟机调用过了,虚拟机将这两种情况都视为没有必要执行finalize()方法,对象被回收 第二次标记,如果这个对象被判定为有必要执行finalize()方法,那么这个对象会被放置在一个队列中,并在稍后由一条虚拟机自动建立的,低优先级的finalizer线程中去执行,finalize方法是对象脱离死亡命运的最后一次机会,稍后GC将对队列中的对象进行第二次小规模标记,如果对象在finalize()中自救成功——只要重新与引用链上的任何一个对象建立关联即可,譬如把自己的值赋给某个类变量或对象的成员变量,那么在第二次标记时它将被移出”即将被回收”的集合,如果对象没有逃脱,那么它就真的被回收了 finalize 的主要目的是在不可撤消地丢弃对象之前执行清除操作。 方法区(元空间Method Area):存储.class相关的信息,包含方法的信息，用来存储常量和静态变量以及类元信息，使用直接内存，并不占用虚拟机的内存 本地方法栈(Native Method Stack):也是每个线程独有的,java代码在执行系统方法的时候,系统方法中也有一些局部变量,这些变量就存储在本地方法栈当中 程序计数器(pc Register):与CPU相关,是每一个线程独有的,每一个线程在运行过程中,jvm都会给该线程分配一个程序计数器,用来标识该线程马上要执行的那一行代码的内存地址指针 常量池：它是方法区的一部分。Class文件中除了有类的版本信息、字段、方法、接口等描述信息外，还有一项信息就是常量池，用于存放编译期间生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中，另外翻译出来的直接引用也会存储在这个区域中。这个区域另外一个特点就是动态性，Java并不要求常量就一定要在编译期间才能产生，运行期间也可以在这个区域放入新的内容，String.intern()方法就是这个特性的应用。 JVM参数设置:-Xms：JVM启动时申请的初始Heap值，默认为操作系统物理内存的1/64但小于1G。 -Xmn: Java Heap Young区大小。整个堆大小=年轻代大小 + 年老代大小 + 持久代大小(相对于HotSpot 类型的虚拟机来说)。持久代一般固定大小为64m，所以增大年轻代后，将会减小年老代大小。此值对系统性能影响较大，Sun官方推荐配置为整个堆的3/8。 -XXSurvivorRatio：年轻代中Eden区与Survivor区的大小比值 -Xmx: JVM可申请的最大Heap值，默认值为物理内存的1/4但小于1G，默认当空余堆内存小于40%时，JVM会增大Heap到-Xmx指定的大小，可通过-XX:MinHeapFreeRation=来指定这个比列。最佳设值应该视物理内存大小及计算机内其他内存开销而定。(例如：-Xmx4g) -Xss : Java每个线程的Stack大小。JDK5.0以后每个线程堆栈大小为1M，以前每个线程堆栈大小为256K。根据应用的线程所需内存大小进行调整。在相同物理内存下，减小这个值能生成更多的线程。但是操作系统对一个进程内的线程数还是有限制的，不能无限生成，经验值在3000~5000左右。 -XX:PermSize: 持久代（方法区）的初始内存大小。（例如：-XX:PermSize=64m） -XX:MaxPermSize: 持久代（方法区）的最大内存大小。（例如：-XX:MaxPermSize=512m）]]></content>
      <categories>
        <category>Java虚拟机</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[方法相关内容]]></title>
    <url>%2F2019%2F09%2F13%2F%E6%96%B9%E6%B3%95%E7%9B%B8%E5%85%B3%E5%86%85%E5%AE%B9%2F</url>
    <content type="text"><![CDATA[基础 方法其实就是若干语句的功能集合 定义方法的完整格式: 1234修饰符 返回值类型 方法名称(参数类型 参数名称,...)&#123; 方法体; return 返回值;&#125; 修饰符:public private protected static final abstract 返回值类型:也就是方法最终产生的数据结果是什么类型 方法名称:方法的名字,规则和变量名一样,小驼峰式 参数类型:进入方法的数据是什么类型 参数名称:进入方法的数据对应的变量名称 参数如果有多个,采用逗号分隔 方法体:方法需要做的事情,若干行代码 return:两个作用,停止当前方法 将后面的返回值还给调用处 返回值:方法执行完后最终产生的数据结果 类型必须和方法定义中的返回值类型相一致 方法调用的三种方式: 单独调用:方法名称(参数); 打印调用:system.out.println(方法名称(参数)); 赋值调用:数据类型 变量名称 = 方法名称(参数); 注意事项: 方法应该定义在类当中,但是不能在方法中再定义方法,不能嵌套 方法定义的前后顺序无所谓 任何数据类型都可以作为方法的参数类型,或者返回值类型,数组作为参数传递的是地址值,同样的数组作为返回值返回的是数组的地址值 方法定义之后,自己不会执行的,如果希望执行,一定要进行方法的调用 如果方法有返回值,那么必须写上”return 返回值” ,不能没有 return 后面的返回值数据,必须和方法的返回值类型,对应起来 对于一个void没有返回值的方法,不能写return后面的返回值,只能写return; 对于无返回值的方法,方法中最后一行的return可以省略不写 一个方法当中可以有多个return语句,但是必须保证同时只有一个会被执行到,两个return不能连写 重载 对于功能类似的方法来说,因为参数列表不一样,却需要记住那么多不同方法的名称,太麻烦,方法的重载就是为了解决这个问题 方法的重载(Overload),多个方法的名称一样,但是参数列表不一样,只需要记住一个方法的名称就可以实现类似的多个方法的名称 在调用输出语句的时候,println方法其实就是进行了多种数据类型的重载形式 方法重载和下列因素有关: 参数个数不同 参数类型不同 参数的多类型顺序不同 方法重载和下列因素无关 与参数的名称无关 与方法的返回值类型无关 构造方法 构造方法是专门用来创建对象的方法,当我们通过关键字new来创建对象时,其实就是在调用构造方法 1234格式:修饰符 类名称(参数类型 参数名称)&#123; 方法体;&#125; 注意事项: 构造方法的名称必须和所在类的类名称完全相同 构造方法不用写返回值类型,连void都不用写 构造方法不能return一个具体的返回值 构造方法，类似于常规的方法，同样可以被public、protected、private这三个关键词修饰，但是构造方法不能有返回值。我们人为地将构造方法声明为private，这样其他的类就不能直接调用该类生成新的对象，也就避免了同一个类被反复创建的情况，这种情况，该类只有一个对象实例 如果没有编写任何构造方法,那么编译器将会默认赠送一个构造方法,没有参数,方法体什么都不做(空参构造方法) 一旦编写了至少一个构造方法,那么编译器将不再赠送 构造方法也可以重载(方法名相同,参数列表不同) 在继承关系中,父子类构造方法的访问特点:(子类必须调用父类构造,不写则赠送super(),写了则用写的指定的super调用,super只能有一个,还必须是第一个) 子类构造方法当中有一个默认隐含的”super()”调用,所以一定是先调用父类构造,后执行子类构造 子类构造可以通过super关键字来调用父类重载构造 super的父类构造调用,必须是子类构造方法的第一个语句,不能一个子类构造调用多次super构造 非静态方法和构造方法是随着对象绑定在一起的，只有创建了对象，才能调用非静态方法和构造方法。先执行静态方法，再是非静态方法，最后是构造方法。 重写 在继承关系中,方法的名称一样,参数列表也一样 创建的是子类对象,则优先使用子类方法 注意事项: 必须保证父子类之间方法的名称相同,参数列表也相同 @Override:写在方法的前面,用来检测该方法是不是一个正确的重写方法,但是不写该注解,并不影响重写 子类方法的返回值必须小于等于父类方法的返回值范围]]></content>
      <categories>
        <category>Java</category>
        <category>方法</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>方法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数组相关内容]]></title>
    <url>%2F2019%2F09%2F12%2F%E6%95%B0%E7%BB%84%E7%9B%B8%E5%85%B3%E5%86%85%E5%AE%B9%2F</url>
    <content type="text"><![CDATA[数组简单使用 数组可以用来存储多个类型一致的元素。（任意类型） 引用类型和基本类型变量创建的不同 基本类型变量声明出来不管是否赋值，都已经分配了内存。 引用变量类型的创建分为两步：声明和初始化 声明只在栈内分配内存（存储引用，或者说存储地址） 初始化在堆或者方法区分配内存（存储实际的数据） new出来的东西放在堆里面 程序运行常量放在方法区里面 关于栈 所有局部变量都存放在栈里面（在方法里面创建的变量都是局部变量，因为只在这个方法内有效） 一维数组的声明初始化和使用 声明 数组元素类型[] 数组名； 数组元素类型 数组名 []; 初始化 初始化的时间 可以在声明的时候直接初始化 也可以先声明后初始化 初始化的方法（初始化的时候必须确定数组的长度） String[] arr = new String[3];(动态初始化,指定长度) int [] arr = new int [] {2,1,6,4};(静态初始化,指定内容) int [] arr = {3 ,4 ,68,23,12};静态初始化,指定内容) 数据类型的默认值 整数类型（byte,short,int,long）的基本类型变量的默认值为0 单精度浮点型（float)的基本数据类型变量的默认值为0.0f 双精度浮点型（double)的基本类型变量的默认值为0.0d 字符型（char）的基本类型变量的默认值为“\u0000” 布尔型（boolean）的基本类型变量的默认值为false 引用类型的变量是默认值为null 数组引用类型的变量的默认值为null,除关键数组变量的实例后，如果没有显式的为每个元素赋值，Java就会把该数组的所有元素初始化为其相应类型的默认值。 使用 通过索引访问数组里面的成员，索引是从0开始， 访问方式：数组名[索引] //可以访问值，也可以设置值 获取数组长度 数组名：length 这里的length是属性，不是方法，不需要加括号 注意事项 下标超出范围 空引用 填充数组 Arrays.fill(数组名，值)； //使用指定的值填充指定的数组 二维数组的声明，初始化和使用 声明 声明第一种方式：数据类型[] [] 数组名 声明第二种方式：数据类型 数组名 [] [] 初始化 初始化第一种方式：数组名 = new 数据类型 [m] [n] 初始化第二种方式： 1数组名 = &#123;&#123;234，54，75&#125;，&#123;43，34，23&#125;，&#123;2，3，5&#125;&#125;; 可以把二维数组当作多个以为数组组成的一维数组，不如这里的就是一个长度为m的一维数组，这个数组里面每一个元素都是长度为n的一维数组。 + 初始化第三种方式：`数据类型 [] [] 数组名 = new 数据类型[] [];` m表示里面有多少个一维数组，但是没有给出这个一维数组的长度，这里的每一个一维数组的长度是可以不一样的。 使用 格式：数组名 [索引] [索引]; 通过数组名 [索引] ;得到的是一维数组，完全可以当作一维数组来使用]]></content>
      <categories>
        <category>Java</category>
        <category>数组</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[String相关内容]]></title>
    <url>%2F2019%2F09%2F10%2FString%E7%9B%B8%E5%85%B3%E5%86%85%E5%AE%B9%2F</url>
    <content type="text"><![CDATA[字符串基础 字符串常量： ​ 需要使用“ ”双引号包裹起来 ​ “ 12435” “asdhskdfgb” &quot;我爱你，中国&quot; ​ 一个字符串不能放在多行，如果要过表示换行可以在字符串中间添加\n,来表示换行 字符串变量： String str =“asdfa”; String str = new String(&quot;dfasdg&quot;); String str = new String(byteArray); String str = new String(charArray); 字符串的特点: 字符串的内容永不可变,所以字符串是可以共享使用的 正因为字符串不可以改变,所以字符串是可以共享使用的 字符串效果上相当于是一个char[]字符数组,但是底层原理是byte[]字节数组 new出来的字符串直接在堆当中,直接赋值的字符串在堆中的字符串常量池中 字符串连接（+）： 多个字符串连接 public String concat(String str)将当前字符串和参数字符串拼接为一个新的字符串并返回 和其他数据连接 通过+可以直接对字符串（或者其他数据类型）常量和变量做连接操作 字符串的特性： 字符串无法被修改 字符串的值无法被修改，但是字符串对象可以引用别的字符串。 字符串信息获取： 长度：s.length(); 查找子字符串的位置： s.indexOf(int c); s.indexOf(String str); s.lastIndexOf(String str); 获取指定位置的字符：s.charAt(int index); 获取子字符串：(如不给定beginIndex则默认从0开始，到endIndex的前一个字符) s.subString(int beginIndex); s.subString(int beginIndex,int endIndex); 字符串判断； 判断字符串的开始和结尾： s.startsWith(Stirng prefix); s.endsWith(String suffix); 判断字符串是否相等： == s.equals(String str); s.equalsIgnoreCase(String str); s.compareTo(String str); compareTo比较的不是字符串是否相等，这里比较的是字符串的大小，字符串的大小怎么比较呢？按各个字符比较相同的字符跳过，遇到不同的字符，返回字符的差(Ascll码值 )，如果两个字符串，前面的几个字符相等，长度不相等（“”siki”,”sikiedu”）返回两个字符串的长度差。（常用于排序） 判断是否包含某个字符串，包含返回true s.contains(String str); 判断字符串是否为空 s.isEmpty(); 空的两种状态： String s = &quot;&quot;;空字符串 String s = null;空对象 字符串转换操作： 字母大小写转换 s.toLowerCase(); s.toUpperCase(); 字符串分割(返回的是一个字符串数组,limit可以控制字符串数组中的元素个数) s.split(String str); s.split(String str,int limit); 去除空格（前面和后面的空格，不包括中间的空格） s.trim() 字符串替换 s.replace(char oldChar,char new Char); s.replace(String oldStr,String newStr); 字符串格式化(日期和时间的格式化) 在 Java中要将 String 类型转化为 int 类型时,需要使用 Integer 类中的 parseInt() 方法或者 valueOf() 方法进行转换 将一个字符串翻转： 通过String类的charAt()的方法来获取字符串中的每一个字符，然后将其拼接为一个新的字符串。 1234567public static String CharAtreverse(String s) &#123; int length = s.length(); String reverse = ""; for (int i=0; i&lt;length; i++) reverse = s.charAt(i) + reverse; return reverse; &#125; 通过String的toCharArray()方法可以获得字符串中的每一个字符串并转换为字符数组，然后用一个空的字符串从后向前一个个的拼接成新的字符串。 123456789public static String reverseCharArray(String s) &#123; char[] array = s.toCharArray(); String reverse = ""; for (int i = array.length - 1; i &gt;= 0; i--) &#123; reverse += array[i]; &#125; return reverse; &#125; 通过StringBuilder的reverse()方法，最快的方式 12345public static String reverseStringBuilder(String s) &#123; StringBuilder sb = new StringBuilder(s); String afterreverse = sb.reverse().toString()； return afterreverse; &#125; String和StringBuilder和StringBuffer1、在字符串不经常发生变化的业务场景优先使用String(代码更清晰简洁)。如常量的声明，少量的字符串操作(拼接，删除等)。 2、在单线程情况下，如有大量的字符串操作情况，应该使用StringBuilder来操作字符串。不能使用String”+”来拼接而是使用，避免产生大量无用的中间对象，耗费空间且执行效率低下（新建对象、回收对象花费大量时间）。如JSON的封装等。 3、在多线程情况下，如有大量的字符串操作情况，应该使用StringBuffer。如HTTP参数解析和封装等。]]></content>
      <categories>
        <category>Java</category>
        <category>String</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot的相关配置]]></title>
    <url>%2F2019%2F09%2F09%2FSpringBoot%E7%9A%84%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[SpringBoot简介 SpringBoot是Spring家族中一个全新的框架,它用来简化Spring应用程序的创建和开发过程,也可以说SpringBoot能简化我们之前采用的SpringMVC+Spring+Mybatis应用程序的开发过程 在以往我们采用SpringMVC+Spring+MyBatis框架进行开发的时候,搭建和整合三大框架,我们需要做很多事情,比如配置web.xml,配置Spring,配置MyBaits,并将它们整合在一起,而SpringBoot框架对此过程进行了革命性的颠覆,抛弃了繁琐的xml配置过程,采用大量的默认配置简化我们的开发过程 所以采用SpringBoot可以非常容易和快速的创建基于Spring框架的应用程序,它可以让编码变简单了,配置变简单了,部署变简单了,监控变简单了 正因为SpringBoot它化繁为简,让开发变得极其简单和快速,所以在业界内备受关注 SpringBoot的特性 能够快速创建基于Spring的应用程序 能够直接使用java main方法启动内嵌的 tomcat,Jetty服务器运行SpringBoot程序,不需要部署war包文件, 提供约定的starterPOM来简化Maven配置,让Maven配置变得简单 根据项目的Maven依赖配置,SpringBoot自动配置Spring,SpringMVC等 提供了程序的健康检查功能; 基本可以完全不使用xml配置文件,采用注解配置 SpringBoot的四大核心 自动配置:针对很多Spring应用程序和常见的应用功能,SpringBoot能自动提供相关配置 起步依赖:告诉SpringBoot需要什么功能,他就能引入需要的依赖库 Actuator:让你能够深入运行中的SpringBoot应用程序,一探SpringBoot程序的内部信息 命令行界面:这是SpringBoot的可选特性,主要针对Groovy语言使用 第一个SpringBoot程序 创建一个SpringBoot项目 加入SpringBoot的入口main方法 创建一个SpringMVC的Controller 运行SpringBoot的入口main方法 SpringBoot整合MyBatis 添加Mybatis的起步依赖 添加数据库驱动坐标 添加数据库连接信息 创建user表 创建实体Bean 编写Mapper(Dao接口) 配置Mapper映射文件 在application.properties中添加Mybatis的信息 编写测试Controller]]></content>
      <categories>
        <category>Java</category>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringMVC的相关配置]]></title>
    <url>%2F2019%2F09%2F02%2FSpringMVC%E7%9A%84%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[SpringMVC入门程序步骤: 启动服务器,加载一些配置文件 DispatcherServlet对象创建 springmvc.xml被加载了 HelloController被创建成对象 视图解析器被创建成对象 发送请求,后台处理请求 运行程序,点击首页的超链接 超链接根据web.xml中的DispatcherServlet这个控制中心找到相应的注解@RequestMapping下的方法,执行该方法 控制中心重新寻找对象,根据视图解析器和前一个方法的返回值,寻找到下一步跳到哪儿,将结果显示给客户端(success.jsp展示给客户端) @RequestMapping value:用于指定请求的URl和path属性的作用是一致的,value=”/haha” method:用于指定请求的方式,method={RequestMethod.POST} params:用于指定限制请求参数的条件,它支持简单的表达式,要求请求参数的key和value必须和配置的一模一样 params = {“accountName”},表示请求参数必须有accountName params={“money!100”},表示请求参数中money不能是100 headers:用于指定限制请求消息头的条件,headers={“Accept”} 请求参数的绑定 请求参数的绑定说明 绑定机制 表单提交的数据都是k=v 的格式, username=haha&amp;&amp;passsword=123 SpringMVC的参数绑定过程是把表单提交的请求参数,作为控制器中方法的参数进行绑定的 要求:提交表单的name和参数的名称要一致 @RequestParam: 定义参数名称,在请求参数的名称和函数方法名称不一样时使用 @RequestBody:添加在函数参数上,将请求体的内容封装到参数中,形式为key=value&amp;key=value的形式 @PathVaribale:拥有绑定url中的占位符,例如:url中有/delete/{id},{id}就是占位符,将这个注解加到方法的参数上就可以获取url中占位符的值 @RequestHeader:用于获取请求头信息,value属性:提供消息头名称,required:是否必须有此消息头 @CookieValue:用于把指定Cookie名称的值传入控制器方法参数,value:指定cookie的名称,required:是否必须有此cookie,将这个注解加到方法的参数上就可以获取名称为value的cookie值 @ModuleAttribute:此注解可以用于修饰方法和参数,出现在方法上,表示当前方法会在控制器的方法执行之前执行,出现在参数上,获取指定的数据给参数赋值 @SessionAttribute:用于多次执行控制器方法间的参数共享,value:用于指定存入的属性名称,type:用于指定存入的输入的数据类型 响应数据和结果视图 响应之结果返回值: String Void ModelAndView 转发(forward)和重定向(redirect) 1234567891011@RequestMapping("/testForwardOrRedirect") public String testForwardOrRedirect() &#123; System.out.println("testForwardOrRedirect执行了..."); //请求的转发 //return "forward:/WEB-INF/pages/success.jsp";//视图解析器根据返回的名称寻找相应的jsp页面进行跳转 //重定向 return "redirect:/index.jsp"; &#125; 发送ajax请求 1234567891011@RequestMapping("/testAjax") public @ResponseBody User testAjax(@RequestBody User user) &#123; System.out.println("testAjax执行了..."); //客户端发送ajax的请求,传的是字符串,后端把json字符串封装到user对象中 System.out.println(user); //做响应,模拟查询数据库 user.setUsername("haha"); user.setAge(40); //做响应 return user; &#125; 解析json数据 12345678910111213141516171819202122232425&lt;script&gt; //页面加载,绑定单击事件 $(function () &#123; $("#btn").click(function () &#123; //alert("hello,btn!") //发送ajax请求 $.ajax(&#123; //编写json格式,设置属性和值 url: "user/testAjax", contentType: "application/json;charset=UTF-8", data: '&#123;"username":"hehe","password":"123","age":"30"&#125;', dateType: "json", type: "post", success:function (data) &#123; //data服务器端相应的json的数据,进行解析 alert(data); alert(data.username) alert(data.password); alert(data.age); &#125; &#125;) &#125;); &#125;); &lt;/script&gt; 异常处理 异常处理的思路: Controller调用service,service调用dao,异常都是向上抛出的,最终由DispatcherServlet找异常处理器进行异常的处理]]></content>
      <categories>
        <category>Java</category>
        <category>SpringMVC</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JSP相关内容]]></title>
    <url>%2F2019%2F07%2F29%2FJSP%2F</url>
    <content type="text"><![CDATA[JSP:1. 概念: Java Server Pages:java服务器端页面 可以理解为一个特殊的页面,其中既可以指定定义html,又可以定义java代码 用于简化书写 JSP本质上就是一个Servlet JSP的脚本:JSP定义Java代码的方式 &lt;% 代码 %&gt;:定义的Java代码,在service方法中.service方法中可以定义什么,该脚本就可以定义什么 &lt;%! 代码 %&gt;:定义的Java代码,在JSP转换后的Java类的成员位置 &lt;%= 代码 %&gt;:定义的Java代码在service方法中,会输出到页面上,输出语句中可以定义什么,该脚本中就可以定义什么 JSP的内置对象: 在JSP页面中不需要获取和创建的,可以直接使用的对象 JSP一共有9个内置对象 request response out:字符输出流.可以将数据输出到页面上,和response.getWriter()类似 response.getWriter()和out.write()的区别: 在tomcat服务器真正给客户端做出相应之前,会先找response缓冲区数据再找out缓冲区数据 response.getWriter()数据输出永远在out.write()之前 2.指令: 作用:用于配置JSP页面,导入资源文件 格式: &lt;%@ 指令名称 属性名1=属性值1 属性名2=属性值2 …%&gt; 分类: page:配置JSP页面的 contentType:等同于response.setContentType() 设置响应体的mime类型和字符集 设置当前jsp页面的编码(只能是高级的IDE才能生效,如果使用低级工具,则需要设置pageEncoding属性设置当前页面的字符集) language:支持的语言,目前只支持java buffer:缓冲区大小,默认8kb(out对象有缓冲区) import:导包 errorPage::当前页面发生异常后,会自动跳转到指定的错误页面 isErrorPage:标识当前页面是否是错误页面 true:是,可以使用内置对象exception(可用于输出错误信息) false:否,默认值,不可以使用内置对象exception include:页面包含的.导入页面的资源文件(当多个页面有重复内容时,可以提取出相同部分,在其他页面中导入,来简化书写) taglib:导入资源库 &lt;%@ taglib prefix=”c” url=”http://java.sun.com/jsp/jstl/core&quot; %&gt; prefix:前缀,自定义的,如:在使用导入的标签时,使用&lt;c: 3.注释: html注释: &lt;!-- --&gt;:只能注释html代码片段 JSP注释:(推荐使用) &lt;%-- --%&gt;:可以注释所有 4.内置对象​ 变量名 :真实类型 : 作用 pageContext : PageContext : 当前页面共享数据 ,还可以获取其他8个内置对象 request : HttpServletRequest : 一次请求访问的多个资源(转发) session : HttpSession : 一次会话的多次请求间 application : ServletContext : 所有的用户间共享数据 rseponse : HttpServletResponse : 响应对象 page : Object : 当前页面(Servlet)的对象, this out : JspWriter : 输出对象,数据输出到页面上 config : ServletConfig : Servlet的配置对象 exception : Throwable : 异常对象 MVC: M:Model ,模型, JavaBean 完成具体的业务操作,如:查询数据库,封装对象 V:View,视图,JSP 展示数据 C:Controller,控制器,Servlet 获取用户的输入 调用模型 将数据交给视图进行展示 EL表达式: 概念:Expresssion language 表达式语言 作用:替换和简化JSP页面中Java代码的缩写 语法:${表达式} 注意: JSP默认是支持el表达式的,如果要忽略el表达式 设置jsp中的page指令中的 :ELIgnored=”true” 忽略当前页面中所有的el表达式 \${} :忽略当前这个el表达式 使用: 运算: 运算符: 算数运算符:+ - * /(div) %(mod) 比较运算符:&gt; &lt; &gt;= &lt;= == != 逻辑运算符: &amp;&amp;(and) ||(or) !(not) 空运算符:empty 功能: 用于判断字符串,集合,数组对象是否为null,或者长度是否为0 ${empty list}:判断字符串,集合,数组,对象是否为null,或者长度是否为0 ${not empty list}:表示判断字符串,集合,数组是否不为null,并且长度&gt;0 获取值: el表达式只能从域对象中获取值 语法: ${域名称.键名} :从指定域中获取值 域名称: pageScope —&gt; pageContext requestScope —&gt; request sessionScope —&gt; session applicationScope —&gt; application 举例:在request域中存储了name :张三 获取:${requestScope.name} ${域名}:表示依次从最小的域中查找是否有该键对应的值,直到找到为止 获取对象,List集合,Map集合的值 对象:${域名称.键名.属性名} 本质上会去调用对象的getter方法 List集合:${域名称.键名.[索引]},索引越界会显示空字符串(什么都不显示,不会报错) Map集合: ${域名称.键名.Key名称} ${域名称.键名[“Key名称”]} 隐式对象: el表达式中有11个隐式对象 pageContext: 获取jsp其他八个内置对象 ${pageContext.request.contextPath}:动态获取虚拟目录 JSTL: 概念:JavaServer Pages Tag Library :JSP标准标签库 是由Apache组织提供的开源的免费的jsp标签 作用:用于简化和替换jsp页面上的Java代码 使用步骤: 导入jstl相关的jar包 引入标签库: taglib指令: &lt;%@ taglib %&gt; 使用标签库 常用的JSTL标签 if :c:if标签没有else情况,想要else情况,则可以在定义一个c:if标签 c: if标签 1.属性, 必须属性:test 接收boolean表达式 如果表达式为true,则显示if标签体内容,如果为false,则不显示标签体内容 一般情况下,test属性值会结合el表达式一起使用 choose : 相当于java代码中的switch语句 使用choose标签取出数字 //相当于switch声明 使用when标签做数字判断 //相当于 case otherwise标签做其他情况的声明 //相当于default foreach:相当于java代码中的for语句 练习: 需求:在request域中有一个存有User对象的List集合,需要使用jstl标签将list集合数据展示到jsp页面的表格table中 三层架构:软件设计架构: 界面层(表示层):用户看的界面,用户可以通过界面上的组件和服务器进行交互 业务逻辑层:处理业务逻辑的 数据访问层:操作数据存储文件]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JavaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cookie和Session]]></title>
    <url>%2F2019%2F07%2F28%2FCookie%E5%92%8CSession%2F</url>
    <content type="text"><![CDATA[会话技术 会话：一次会话中包含多次请求和响应 一次会话：浏览器第一次给服务器资源发送请求，会话建立，直到有一方断开为止 功能：在一次会话的范围内的多次请求间，共享数据 方式： 客户端会话技术(数据存在客户端):Cookie 服务器端会话技术(数据存在服务器端)：Session Cookie 概念:客户端会话技术,将数据保存到客户端 快速入门: 创建Cookie对象,绑定数据 new Cookie(String name,String value) 服务器发送Cookie对象给浏览器 response.addCookie(Cookie cookie) 浏览器再次请求服务器时,服务器从request中获取Cookie,拿到数据 Cookie[] request.getCookies() 实现原理: 基于响应头set-cookie和请求头cookie实现 cookie的细节 一次可不可以发送多个cookie? 可以 可以创建多个cookie对象,使用response调用多次addCookie方法发送cookie即可 cookie在浏览器中保存多长时间? 默认情况下,当浏览器关闭后,Cookie数据被销毁 持久化存储: setMaxAge(int seconds) 正数:将Cookie数据写到硬盘的文件中.持久化存储.cookie存活时间 负数:默认值,存在浏览器中,浏览器关闭,信息销毁 零:删除cookie信息 cookie能不能存中文? 在tomcat 8 之前,Cookie不能直接存储中文数据 需要将中文数据转码—-一般采用URL编码(%E3) 在tomcat 8 之后,Cookie支持中文数据.特殊字符还是不支持,建议使用URL编码存储,URL解码解析 Cookie获取范围有多大? 假设在一个tomcat服务器中,部署了多个web项目,那么在这些web项目中Cookie能不能共享? 默认情况下Cookie不能共享+ setPath(String path):设置Cookie的获取范围.默认情况下,设置当前的虚拟目录 + 如果要共享,可以将path设置为&quot;/&quot; 不同的tomcat服务器间Cookie数据的共享? setDomain(String path):如果设置一级域名相同, 那么多个服务前间的Cookie可以共享 setDomain(“.baidu.com”),那么tieba.baidu.com和news.baidu.com中的Cookie可以共享 Cookie的特点和作用 特点: Cookie存储数据在客户端浏览器 浏览器对于单个Cookie的大小有限制(4kb),以及对同一个域名下的总的Cookie数量也有限制(20个) 作用: Cookie一般用于存储少量的不太敏感的数据 在不登录的情况下,完成服务器对客户端的身份识别 案例:记住上一次访问时间 需求: 访问一个Servlet,如果是第一次访问,则提示:您好,欢迎您首次访问 如果不是第一次访问,则提示:欢迎回来,您上次访问时间为:显示时间字符串 Session 概念:服务器端会话技术,在一次会话的多次请求间共享数据,将数据保存在服务器端的对象中.HttpSession 快速入门: 获取HttpSession对象: HttpSession session = request.getSession(); 使用HttpSession对象: Object getAttribute(String name) void setAttribute(String name, Object value) void removeAttribute(String name) 实现原理: Session的实现是依赖与Cookie的 Session细节: 当客户端关闭后,服务器不关闭,两次获取的Session是否为同一个? 默认不是,因为一次对话已经结束,Session已经关闭 因为是基于Cookie实现的,所以可以采用手动定义一个JSESSIONID的Cookie,值设为session对象的id,,然后可以通过Cookie的setMaxAge(时间秒)来设置Session的存活时间 客户端不关闭,服务器关闭后两次获取的Session是同一个吗? 不是同一个,但是要确保数据不丢失 Session的钝化: 在服务器正常关闭之前,将Session对象系列化到键盘上 Session的活化: 在服务器启动后,将Session文件转换为内存中的Session对象即可 Session的失效时间,什么时候被销毁? 服务器关闭 Session对象调用invalidate()方法 Session默认失效时间为30分钟 可以选择性的修改配置在web.xml中 &lt;session-config&gt; &lt;session-timeout&gt;30&lt;sesion-timeout&gt; &lt;session-config&gt; Session的特点 Session用于存储一次对话的多次请求的数据,存在服务器端 Session可以存储任意类型,任意大小的数据 Session和Cookie的区别: Session存储数据在服务器端,Cookie在客户端 Session没有数据大小限制,Cookie 有 Session数据安全,Cookie相对不安全 案例:验证码 案例需求: 访问带有验证码的登录页面login.jsp 用户输入用户名,密码,以及验证码 如果用户名和密码输入有误,跳转到登录页面显示用户名或者密码错误 如果验证码输入有误,跳转到登录页面,提示:验证码错误 如果全部输入正确,则跳转到seccess.jsp页面,显示:用户名,欢迎您]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JavaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[反射相关内容]]></title>
    <url>%2F2019%2F07%2F07%2F%E5%8F%8D%E5%B0%84%2F</url>
    <content type="text"><![CDATA[Java反射反射:框架设计的灵魂 框架:半成品软件.可以在框架的基础上进行软件开发,简化编码 反射:将类的各个组成部分封装为其他对象,这就是反射机制，JAVA语言编译之后会生成一个.class文件，反射就是通过字节码文件找到某一个类、类中的方法以及属性等。 好处 可以在程序运行过程中,操作这些对象 可以解耦合,提过程序的可扩展性 获取Class对象的三种方式 Object ——&gt; getClass(); 多用于对象的获取字节码的方式 任何数据类型（包括基本数据类型）都有一个“静态”的class属性 多用于参数的传递 通过Class类的静态方法：forName（String className）(常用) 对用于配置文件,将类名定义在配置文件中,读取文件,加载类. 结论: 同一个字节码文件(*.class)在一次程序运行过程中,只会被加载一次,不论通过哪一种方式获取的class对象都是同一个. class类对象功能 获取功能: 获取成员变量们 Fileld[] getFields() :获取所有public修饰的成员变量的 Fileld getField(String name) :获取特定名称的public修饰成员变量 Field[] getDeclaredFields() :获取所有的成员变量 Field getDeclaredField(String name):获取特定名称的成员变量 获取构造方法们 Constructor&lt;?&gt;[] getConstructors() Constructor getConstrucotr(Class&lt;?&gt;…parameterTypes) Constructor getDeclaredConstructor(Class&lt;?&gt;… parameterTypes) Constructor&lt;?&gt;[] getDeclaredConstructors() 获取成员方法们: Method[] getMethods() Method getMethod(String name,Class&lt;?&gt;…parameterTypes) Method[] getDeclaredMethods() Method getDeclaredMethod(String name,Class&lt;?&gt;… parameterTypes) 获取类名: String getName() Filed: 成员变量 操作 设置值 void set(Object obj,Object value) 获取值 get(Object obj) 用于忽略访问权限修饰符的安全检查. setAccsessible(true) //暴力反射 Constructor:构造方法 创建对象: T newInstance(Object…initargs) 如果使用空参构造方法创建对象,操作可以简化:Class对象的newInstance方法 Method:方法对象 执行方法: Object invoke(Object obj, Object… args) 获取方法名称: String getName:获取方法名]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>反射</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Junit测试]]></title>
    <url>%2F2019%2F07%2F07%2FJunit%E6%B5%8B%E8%AF%95%2F</url>
    <content type="text"><![CDATA[Junit测试Junit单元测试: 测试分类: 黑盒测试:不需要写代码,给输入值,看程序是否能够输出预期的值 白盒测试:需要编写代码,关注程序具体的执行流程 Junit使用:白盒测试 步骤 定义一个测试类(测试用例) 建议: 测试类名:被测试的类名Test CalculatorTest 包名:xxx.xxx.xx.test cn.itcast.test 定义测试方法:可以独立运行 建议: 方法名:test测试的方法名 testAdd() 返回值:void 参数列表:空参 给方法加上@Test注解 导入Junit依赖环境 判定结果: 红色:失败 绿色:成功 一般我们会使用断言操作来处理结果 Assert.assertEquals(期望的结果,运算的结果); 补充: @Before: 修饰的方法会在测试方法之前被自动执行 @After: 修饰的方法会在测试方法执行之后被自动执行]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>测试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git命令]]></title>
    <url>%2F2019%2F05%2F14%2Fgit%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[git常用操作：git init:使用 git init 在目录中创建新的 Git 仓库。 你可以在任何时候、任何目录中这么做，完全是本地化的。 git clone: 使用 git clone 拷贝一个 Git 仓库到本地，让自己能够查看该项目，或者进行修改。 git add:使用git add 命令可将该文件添加到缓存。新项目中，添加所有文件很普遍，我们可以使用 git add . 命令来添加当前项目的所有文件。 git status: 使用git status 命令用于查看项目的当前状态。 git diff: 执行 git diff 来查看执行 git status 的结果的详细信息。 git commit:使用 git add 命令将想要快照的内容写入缓存区， 而执行 git commit 将缓存区内容添加到仓库中 git reset HEDA:git reset HEAD 命令用于取消已缓存的内容。执行 git reset HEAD 以取消之前 git add 添加，但不希望包含在下一提交快照中的缓存。 git rm:如果只是简单地从工作目录中手工删除文件，运行 git status 时就会在 Changes not staged for commit 的提示。要从 Git 中移除某个文件，就必须要从已跟踪文件清单中移除，然后提交。git rm 如果删除之前修改过并且已经放到暂存区域的话，则必须要用强制删除选项 -f 即：git rm -f 如果把文件从暂存区域移除，但仍然希望保留在当前工作目录中，换句话说，仅是从跟踪清单中删除，使用 –cached 选项即可 即：git rm –cached git mv:git mv 命令用于移动或重命名一个文件、目录、软连接。 git diff执行 git diff 来查看执行 git status 的结果的详细信息。 git diff 命令显示已写入缓存与已修改但尚未写入缓存的改动的区别。git diff 有两个主要的应用场景。 尚未缓存的改动：git diff 查看已缓存的改动： git diff –cached 查看已缓存的与未缓存的所有改动：git diff HEAD 显示摘要而非整个 diff：git diff –stat Git分支管理:乎每一种版本控制系统都以某种形式支持分支。使用分支意味着你可以从开发主线上分离开来，然后在不影响主线的同时继续工作。 有人把 Git 的分支模型称为必杀技特性，而正是因为它，将 Git 从版本控制系统家族里区分出来。 创建分支命令: git branch (branchname) 切换分支命令:git checkout (branchname) 你切换分支的时候，Git 会用该分支的最后提交的快照替换你的工作目录的内容， 所以多个分支不需要多个目录。 我们也可以使用 git checkout -b (branchname) 命令来创建新分支并立即切换到该分支下，从而在该分支中操作。 合并分支命令: git merge 你可以多次合并到统一分支， 也可以选择在合并之后直接删除被并入的分支 列出分支命令:git branch 删除分支命令:git branch -d (branchname) 分支合并命令:git merge (branchname) 一旦某分支有了独立内容，你终究会希望将它合并回到你的主分支。 你可以使用git merge命令branchname分支合并到当前分支中去 Git远程仓库:git remote:添加远程仓库,git remote add [shortname] [url] 由于你的本地 Git 仓库和 GitHub 仓库之间的传输是通过SSH加密的，所以我们需要配置验证信息： 使用以下命令生成 SSH Key： ssh-keygen -t rsa -C “email@xx.XXX“ git remote:查看当前的远程库 执行时加上 -v 参数，你还可以看到每个别名的实际链接地址。 git fetch:提取远程仓库,从远程仓库下载分支与数据git fetch origin git merge:从远程仓库提取数据并尝试合并到当前分支git merge origin/master git push:推送你的新分支与数据到某个远端仓库命令:,git push [alias] [branch] git push &lt;远程主机名&gt; &lt;本地分支名&gt; &lt;远程分支名&gt; 如果远程分支被省略，则表示将本地分支推送到与之存在追踪关系的远程分支（通常两者同名），如果该远程分支不存在，则会被新建 如果省略本地分支名，则表示删除指定的远程分支，因为这等同于推送一个空的本地分支到远程分支，等同于 git push origin –delete master 如果当前分支与远程分支存在追踪关系，则本地分支和远程分支都可以省略，将当前分支推送到origin主机的对应分支 git push -u origin master 如果当前分支与多个主机存在追踪关系，则可以使用 -u 参数指定一个默认主机，这样后面就可以不加任何参数使用git push，不带任何参数的git push，默认只推送当前分支，这叫做simple方式 git remote rm [别名]:删除远程仓库 git pull 获取并合并其他的厂库，或者本地的其他分支。git pull &lt;远程主机&gt; &lt;远程分支&gt;:&lt;本地分支&gt; 文件夹上传到github库：git init //把这个目录变成Git可以管理的仓库 git add README.md //文件添加到仓库 git add . //不但可以跟单一文件，还可以跟通配符，更可以跟目录。一个点就把当前目录下所有未追踪的文件全部add了 git commit -m “first commit” //把文件提交到仓库 git remote add origin git@github.com:yourname/youremail.git //关联远程仓库 git pull –rebase origin master //代码合并 git push -u origin master //把本地库的所有内容推送到远程库上]]></content>
      <tags>
        <tag>git</tag>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring的相关配置]]></title>
    <url>%2F2019%2F04%2F29%2FSpring%E7%9A%84%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[基本概念 IOC:(Inverse of Control)控制反转 将对象的创建权反转(交给)Spring DI:(Dependency Injection)依赖注入 前提必须得有IOC的环境,Spring管理这个类的时候将类的依赖的属性注入(设置)进来 AOP:(Aspect Oriented Programming)面向切面编程 通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。 AOP是OOP(面相对象编程)的扩展和延伸,解决AOP开发中遇到的一些问题. XML提示的配置​ Scheme的配置 Bean的相关配置(XML) 标签的id和name的配置 大部分情况下作用相同 id :使用了约束中的唯一约束.里面不能出现特殊字符 name: 没有使用约束中的唯一约束(理论上可以出现重复的,但是实际开发不能出现的),name里面可以出现特殊字符 Bean的生命周期的配置 init-method :Bean被初始化的时候执行的方法 destroy :Bean被销毁的时候执行的方法 执行条件（1.Bean是单例创建的（默认就是单例创建的） 2.工厂关闭） 如果是多例模式下不知道销毁哪个所以就不会销毁。 Bean的作用范围的配置 scope :Bean的作用范围 singleton :默认的，Spring会采用单例模式来创建这个对象(在创建容器读取配置文件的时候立即创建对象,立即加载) prototype :多例模式(当真正调用对象的时候再创建对象,延迟加载,因为不知道创建多少个对象) request :应用在web项目中，Spring创建这个类以后，将这个类存入到request范围中。 session :应用在web项目中，Spring创建这个类以后，将这个类存入到session范围中。 globalsession:应用在web项目中，作用于集群环境下的会话范围,必须在porlet(集群)环境下使用，如果没有这种环境，相当于session。 开发中常用的就是singleton和prototype Spring的属性注入（给Bean中的属性设置值）的方式 构造方法的方式属性注入: 123456 &lt;!-- Spring属性注入的方式 --&gt; &lt;!-- 构造方法的方式 --&gt; &lt;bean id="car" class="spring.demo3.Car"&gt; &lt;constructor-arg name="name" value="宝马"/&gt; &lt;constructor-arg name="price" value="800000"/&gt;&lt;/bean&gt; Set方法的方式的属性注入: 12345&lt;!-- set方法的方式 --&gt; &lt;bean id="car2" class="spring.demo3.Car2"&gt; &lt;property name="name" value="奔驰"/&gt; &lt;property name="price" value="1000000"/&gt; &lt;/bean&gt; 123456&lt;!-- set方法注入对象类型的属性 --&gt; &lt;bean id="employee" class="spring.demo3.Employee"&gt; &lt;property name="name" value="涛哥"/&gt; &lt;!-- value:设置普通属性类型的值 ref:用来设置其他类的id和name --&gt; &lt;property name="car2" ref="car2"/&gt; &lt;/bean&gt; P名称空间的属性注入(Spring2.0以后) 通过引入p名称空间完成属性的注入 写法: 普通属性: p:属性名=”值” 对象属性: p:属性名-ref=”值” 引入p名称空间 1xmlns:p="http://www.springframework.org/schema/p" 1234 &lt;!-- 改为p名称空间的方式 --&gt; &lt;bean id="car2" class="spring.demo3.Car2" p:name="奇瑞qq" p:price="30000"&gt;&lt;/bean&gt;&lt;!-- p名称空间的方式来注入对象类型 --&gt; &lt;bean id="employee" class="spring.demo3.Employee" p:name="王东" p:car2-ref="car2"&gt;&lt;/bean&gt; SpEL的属性注入(Spring3.0以后) SpEL(Spring Expression Language) :Spring的表达式语言 语法: #{SpEL} 1234567891011121314 &lt;!-- SpEL方式属性注入 --&gt;&lt;bean id="carInfo" class="spring.demo3.CarInfo"&gt;&lt;/bean&gt;&lt;bean id="car2" class="spring.demo3.Car2"&gt; &lt;property name="name" value="#&#123;carInfo.name&#125;"&gt;&lt;/property&gt; &lt;property name="price" value="#&#123;carInfo.calculatorPrice()&#125;"&gt;&lt;/property&gt;&lt;/bean&gt; &lt;bean id="employee" class="spring.demo3.Employee"&gt; &lt;property name="name" value="#&#123;'张三'&#125;"&gt;&lt;/property&gt; &lt;property name="car2" value="#&#123;car2&#125;"&gt;&lt;/property&gt;&lt;/bean&gt; 集合类型属性的注入 数组类型,list类型,set类型,map类型 12345678910111213141516171819202122232425262728293031323334353637383940414243 &lt;!-- Spring的集合属性的注入 --&gt; &lt;bean id="collectionBean" class="spring.demo4.CollectionBean"&gt; &lt;!-- 注入数组类型 --&gt; &lt;property name="arrs" &gt; &lt;list&gt; &lt;!-- &lt;ref/&gt; 引入对象类型 --&gt; &lt;value&gt;王东&lt;/value&gt; &lt;!-- 引入一般类型 --&gt; &lt;value&gt;赵红&lt;/value&gt; &lt;value&gt;李冠希&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;!-- 注入List集合类型 --&gt; &lt;property name="list" &gt; &lt;list&gt; &lt;!-- &lt;ref/&gt; 引入对象类型 --&gt; &lt;value&gt;小明&lt;/value&gt; &lt;!-- 引入一般类型 --&gt; &lt;value&gt;小红&lt;/value&gt; &lt;value&gt;小狗&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;!-- 注入Set集合类型--&gt; &lt;property name="set" &gt; &lt;set&gt; &lt;!-- &lt;ref/&gt; 引入对象类型 --&gt; &lt;value&gt;aaa&lt;/value&gt; &lt;!-- 引入一般类型 --&gt; &lt;value&gt;bbb&lt;/value&gt; &lt;value&gt;ccc&lt;/value&gt; &lt;/set&gt; &lt;/property&gt; &lt;!-- 注入Map集合 --&gt; &lt;property name="map"&gt; &lt;map&gt; &lt;entry key="aaa" value="111"/&gt; &lt;entry key="bbb" value="222"/&gt; &lt;entry key="ccc" value="333"/&gt; &lt;/map&gt; &lt;/property&gt; &lt;/bean&gt; Spring分模块开发的配置 在加载配置文件的时候,加载多个 1ApplicationContext applicationContext = new ClassPathXmlApplicationContext("applicationContext.xml","applicationContext2.xml"); 在一个配置文件中引入多个配置文件 12&lt;!-- 引入多个配置文件 --&gt; &lt;import resource="applicationContext2.xml"/&gt; Spring 的IOC的注解的详解(注解)12&lt;!-- 使用IOC的注解开发，配置组件扫描(要在哪些包下的类使用IOC的注解) --&gt; &lt;context:component-scan base-package="spring"&gt;&lt;/context:component-scan&gt; @Component:组件 修饰一个类，将这个类交给Spring管理相当于 &lt;bean id=&quot;orderDao&quot; class=&quot;spring.demo1.OrderDao&quot;&gt;&lt;/bean&gt; 这个注解有三个衍生注解（功能类似），修饰类 Controller: web层 Service: servcice层 Repository: dao层 属性注入的注解 普通属性： @Value:设置普通属性的值 对象类型属性： @Autowired:设置对象类型的属性的值,但是是按照类型完成属性的注入. 我们习惯是按照名称完成属性的注入,必须让@AutoWired和@Qualifier(value=”id”)一起使用完成按照名称属性注入. @Resource(name=”id”):完成对象类型的属性的注入,按照名称完成属性注入. Bean的其他的注解 生命周期相关的注解 @PostConstruct:初始化方法 @PreDestory: 销毁方法 Bean作用范围的注解 @Scope singleton :默认的，Spring会采用单例模式来创建这个对象 prototype :多例模式 request :应用在web项目中，Spring创建这个类以后，将这个类存入到request范围中。 session :应用在web项目中，Spring创建这个类以后，将这个类存入到session范围中。 globalsession:应用在web项目中，必须在porlet环境下使用，如果没有这种环境，相当于session。 开发中常用的就是singleton和prototype XML模式和注解模式的比较 使用场景 XML:可以适用于任何场景,结构清晰,维护方便 注解:如果这个类不是我们提供的,那么无法使用注解,开发方便 整合开发 XML管理Bean,注解完成属性注入 Spring 的AOP的开发(XML) Spring的AOP的简介 AOP思想最早是由AOP联盟组织提出的,Spring是使用这种框架最好的组织.Spring的AOP自己的实现方式非常繁琐,AspectJ是一个AOP的框架,后来Spring引入AspectJ作为自身AOP的开发. Spring两套AOP开发的方式 Spring传统方式(弃用) Spring基于ASpectJ的AOP的开发(使用) Spring底层的AOP实现原理 动态代理： JDK的动态代理 只能对实现了接口的类产生代理(自动的) Cglib的动态代理 对没有实现接口的类产生代理对象,产生子类对象 AOP开发中相关的术语 JoinPoint(连接点):可以被拦截到的点,增删改查的方法都可以被增强,这些方法就可以被称为是连接点 Pointcut(切入点):真正被拦截到的点,在实际开发中只对save方法进行了增强,所以save方法就称为是切入点 Advice(通知,增强):方法层面的增强.现在对save方法进行权限校验,权限校验的方法称之为通知 Introduction(引介):类层面的增强 Target(目标):被增强的对象,UserDao称之为是目标 weaving(织入):将通知应用到目标的过程,将权限校验的方法的代码应用到UserDao的save方法的过程,织入后产生结果代理类(Proxy) Aspect(切面):多个通知和多个切入点组合!!! AspectJ的XML的方式 引入基本的开发包(6个) 引入AOP开发的相关Jar包(4个) 引入Spring的配置文件 引入aop的约束 123456789101112131415161718192021222324252627282930&lt;aop:config&gt; &lt;!-- expression=表达式的配置来决定哪些类的那些方法需要进行增强(切入点) --&gt; &lt;aop:pointcut expression="execution(* spring.demo2.ProductDaoImpl.save(..))" id="pointcut1"/&gt; &lt;aop:pointcut expression="execution(* spring.demo2.ProductDaoImpl.delete(..))" id="pointcut2"/&gt; &lt;aop:pointcut expression="execution(* spring.demo2.ProductDaoImpl.update(..))" id="pointcut3"/&gt; &lt;aop:pointcut expression="execution(* spring.demo2.ProductDaoImpl.find(..))" id="pointcut4"/&gt; &lt;!-- 配置切面 --&gt; &lt;aop:aspect ref="myAspect"&gt; &lt;!-- 前置通知 --&gt; &lt;!-- 在pointcut1这个切入点的前面应用checkPri方法 --&gt; &lt;aop:before method="checkPri" pointcut-ref="pointcut1"/&gt; &lt;!-- 后置通知 --&gt; &lt;!-- 在pointcut2这个切入点的后面应用writelog方法 --&gt; &lt;aop:after-returning method="writelog" pointcut-ref="pointcut2" returning="result"/&gt; &lt;!-- 环绕通知 --&gt; &lt;!-- 在pointcut3这个切入点环绕around方法 --&gt; &lt;aop:around method="around" pointcut-ref="pointcut3"/&gt; &lt;!-- 异常抛出通知 --&gt; &lt;!-- 在pointcut3这个切入点加入异常抛出通知afterThrowing方法 --&gt; &lt;aop:after-throwing method="afterThrowing" pointcut-ref="pointcut4" throwing="ex"/&gt; &lt;!-- 最终通知 --&gt; &lt;!-- 在pointcut3这个切入点加入异常抛出通知afterThrowing方法 --&gt; &lt;aop:after method="after" pointcut-ref="pointcut4"/&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt; Spring中的通知类型 前置通知 在目标方法执行之前进行操作 配置前置通知 12345&lt;!-- 配置切面 --&gt; &lt;aop:aspect ref="myAspect"&gt; &lt;!-- 在pointcut1这个切入点的前面应用checkPri方法 --&gt; &lt;aop:before method="checkPri" pointcut-ref="pointcut1"/&gt; &lt;/aop:aspect&gt; * 可以获得切入点信息 * 12public void checkPri(JoinPoint joinpoint)&#123;System.out.println("权限校验..."+joinpoint); 后置通知 在目标方法执行之后进行操作 配置后置通知 123&lt;!-- 后置通知 --&gt; &lt;!-- 在pointcut2这个切入点的后面应用writelog方法 --&gt; &lt;aop:after-returning method="writelog" pointcut-ref="pointcut2" returning="result"/&gt; * 可以获得方法返回值 * 123public void writelog(Object result)&#123; System.out.println("日志记录..."+result); &#125; 环绕通知 在目标方法执行前和后进行操作 配置环绕通知 123&lt;!-- 环绕通知 --&gt; &lt;!-- 在pointcut3这个切入点环绕around方法 --&gt; &lt;aop:around method="around" pointcut-ref="pointcut3"/&gt; * 可以阻止目标方法的执行 异常抛出通知 在程序出现异常的时候进行的操作 配置异常抛出通知 123&lt;!-- 异常抛出通知 --&gt; &lt;!-- 在pointcut3这个切入点加入异常抛出通知afterThrowing方法 --&gt; &lt;aop:after-throwing method="afterThrowing" pointcut-ref="pointcut4" throwing="ex"/&gt; * 123public void afterThrowing(Throwable ex)&#123; System.out.println("异常抛出通知..."+ex.getMessage()); &#125; 最终通知 无论代码是否有异常总是会执行的操作 配置最终通知 123&lt;!-- 最终通知 --&gt; &lt;!-- 在pointcut3这个切入点加入异常抛出通知afterThrowing方法 --&gt; &lt;aop:after method="after" pointcut-ref="pointcut4"/&gt; * 12345/** *最终通知:相当于finally代码块中的内容 */ public void after()&#123; System.out.println("最终通知..."); Spring的切入点表达式写法 基于execution的函数完成的 语法 [访问修饰符] 方法返回值 包名.类名.方法名(参数) public void spring.demo2.ProductDaoImpl.save(..) *为通配符 +表示该类和子类 ..表示该包和子包 Spring 的AOP的开发(注解) AspectJ的注解的方式 引入基本的6个jar包 引入aspectJ相关的4个jar包 引入配置文件 编写目标类并配置 编写切面类并配置 使用注解的AOP对目标类进行增强 在配置文件中去打开注解的AOP开发 &lt;aop:aspectj-autoproxy/&gt; 1234567@Aspectpublic class MyAspectAnno &#123; @Before(value="execution(* spring.demo1.OrderDao.save(..))" ) public void before()&#123; System.out.println("前置增强..."); &#125;&#125; 1234567891011121314@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration("classpath:applicationContext.xml")public class SpringDemo1 &#123; @Resource(name="orderDao") private OrderDao orderDao; @Test public void demo1()&#123; orderDao.save(); orderDao.update(); orderDao.find(); orderDao.delete(); &#125;&#125; Spring的注解的AOP的通知类型 @Before: 前置通知 @AfterReturning:后置通知 @Around: 环绕通知 @AfterThrowing: 异常抛出通知 @After: 最终通知 Spring的AOP的切入点的配置 123//切入点注解: @Pointcut(value="execution(* spring.demo1.OrderDao.find(..))") private void pointcut1()&#123;&#125; Spring的JDBC的模板的使用 Spring的JDBC的模板 Spring是EE开发的一站式的框架,有EE开发的每层的解决方案,Spring对持久层也提供了解决方案,ORM模块和JDBC的模板. JDBC模板的使用 引入基本的6的jar包 引入数据库驱动jar包 引入Spring的JDBC模板的jar包 引入单元测试的jar包 创建数据库和表springt.account 使用JDBC的模板:保存数据 123456789101112131415public class JdbcDemo1 &#123; @Test public void demo1()&#123; //创建连接池 DriverManagerDataSource dataSource = new DriverManagerDataSource(); dataSource.setDriverClassName("com.mysql.jdbc.Driver"); dataSource.setUrl("jdbc:mysql:///springt"); dataSource.setUsername("root"); dataSource.setPassword("975864"); //创建jdbc模板 JdbcTemplate jdbcTemple = new JdbcTemplate(dataSource); jdbcTemple.update("insert into account values (null,?,?)", "xiaohu",10000d); &#125;&#125; 将连接池和模板都交给Spring管理 引入Spring的配置文件 123456789101112&lt;!-- 配置Spring内置的连接池 --&gt; &lt;bean id="dataSource" class="org.springframework.jdbc.datasource.DriverManagerDataSource"&gt; &lt;!-- 属性注入 --&gt; &lt;property name="driverClassName" value="com.mysql.jdbc.Driver"/&gt; &lt;property name="url" value="jdbc:mysql:///spring5"/&gt; &lt;property name="username" value="root"/&gt; &lt;property name="password" value="975864"/&gt; &lt;/bean&gt; &lt;!-- 配置SpringJDBC的模板 --&gt; &lt;bean id="jdbcTemplate" class="org.springframerwork.jdbc.core.JdbcTemplate"&gt; &lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt; &lt;/bean&gt; 使用Spring 的数据库连接池和jdbc模板 1234567891011@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration("classpath:applicationContext.xml")public class JdbcDemo2 &#123; @Resource(name="jdbcTemplate") private JdbcTemplate jdbcTemple; @Test public void demo1()&#123; jdbcTemple.update("insert into account values (null,?,?)", "小天",100d); &#125;&#125; 使用开源的数据库连接池 DBCP的使用 引入两个jar包(dbcp和pool) 配置DBCP连接池 1234567&lt;!-- 配置DBCP连接池 --&gt;&lt;bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource"&gt; &lt;property name="driverClassName" value="com.mysql.jdbc.Driver"/&gt; &lt;property name="url" value="jdbc:mysql:///springt"/&gt; &lt;property name="username" value="root"/&gt; &lt;property name="password" value="975864"/&gt;&lt;/bean&gt; C3P0的使用 引入c3p0的jar包 配置C3P0连接池 123456789&lt;!-- 配置C3P0连接池 --&gt; &lt;bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource"&gt; &lt;property name="driverClass" value="com.mysql.jdbc.Driver"/&gt; &lt;property name="jdbcUrl" value="jdbc:mysql:///springt"/&gt; &lt;property name="user" value="root"/&gt; &lt;property name="password" value="975864"/&gt; &lt;/bean&gt; 抽取配置到属性文件 定义一个属性文件 1234jdbc.driverClass=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql:///springtjdbc.username=rootjdbc.password=975864 在Spring的配置文件中引入属性文件 123456&lt;!-- 第一种方式通过一个bean标签引入(很少用) --&gt;&lt;!-- &lt;bean class="org.springframework.beans.factory.config.PropertyPlaceholderConfigurer"&gt; &lt;property name="location" value="classpath:jdbc.properties"&gt;&lt;/property&gt; &lt;/bean&gt; --&gt; &lt;!-- 第二种方式通过context标签引入 --&gt; &lt;context:property-placeholder location="calsspath:jdbc.properties"/&gt; 引入属性文件的值 123456&lt;bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource"&gt; &lt;property name="driverClass" value="$&#123;jdbc.driverClass&#125;"/&gt; &lt;property name="jdbcUrl" value="$&#123;jdbc.url&#125;"/&gt; &lt;property name="user" value="$&#123;jdbc.username&#125;"/&gt; &lt;property name="password" value="$&#123;jdbc.password&#125;"/&gt; &lt;/bean&gt; 使用JDBC的模板完成CRUD的操作 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration("classpath:applicationContext.xml")public class JdbcDemo2 &#123; @Resource(name="jdbcTemplate") private JdbcTemplate jdbcTemple; //增删改的操作相同 @Test //保存操作 public void demo1()&#123; jdbcTemple.update("insert into account values (null,?,?)", "小水",1000d); &#125; @Test //修改操作 public void demo2()&#123; jdbcTemple.update("update account set name=?,money=? where id=?","李四",2000d,5); &#125; @Test //删除操作 public void demo3()&#123; jdbcTemple.update("delete from account where id=?",6); &#125; @Test //查询操作:查询名称 public void demo4()&#123; String name = jdbcTemple.queryForObject("select name from account where id=?", String.class,5); System.out.println(name); &#125; @Test //查询操作:查询记录总条数 public void demo5()&#123; Long count = jdbcTemple.queryForObject("select count(*) from account", Long.class); System.out.println(count); &#125; @Test //查询操作:查询一条记录封装到一个对象中 public void demo6()&#123; Account account = jdbcTemple.queryForObject("select * from account where id=?", new MyRowMapper(), 5); System.out.println(account); &#125; @Test //查询操作:查询多条记录封装到一个List集合中 public void demo7()&#123; List&lt;Account&gt; list = jdbcTemple.query("select * from account ", new MyRowMapper()); for (Account account : list) &#123; System.out.println(account); &#125; &#125; class MyRowMapper implements RowMapper&lt;Account&gt;&#123; @Override public Account mapRow(ResultSet rs, int rowNum) throws SQLException &#123; Account account = new Account(); //通过account属性的set方法里利用查询到的数据,封装成一个account对象并返回 account.setId(rs.getInt("id")); account.setName(rs.getString("name")); account.setMoney(rs.getDouble("money")); return account; &#125; &#125;&#125; Spring的事务管理 事物的回顾: 事务:逻辑上的一组操作,组成这组操作的各个单元,要么全部成功,要么全部失败 事务的特性 原子性:事务不可分割 一致性:事务执行前后数据完整性保持一致 隔离性:一个事务的执行不应该受到其他事务的干扰 持久性:一旦事务结束,数据就持久化到数据库 如果不考虑隔离性将会引发安全性问题 读问题: 脏读:一个事务读到另一个事务未提交的数据 不可重复读:一个事务读到另一个事务已经提交的Update的数据,导致一个事务中多次查询的结果不一致 虚读,幻读:一个事务读到另一个事务已经提交的insert的数据,导致一个事务中多次查询的结果不一致 写问题: 丢失更新 解决读问题 设置事务的隔离级别: Read uncommitted:未提交读,任何读问题都解决不了但是效率高 Read committed:已提交读,解决脏读,但是不可重复读和虚读可能发生 Repeatable:重复读,解决脏读和不可重复读,但是虚读可能发生 Serializable:解决所有读问题,但是效率低,一般设置问2,3两个级别 Spring事务管理的API Platform TransactionManager:平台事务管理器 平台事务管理器:接口,是Spring用于管理事务的真正的对象 DataSourceTransactionManager:底层使用JDBC管理事务 HibernateTransactionManager:底层使用Hibernat管理事务 TransactionDefinition:事务定义信息 事务定义:用于定义事务的相关的信息,隔离级别,超时信息,传播行为,是否只读 TransactionStatus:事务的状态 事务状态:用于管理事务运行过程中,事务的状态的对象 事务管理的 API 的关系 Spring进行事务管理的时候,首先平台事务管理器根据事务定义信息进行事务的管理 ,在事务管理过程中,产生各种状态,将这些状态信息记录到事务状态的对象 Spring的事务的传播行为 Spring中提供了七种传播行为 保证多个操作在同一个事务中 propagation: 增殖, 广传, 繁殖 PROPAGATION_REQUIRED :默认值,如果A中有事务就会使用A中的事物,如果A中没有事务,创建一个新事物,将操作包含进来 PROPAGATION_SUPPORTS:支持事务,如果A中有事务,使用A中的事务,如果A中没有事务,不使用事务 PROPAGATION_MANDATORY:如果A中有事务,使用A中的事务,如果A中没有事务,抛出异常 保证多个操作不在同一个事务中 PROPAGATION_REQUIRES_NEW:如果A中有事务,将A的事务挂起(暂停),创建新事务,只包含自身操作,如果A中没有事务,创建一个新事务,包含自身的操作 PROPAGATION_NOT_SUPPORTED:如果A中有事务,将A的事务挂起,不使用事务管理 PROPAGATION_NEVER:如果A中有事务,报异常 嵌套式事务 PROPAGATION_NESTED:如果A中有事务,按照A的事务执行,执行完之后设置一个保存点,执行B中的操作,如果没有异常,执行通过,如果有异常,可以选择回滚到最初始的位置也可以选择回滚到保存点 事务的传播行为主要用来解决业务层方法相互调用的问题 Spring事务管理 搭建Spring事务管理的环境 创建Service的接口和实现类 1234567891011121314151617181920public class AccountServiceImpl implements AccountService&#123; //注入DAO private AccountDao accountDao; public void setAccountDao(AccountDao accountDao) &#123; this.accountDao = accountDao; &#125; @Override /** * from:转出账号 * to:转入账号 * money:转账金额 */ public void transfer(String from, String to, Double money) &#123; accountDao.outMoney(from,money); accountDao.inMoney(to, money); &#125;&#125; * 创建DAO的接口和实现类 12345678910111213public class AccountDaoImpl extends JdbcDaoSupport implements AccountDao&#123; @Override public void outMoney(String from, Double money) &#123; this.getJdbcTemplate().update("update account set money = money - ? where name = ?", money,from); &#125; @Override public void inMoney(String to, Double money) &#123; this.getJdbcTemplate().update("update account set money = money + ? where name = ?", money,to); &#125;&#125; * 配置Service和DAO交给Spring管理 12345678910&lt;!-- 配置Service======= --&gt;&lt;bean id="accountService" class="tx.demo1.AccountServiceImpl"&gt; &lt;property name="accountDao" ref="accountDao"/&gt;&lt;/bean&gt; &lt;!-- 配置Dao======= --&gt;&lt;bean id="accountDao" class="tx.demo1.AccountDaoImpl"&gt;&lt;/bean&gt; * 在DAO中写SQL语句控制 * 配置连接池 1234567&lt;!-- 配置C3P0连接池 --&gt; &lt;bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource"&gt; &lt;property name="driverClass" value="$&#123;jdbc.driverClass&#125;"/&gt; &lt;property name="jdbcUrl" value="$&#123;jdbc.url&#125;"/&gt; &lt;property name="user" value="$&#123;jdbc.username&#125;"/&gt; &lt;property name="password" value="$&#123;jdbc.password&#125;"/&gt; &lt;/bean&gt; * 在DAO中注入Jdbc的模板 12345&lt;!-- 配置Dao======= --&gt;&lt;bean id="accountDao" class="tx.demo1.AccountDaoImpl"&gt;&lt;!-- &lt;property name="jdbcTemplate" ref="jdbcTemple"&gt;&lt;/property&gt; --&gt;&lt;!-- 因为我们的类继承了JdbcDaoSupport所以我们需要JDBC模板的时候只要传给他一个连接池,他就会自动生成一个模板给我们 --&gt;&lt;property name="dataSource" ref="dataSource"/&gt; 编程式事务管理(需要手动编写代码) 配置平台事务管理器: 1234&lt;!-- 配置平台事务管理器====== --&gt;&lt;bean id="transactionManager" class="org.springframework.jdbc.darasource.DataSourceTransactionManager"&gt;&lt;property name="dataSource" ref="dataSource"/&gt;&lt;/bean&gt; 配置事务管理的模板类 1234&lt;!-- 配置事务管理的模板 --&gt;&lt;bean id="transactionTemplate" class="org.springframework.transaction.support.TransactoinTemplate"&gt; &lt;property name="transactionManager" ref="transactionManager"/&gt;&lt;/bean&gt; 在业务层注入事务管理的模板 12345//注入事务管理的模板 private TransactionTemplate transactionTemplate; public void setTransactionTemplate(TransactionTemplate transactionTemplate) &#123; this.transactionTemplate = transactionTemplate; &#125; 1234567&lt;!-- 配置Service======= --&gt; &lt;bean id="accountService" class="tx.demo1.AccountServiceImpl"&gt; &lt;property name="accountDao" ref="accountDao"/&gt; &lt;!-- 注入事务管理的模板 --&gt; &lt;property name="transactionTemplate" ref="transactionTemplate"/&gt; &lt;/bean&gt; 声明式事务管理 XML方式的声明式事务管理 引入AOP的四个开发包 配置事务管理器 1234&lt;!-- 配置事务管理器=== --&gt;&lt;bean id="transactionManager" class="org.springframework.jdbc.datasource.DatasourceTransactionManager"&gt; &lt;property name="dataSource" ref="dataSource"/&gt;&lt;/bean&gt; 配置事务的增强 123456&lt;!-- 配置事务的增强=== --&gt; &lt;tx:advice transaction-manager="transactionManager"&gt; &lt;tx:attributes&gt; &lt;tx:method name="transfer" propagation="REQUIRED"/&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt; AOP的配置 12345&lt;!-- AOP的配置==== --&gt; &lt;aop:config&gt; &lt;aop:pointcut expression="execution(* tx.demo2.AccountServiceImpl.*(..))" id="pointcut1"/&gt; &lt;aop:advisor advice-ref="txAdvice" pointcut-ref="pointcut1"/&gt; &lt;/aop:config&gt; 注解方式的声明式事务管理 引入aop开发的jar包 配置事务管理器 开启注解事务 12&lt;!-- 开启注解事务==== --&gt; &lt;tx:annotation-driven transaction-manager="transactionManager"/&gt; 添加注解 12@Transactionalpublic class AccountServiceImpl implements AccountService&#123;]]></content>
      <categories>
        <category>Java</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux使用心得]]></title>
    <url>%2F2019%2F04%2F27%2FLinux%E4%BD%BF%E7%94%A8%E5%BF%83%E5%BE%97%2F</url>
    <content type="text"><![CDATA[Linux中的常用命令Linux下权用户组/用户/权限管理命令groupadd:添加用户组groupadd命令格式: ​ groupadd [选项] 组名 选项: -g GID:指定组ID groupdel:删除用户组groupdel命令格式: ​ groupdel 组名 但这个组中要没有初始用户,因为不能让一个用户没有初始组 useradd:添加用户useradd命令格式: ​ useradd [选项] 用户名 选项: -u UID:手工指定用户的UID号 -d 家目录:手工指定用户的家目录 -c 用户说明:手工指定用户的说明 -g 组名:手工指定用户的初始组 -G 组名:指定用户的附加组 -s shell:手工指定用户的登录shell,默认是/bin/bash usermod:修改用户信息usermod命令格式: ​ usermod [选项] 用户名 选项: -u UID:修改用户的UID号 -c 用户说明:修改用户的说明信息 -G 组名:修改用户的附加组 -L:临时锁定用户(Lock) -U:解锁用户锁定(Unlock) userdel:删除用户userdel命令格式: ​ userdel [-r] 用户名 选项: -r:删除用户的同时删除用户家目录 passwd:修改用户密码passwd命令格式: ​ passwd [选项] 用户名 选项: -s: 查询用户密码的密码状态.仅root用户可用 -l:暂时锁定用户,仅root用户可用 -u:解锁用户,仅root用户可用 –stdin: 可以通过管道符输出的数据作为用户的密码 如不加用户名,则默认修改当前用户 chage:修改用户密码状态chage命令格式: ​ chage [选项] 用户名 选项: -l:列出用户的详细密码状态 -d 日期:修改密码最后一次更改日期 -m 天数:两次密码修改间隔 -M 天数:密码有效期 -W 天数:密码过期前警告天数 -I 天数:密码过期后宽限天数 -E 日期:账号失效时间 chown:改变文件或者目录的所有者命令英文原意:change file ownership 执行权限:所有用户 chown命令格式: ​ chown [用户] [文件或目录] chmod:权限管理命令命令英文原意:change the permissions mode of a file 执行权限:所有用户 chmod命令格式: ​ chmod [{ugoa} {+-=}{rwx}] [文件或目录] ​ chmod [mode=421] [文件或目录] 选项: ​ -R 递归修改]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式]]></title>
    <url>%2F2019%2F04%2F25%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[设计原则 找出应用中可能需要变化之处，把他们独立出来，不要和那些不需要变化的代码混在一起。 针对接口编程，而不是针对实现编程。 多用组合，少用继承。 为了交互对象之间的松耦合设计而努力。 类应该对扩展开放,对修改关闭。 设计模式策略模式 定义了算法族,分别封装起来,让他们之间可以互相替换,此模式让算法的变换独立于使用算法的客户。 观察者模式 定义了对象之间的一对多依赖，这样一来，当一个对象改变状态时，它的所有依赖者都会收到通知并自动更新。 装饰者模式​ 动态地将责任附加到对象上,若要扩展功能,装饰者提供了比继承更有弹性的替代方案。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>DesignMode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于java中的注解]]></title>
    <url>%2F2019%2F04%2F23%2F%E5%85%B3%E4%BA%8Ejava%E4%B8%AD%E7%9A%84%E6%B3%A8%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[什么是注解?定义 注解（Annotation），也叫元数据。一种代码级别的说明。它是JDK1.5及以后版本引入的一个特性，与类、接口、枚举是在同一个层次。它可以声明在包、类、字段、方法、局部变量、方法参数等的前面，用来对这些元素进行说明，注释。 练习代码 JDK中的三种注解 @Override 它的作用是对覆盖超类中方法的方法进行标记，如果被标记的方法并没有实际覆盖超类中的方法，则编译器会发出错误警告。 @Deprecated 它的作用是对不应该再使用的方法添加注解，当编程人员使用这些方法时，将会在编译时显示提示信息，它与javadoc里的@deprecated标记有相同的功能，准确的说，它还不如javadoc @deprecated，因为它不支持参数，使用@Deprecated的示例代码示例如下： @SuppressWarnings 其参数有：deprecation，使用了过时的类或方法时的警告unchecked，执行了未检查的转换时的警告fallthrough，当 switch 程序块直接通往下一种情况而没有 break 时的警告path，在类路径、源文件路径等中有不存在的路径时的警告serial，当在可序列化的类上缺少serialVersionUID 定义时的警告finally ，任何 finally 子句不能正常完成时的警告all，关于以上所有情况的警告12//以下注解的含义为: 抑制编译器发生警告信息(如果变量未使用或者未遵循泛型格式错误的不报警告) @SuppressWarnings(&#123; "unused", "rawtypes" &#125;) 注解的特点 注解和接口,类一样都是数据类型. 注解可以加在变量,方法,类上. 注解可以有属性也可以没有属性@override @Test(timeout=1000) 注解是有作用范围的(源码期间有效,编译期间有效,运行期间有效) 源码期间有效: String 类上的@Author,@Since,@See 作用:使用命令 javadoc 命令将当前的源码生成帮助文件,可以识别String类上的相关的注解. 编译期间有效:@Override,@Deprecated,@Suppresswarning 作用:告诉编译器部分信息 运行期间有效:@Test 作用当我们在我们当前的代码上以Junit方式运行时,Junit会运行方法上包含@Test注解的方法 自定义注解 格式: 12345678910public @interface 注解名称 &#123; //在注解中定义一个属性 public long timeout() default -1; //only primitive type, String, Class, annotation, enumeration are permitted or 1- dimensional arrays thereof //报错,原因是属性不支持自定义类类型 //public TestAnnotation aa(); //注解的属性支持的类型有:基本数据类型(4类8种),String,Class,Annotation(注解类型),枚举类型,以及以上类型的一维数组类型 &#125; 注解作用: 配置作用 配置:开发的时候部分信息不希望写死在程序中,例如数据库的用户名和密码,可以将用户名和密码存放在.txt,.properties,.xml文件中,利用程序来读取文件中的内容. 什么时候用注解来做配置 如果配置信息不会发生频繁的改动,例如Servlet路径,建议使用注解的形式. 如果配置信息需要发生频繁的修改,例如数据库的用户名和密码信息,建议采用传统方法(.txt,.xml,.properties).]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Java注解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ajax]]></title>
    <url>%2F2019%2F04%2F19%2FAjax%2F</url>
    <content type="text"><![CDATA[Ajax:是什么? 使用css和XHTML来表示。 使用DOM模型来交互和动态显示。 使用XMLHttpRequest来和服务器进行异步通信。 使用JavaScript来绑定和调用。 练习代码 有什么用? 咱们的网页如果想要刷新局部内容,那么需要重新载入整个网页,用户体验不是很好.就是为了解决局部刷新问题,其他部分不动,只改变更新了的地方. GET 还是 POST？与 POST 相比，GET 更简单也更快，并且在大部分情况下都能用。 然而，在以下情况中，请使用 POST 请求： 无法使用缓存文件（更新服务器上的文件或数据库） 向服务器发送大量数据（POST 没有数据量限制） 发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠 数据请求: Get 创建对象: 123456789101112131415161718function ajaxFunction()&#123; var xmlHttp; try&#123; // Firefox, Opera 8.0+, Safari xmlHttp=new XMLHttpRequest(); &#125; catch (e)&#123; try&#123;// Internet Explorer xmlHttp=new ActiveXObject("Msxml2.XMLHTTP"); &#125; catch (e)&#123; try&#123; xmlHttp=new ActiveXObject("Microsoft.XMLHTTP"); &#125; catch (e)&#123;&#125; &#125; &#125;return xmlHttp;&#125; 发送请求: 123456789101112131415//执行get请求 function get() &#123; //1.创建xmlhttprequest 对象 var request = ajaxFunction(); //2.发送请求 /* 参数1:请求类型 GET or POST 参数2:请求的路径 参数3:是否同步 true or false */ request.open("GET","/ajax/DemoServlet01",true); request.send(); &#125; ​ 如果发送请求的同时,还想获取数据,那么代码如下: 12345678910111213141516 //执行get请求function get() &#123; //1.创建xmlhttprequest 对象 var request = ajaxFunction(); //2.发送请求 request.open("GET","/ajax/DemoServlet01?name=aa&amp;age=18",true); //3.获取响应数据 注册监听的意思,一会儿准备的状态发生了改变,那么就执行等号右边的方法 request.onreadystatechange = function()&#123; //前半段表示已经能够正常处理,再判断状态码是否是200 if(request.readyState == 4 &amp;&amp; request.status == 200) &#123; //弹出响应的信息 alert(request.responseText); &#125; &#125; request.send();&#125; 数据请求: Post 创建对象: 123456789101112131415161718function ajaxFunction()&#123; var xmlHttp; try&#123; // Firefox, Opera 8.0+, Safari xmlHttp=new XMLHttpRequest(); &#125; catch (e)&#123; try&#123;// Internet Explorer xmlHttp=new ActiveXObject("Msxml2.XMLHTTP"); &#125; catch (e)&#123; try&#123; xmlHttp=new ActiveXObject("Microsoft.XMLHTTP"); &#125; catch (e)&#123;&#125; &#125; &#125;return xmlHttp;&#125; 发送请求: 1234567891011121314151617181920212223 function post() &#123; //1.创建对象 var request = ajaxFunction(); //2.发送请求 request.open("POST","/ajax/DemoServlet01",true); request.send();&#125; 如果发送请求的同时要带数据过去: function post() &#123; //1.创建对象 var request = ajaxFunction(); //2.发送请求 request.open("POST","/ajax/DemoServlet01",true); //如果使用的是post方式带数据,那么要添加头,说明提交的数据类型是一个经过url编码的form表单数据 request.setRequestHeader("Content-type","application/x-www-form-urlencoded"); //要将数据发送到服务器 在send方法里写表单数据 request.send("name=bb&amp;age=19");&#125; ​ 如果发送请求的同时,还想获取数据,那么代码如下: 12345678910111213141516171819202122//执行post请求 有响应的function post() &#123; //1.创建对象 var request = ajaxFunction(); //2.发送请求 request.open("POST","/ajax/DemoServlet01",true); //获取服务器传送过来的数据,加一个状态的监听. request.onreadystatechange=function() &#123; if(request.readyState == 4 &amp;&amp; request.status == 200)&#123; alert("post:"+ request.responseText); &#125; &#125; //如果使用的是post方式带数据,那么要添加头,说明提交的数据类型是一个经过url编码的form表单数据 request.setRequestHeader("Content-type","application/x-www-form-urlencoded"); //要将数据发送到服务器 在send方法里写表单数据 request.send("name=bb&amp;age=19");&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JavaScript</tag>
        <tag>JavaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[servlet相关内容]]></title>
    <url>%2F2019%2F04%2F16%2Fservlet%2F</url>
    <content type="text"><![CDATA[详细连接菜鸟教程 servlet相关概念 Servlet 为创建基于 web 的应用程序提供了基于组件、独立于平台的方法，可以不受 CGI 程序的性能限制。Servlet 有权限访问所有的 Java API，包括访问企业级数据库的 JDBC API. Java Servlet 是运行在 Web 服务器或应用服务器上的程序，它是作为来自 Web 浏览器或其他 HTTP 客户端的请求和 HTTP 服务器上的数据库或应用程序之间的中间层。 使用 Servlet，您可以收集来自网页表单的用户输入，呈现来自数据库或者其他源的记录，还可以动态创建网页。 架构图: Servlet任务 读取客户端（浏览器）发送的显式的数据。这包括网页上的 HTML 表单，或者也可以是来自 applet 或自定义的 HTTP 客户端程序的表单。 读取客户端（浏览器）发送的隐式的 HTTP 请求数据。这包括 cookies、媒体类型和浏览器能理解的压缩格式等等。 处理数据并生成结果。这个过程可能需要访问数据库，执行 RMI 或 CORBA 调用，调用 Web 服务，或者直接计算得出对应的响应。 发送显式的数据（即文档）到客户端（浏览器）。该文档的格式可以是多种多样的，包括文本文件（HTML 或 XML）、二进制文件（GIF 图像）、Excel 等。 发送隐式的 HTTP 响应到客户端（浏览器）。这包括告诉浏览器或其他客户端被返回的文档类型（例如 HTML），设置 cookies 和缓存参数，以及其他类似的任务。 servlet执行原理 当服务器接收到客户端浏览器的请求后,会解析请求url路径,获取访问的servlet的资源路径 查找web.xml文件,是否有对应的标签体内容 如果有,则找到对应的全类名 tomcat会将字节码文件加载进内存,并且创建其对象 调用方法 Servlet 生命周期Servlet生命周期可被定义为从创建到毁灭的整个过程.以下是Servlet遵循的过程: Servlet 通过调用 init () 方法进行初始化。 servlet的init方法只执行一次,说明一个servlet在内存中只存在一个对象,servlet是单例的 多个用户同时访问时可能会出现线程安全的问题 解决:尽量不要在servelt中定义成员变量,即使定义了成员变量也不要对其修改值 Servlet 调用 service() 方法来处理客户端的请求。 Servlet 通过调用 destroy() 方法终止（结束）。 最后，Servlet 是由 JVM 的垃圾回收器进行垃圾回收的 Servlet 表单数据:很多情况下，需要传递一些信息，从浏览器到 Web 服务器，最终到后台程序。浏览器使用两种方法可将这些信息传递到 Web 服务器，分别为 GET 方法和 POST 方法。 http协议:基本概念: http: Hyper Text Transfer Protocol 超文本传输协议 传输协议:定义了,客户端和服务端通信时,发送数据的格式 特点: 基于TCP/IP的高级协议 默认端口号:80 基于请求/响应模型的:一次请求对应一次响应 无状态的:每次请求之间相互独立,不能交互数据 历史版本: 1.0: 每一次请求都会建立新的连接 1.1:复用连接 请求消息数据格式: 请求行 请求方式 请求url 请求协议/版本 GET /login.html HTTP/1.1 请求方式: http协议有七种请求方式,常用的有两种 GET: 请求参数在请求行中,在url后 请求的url长度是有限制的 不太安全的 POST: 请求参数在请求体中 请求的url的长度是没有长度的 相对安全的 请求头 作用:客户端浏览器告诉服务器一些信息 请求头名称: 请求头值 常见的请求头: User-Agent: 浏览器告诉服务器,我访问你使用的浏览器版本信息 可以在服务器端获取该头的信息,解决浏览器的兼容性问题 referer:http://localhost/login.html 告诉服务器我(当前请求)从哪儿来? 作用: 防盗链: 统计工作: 请求空行 空行,分割请求头和请求体 请求体(正文) 封装post请求消息的请求参数的 响应消息数据格式: 响应行 组成:协议/版本 响应状态码 状态码描述 HTTP/1.1 200 OK 响应状态码: 服务器告诉客户端浏览器请求和响应的一个状态 状态码都是三位数字 分类: 一百多:服务器接收客户端消息,但没有接收完成,等待一段时间后,发送一百多的状态码 二百多:成功 三百多:302:重定向 304: 访问缓存 四百多:客户端错误 404:请求路径没有对应的资源 405:请求方式没有对应的doxxx方法 五百多:服务器端错误 响应头 组成:响应头名称: 响应头值 常见的响应头: Content-Type:服务器告诉客户端本次响应体数据格式以及编码格式 Content-disposition:服务器告诉客户端以什么样的格式打开响应体数据 值: in-line:默认值,在当前页面内打开 attachment;filename=xxx:以附件形式打开响应体,文件下载 响应空行 响应体:传输的数据 HTTP协议工作流程: 地址解析(,解析URL,DNS解析) 封装HTTP请求(这一步把上面写的 URL 以及本机的一些信息封装成一个 HTTP 请求数据包) 封装TCP包(第三步就是封装 TCP 包 , 建立 TCP 连接 , 也就是常说的”三次握手” . 由于HTTP位于最上层的应用层 , 所以HTTP在工作之前要由 TCP 和 IP 协议建立网络连接 , 这就是TCP/IP协议族 , 因此互联网又称为 TCP/IP 网络 .) 客户端发送请求命令(第四步就是在连接建立之后 , 客户端发送 HTTP 请求到服务端与请求相关的信息都会包含在请求头和请求体中发送给服务器端 ) 服务器端响应(服务器端在收到请求之后 , 根据客户端的请求发送给客户端相应的信息 , 相关的响应信息都会放在响应头和响应体中 ) 关闭连接(服务器端在发送完响应之后 , 就会关闭连接 , 如果过客户端的请求的头部信息中有 Connection-alive , 那么客户端在响应完这个请求之后不会关闭连接 , 知道客户端的所有请求都响应完毕 , 才会关闭连接 , 这样大大节省了带宽和 IO 资源 ) GET方法:GET 方法向页面请求发送已编码的用户信息。页面和已编码的信息中间用 ? 字符分隔，如下所示： http://www.test.com/hello?key1=value1&amp;key2=value2 GET 方法是默认的从浏览器向 Web 服务器传递信息的方法，它会产生一个很长的字符串，出现在浏览器的地址栏中。如果您要向服务器传递的是密码或其他的敏感信息，请不要使用 GET 方法。GET 方法有大小限制：请求字符串中最多只能有 1024 个字符。 这些信息使用 QUERY_STRING 头传递，并可以通过 QUERY_STRING 环境变量访问，Servlet 使用 doGet() 方法处理这种类型的请求。 post方法:另一个向后台程序传递信息的比较可靠的方法是 POST 方法。POST 方法打包信息的方式与 GET 方法基本相同，但是 POST 方法不是把信息作为 URL 中 ? 字符后的文本字符串进行发送，而是把这些信息作为一个单独的消息。消息以标准输出的形式传到后台程序，您可以解析和使用这些标准输出。Servlet 使用 doPost() 方法处理这种类型的请求。 request: request对象和response对象的原理: request和response对象是由服务器创建的,我们来使用它们 request对象是获取请求消息,response对象是用来设置响应消息 request对象继承体系结构: ServletRequest –接口 ​ | 继承 HttpServletRequest –接口 ​ |实现 org.apache.catalina.connector.RequestFacade类(tomcat) request功能: 获取请求消息数据 获取请求行数据 GET /day14/demo1?name=zhangsan HTTP/1.1 方法: 获取请求方式:GET String getMethod() 获取虚拟目录: /day14 String getContextPath() 获取Servlet路径: /demo1 String getServletPath() 获取get方式的请求参数:name=zhangsan String getQueryString() 获取请求URL：/day14/demo1 String getRequestURI :/servlet01/RequestDemo1 StringBuffer getRequestURL() :http://localhost:8080/servlet01/RequestDemo1 URL:统一资源定位符 :http://localhost:8080/servlet01/RequestDemo1 URI:统一资源标识符 :/servlet01/RequestDemo1 获取协议及版本：HTTP/1.1 String getProtocol() 获取客户机的IP地址: String getRemoteAddr() 获取请求头数据 方法: 通过请求头的名称获取请求头的值 String getHeader(String name) 获取所有的请求头名称 Enumeration\&lt;String> get HeaderNames() 获取请求体数据 请求体:只有post请求方式,才有请求体,在请求体中封装了POST请求的请求参数 步骤: 获取流对象 BufferedReader getReader():获取字符输入流,只能操作字符数据 ServletInputStream getInputStream():获取字节输入流,可以操作所有数据类型 再从流对象中获取数据 其他功能 获取请求参数通用方式(get和post通用) String getParameter(String name):根据参数名称获取参数值 username=zs&amp;password=123 String[] getParameterValues(String name):根据参数名称获取参数值的数组 hobby=xx&amp;hobby=game Enumeration\&lt;String> getParameterNames():获取所有请求的参数名称 Map&lt;String,String[]&gt; getParameterMap():获取所有参数的map集合 中文乱码问题: get方式:tomcat8已经将get方式乱码问题解决了 post方式:会乱码 解决:在获取参数前,设置request的编码为utf-8 1request.setCharacterEncoding("utf-8"); 请求转发:一种在服务器内部的资源跳转方式 步骤 通过request对象获取请求转发器对象:RequestDispatcher getRequestDispatcher(String path) 使用RequestDispatcher对象来进行转发:forward(ServletRequest request,ServletResponse response) 特点: 浏览器地址栏路径不发生变化 只能转发到当前服务器内部资源中 转发是一次请求 共享数据: 域对象:一个有作用范围的对象,可以在范围内共享数据 request域:代表一次请求的范围,一般用于请求转发的多个资源中共享数据 方法: void setAttribute(String name,Object obj):存储数据 Object getAttribute(String name):通过键来获取值 void removeAttribute(String name):通过键来移除键值对 获取ServletContext: ServletContext getServletContext() response: response对象继承体系结构: ServletResponse –接口 ​ | 继承 HttpServletResponse –接口 ​ |实现 org.apache.catalina.connector.ResponseFacade@3b2b20f1(tomcat) 功能:设置相应消息 设置响应行 HTTP/1.1 200 OK 设置状态码:setStatus(int sc) 设置响应头 setHeader(String name,String value) 设置响应体 使用步骤: 获取输出流 字符输出流:PrintWriter getWriter() 字节输出流:ServletOutputStream getOutPutStream() 使用输出流,将数据输出到客户端浏览器 案例: 完成重定向(资源跳转的方式): 代码实现 1234//1.设置状态码:302 response.setStatus(302); //2.设置响应头location response.setHeader("location","/servlet01/ResponseDemo2"); response.sendRedirect(&quot;/servlet01/ResponseDemo2&quot;); 重定向的特点 地址栏发生变化 重定向可以访问其他站点(服务器)的资源 重定向是两次请求,不可以使用request对象来共享数据 路径的写法 相对路径:通过相对路径不可以确定唯一资源 规则:找到当前资源和目标资源之间的相对位置关系 以./或../开头或者直接写名称 绝对路径:通过绝对路径可以确定唯一资源,以/开头 规则:判断定义的路径是给谁用的,判断请求将从哪儿发出 给客户端浏览器使用:需要加虚拟目录(项目的访问路径) 建议虚拟目录动态获取:request.getContextPath() \&lt;a>,\&lt;form>,重定向 给服务器使用:不需要加虚拟目录 转发路径 服务器输出字符数据到浏览器 步骤: 获取字符输出流 输出数据 注意: 乱码问题: PrintWriter pw = response.getWriter();获取的流的默认编码是ISO-8859-1 设置该流的默认编码 告诉浏览器应该使用什么编码来解析 解决方法: 简单形式,设置编码,在获取流之前 response.setContentType(&quot;text/html;charset=utf-8&quot;); 服务器输出字节数据到浏览器 步骤: 获取字节输出流 输出数据 验证码 本质:图片 目的:防止恶意表单注册 ServletContext对象 概念:代表整个web应用,可以和程序的容器(服务器)来通信 获取: 通过request对象获取 request.getServletContext(); 通过HtpServlet获取 this.getServletContext(); 功能 获取MIME类型: 在互联网通信过程中定义的一种文件数据类型 格式:大类型/小类型 text/html image/jpeg 获取:String getMimeType(String file) 域对象:共享数据 setAttribute(String name,Object value) getAttribute(String name) removeAttribute(String name) ServletContext对象范围:所有用户所有请求的数据 获取文件的真实路径(服务器路径) 方法:String getRealPath(String path)]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JavaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库]]></title>
    <url>%2F2019%2F04%2F15%2F%E6%95%B0%E6%8D%AE%E5%BA%93%2F</url>
    <content type="text"><![CDATA[数据库Mysql数据库 Mysql语句 SQL： Structure Query Language:结构化查询语言 DDL：数据定义语言：定义数据库，数据表他们的结构：create(创建) drop(删除) alert(修改) DML：数据操纵语言：主要用来操作数据 insert(插入) update(修改）delete（删除） DCL：数据控制语言：定义访问权限，取消访问权限，安全设置 grant DQL：数据查询语言：select（查询） from子句 where子句 数据库的CRUD操作 创建数据库 create database 数据库的名字 create database character set 字符集 create database 数据库的名字 character set 字符集 collate 校对规则 create database test character set utf8 collate utf8-bin 查看数据库 查看数据库定义的语句: show create database 数据库的名字 查看所有的数据库: show databases 修改数据库的操作 修改数据库的字符集 alter database 数据库的名字 character set 字符集 alter database test character set gbk 删除数据库 drop database 数据库的名字 drop database test 其他的数据库操作命令 选中数据库 user 数据库的名字 use test 查看当前正在使用的数据库 select database() 表的CRUD操作 创建表 create table 表名{ ​ 列名 列的类型 约束 ​ 列名 列的类型 约束 }; 列的类型 | Java | Sql | Explain || :———: | :———-: | :——————————————————: || int | int | || char/string | char/varchar | char:固定长度,char(3)代表了字符的个数 varchar:可变的长度 || double | double | || float | float | || boolean | boolean | || | data | YYYY-MM-DD || | time | HH:mm:ss || | datatime | YYYY-MM-DD HH:mm:ss (默认null) || | timestamp | YYYY-MM-DD HH:mm:ss (用于不同时区,默认使用当前时间) || | text | 主要用来存放文本 || | blob | 存放的是二进制 | 列的约束 主键约束: poinary key 唯一约束: unique 非空约束: not null 例子 123456 create table student( Sid int prinary key,Sname varchar(31), Sex int,Age int ); 查看表 查看所有的表 show tables; 查看表的创建过程 show create table student 查看表的结构 desc student 修改表 添加列(add) alter table 表明 add 列名 列的类型 列的约束 alter table student add chengji int not null; 修改列(modify) alter table student modify sex varchar(2); 修改列名(change) alter table student change sex gender varchar(2); 删除列(drop) alter table student drop chengji1; 修改列名(rename) rename table student to newname; 修改表的字符集 alter table student character set utf8; 删除表: Drop table student 表中数据的CRUD操作 插入数据 insert into 表名(列名1,列名2,列名3) values(值1,值2,值3); insert into student (sid,sname,sex,age,chengji) values(&quot;1&quot;,&quot;zhangsan&quot;,1,23,80); 可以简写为: insert into student values(3,&quot;wangwu&quot;,1,24,81),(4,&quot;zhaoliu&quot;,1,25,82) 但是如果要设置某些项目为空的话,则必须写明列名 insert into student (sid,sname,chengji) values(2,&quot;lisi&quot;,80); 批量插入 insert into student values(3,&quot;wangwu&quot;,1,24,81),(4,&quot;zhaoliu&quot;,1,25,82) 删除记录 delete from 表名 [where 条件] delete from student where sid = 0 delete from student;如果没有指定条件,则会删除表中所有的数据 truncate:DDL语言,先删除表,再重新建立表,当表中数据量较大时,若想删除全部,则使用truncate效率很高 更新记录: update 表名 set 列名1 = 列的值,列名2 = 列的值[where条件]; 将id = 1的sname改成zhangsan 如果参数为字符串,日期,要加上单引号 不加where条件,则会修改所有的表列 update student set sname = &quot;zhangsan&quot; where sid = 1; 查询记录: Seletc [distinct] [*] [列名1，列名2] from 表名 [where 条件]group by having order by Distinct :去重复的数据 Select: 选择显示哪些列的内容 查看表中的所有数据: ​ select * from student; ​ select cname,cdesc from category; 别名查询(as关键字可以省略) 表别名: select p.pname,p.price from product; select p.pname,p.price from product as p 列别名: select pname as 商品名称,price as 商品价格 from product; select pname 商品名称,price 商品价格 from product 去掉重复的值: 查询商品的价格 select price form product select distinct price from product 查询运算,仅仅在查询结果上做了运算 select * ,price*0.5 from product select *,price*0.5 as 折后价 from product 条件查询(where关键字) 指定条件,确定要查询的记录 select * from product where price &gt; 60; where后的条件写法: &lt;&gt;:不等于 ,标准的sql语法 !=:不等于 ,非标准的sql语法 12345Select * from product where price &gt; 10 and price &lt; 100; Select * from product where between 10 and 100; Select * from product where price &lt; 10 or price &gt; 999; + like 模糊查询 + %:代表的是多个字符 + `select * from product where name like &quot;%饼%&quot;; ` (查询名字中带饼字的所有商品) + _:代表的是一个字符 + `select * from product where pname like &quot;_饼%;&quot; ` (查询名字中第二个字是饼字的所有商品) + in:在某个范围内中获取值 + `select * from product where cno in (1,4,5);` (查询出商品分类ID在1,4,5里面的所有商品) 排序查询(order by) asc:ascend 升序(默认的排序方式) desc:descend 降序 查询所有商品,按照价格排序 select * from product order by price; 查询所有商品,按照价格进行降序排列 select * from product order by price desc; 查询所有名称里面带小的商品的按照价格升序排列 select * from product where name like &quot;%小% order by price asc;&quot; 聚合函数: sum():求和 avg():求平均值 count():统计数量 max():最大值 min():最小值 获得所有商品价格的总和 select sum(price) from product; 获得所有商品的个数 select count (*) from product; 查出商品价格大于平均价格的所有商品: select * from product where price &gt;(select avg(price) from product); 分组查询(group by) 过滤筛选:having关键字:可以连接聚合函数,出现在分组之后,条件筛选(根据结果集做筛选) where关键字:不可以连接聚合函数,出现在分组之前 根据cno字段分组,分组后统计商品的个数 select cno,count(*) from product group by cno; 根据cno分组,分组统计每组商品的平均价格并且商品的平均价格大于&gt;60 select cno,avg(price) from product group by cno having(price)&gt;60; 编写顺序:s…f…w…g…h…o(select from where group by having order by) 执行顺序:f…w…g…h…s…o(from where group by having select order by) 表间操作 添加外键约束: foreign key Alter table product add foreign key(cno) references category(cid); 删除的时候先删除与外键关联的所有数据，才能删除分类的数据 建立数据库的原则： 通常情况下，一个项目/应用建立一个数据库 多表之间的建表原则： 一对多： 商品分类 建表原则：在多的一方添加一个外键指向1的1方的主键。 多对多：老师和学生，学生和课程 建表原则：建立一张中间表，将多对多的关系转化为一对多的关系。中间表至少要有两个外键，这两个主键分别指向原来的那两张表。 一对一：公民和身份证； 建表原则： 将一对一的情况，当作是一对多的情况处理，在任意一张表中添加一个外键，并且这个外键要唯一指向另一张表。 将两张表的合成一张表 将两张表的主键建立起连接，让两张表里面的主键相等 实际用途：做拆表操作的时候 主键约束：默认就是不能为空，表内内容还必须唯一。外键都是指向另一张表的主键。 唯一约束：列里面的内容必须唯一，不能出现重复的情况，但可以为空。可以有多个唯一约束。 多表查询inner和outer可以省略 交叉连接查询： select * from 表1 ，表二； 过滤出有意义的数据: select * from 表一,表二 where 条件; 内连接查询:查询两张表的笛卡尔积 隐式内连接: select * from 表1 别名1，表2 别名2 where 别名1.列名 = 别名2.列名； 显式内连接： select * from 表1 别名1 inner join 表2 别名2 on 别名1.列名 = 别名2.列名； 隐式内连接: 在查询出的结果的基础上做where条件的过滤 隐式内连接:直接带着条件去查询,执行效率高 左外连接: select * from 表1 别名1 left outer join 表2 别名2 on 别名1.列名=别名2.列名 ; 左外连接会将左表中的数据都查询出来,如果右表中没有对应的数据,则用null代替 右外连接: select * from 表1 别名1 right outer join 表2 别名2 on 别名1.列名=别名2.列名 右外连接会将右表数据全部查询出来,如果左表没有对应的数据,则用null代替 分页查询: 将查询的结果分页,显示从几开始的几个数据 select * from product limit 1,10; (从商品表中查询所有的数据,显示从索引0,开始的十条数据) 子查询 查询分类名称为手机数码的所有商品： select * from product where cno = (select cid from category where cname = &#39;手机数码&#39;)； 查询出（商品名称，商品分类名称）信息 左连接 select p.pname,c.cname from product p left outer join category c on p.cno = c.cid; 子查询 select pname ,(select cname from category c where p.cno = c.cid) from product p; 事务 概念代码里面的事务主要是针对连接来的，是用来防止当出现异常时对数据库的增删改操作只完成了一般，另一半未做，造成数据的错误。关闭自动提交后，当出现异常时，已完成的一般也会被恢复。 设置方法 通过conn.setAutocommit (false)；来关闭自动提交的设置。 提交事务 conn.commit()。 回滚事务 conn.rollback(); 在catch中写明当出现问题时回滚。 事务的特性事务的特性：（ACID） 原子性： 指的是事务中包含的逻辑不可分割。 一致性： 指的是事务执行前后，数据的完整性保持一致。 隔离性： 指的是事务在执行期间不应该受到其他事务的影响。 持久性： 指的是事务执行成功，那么数据应该持久保持在磁盘上。 事务的安全隐患 不考虑隔离级别设置，那么会出现以下问题 读： 脏读，不可重复读，幻读 脏读：一个事务读到了另一个事物还未提交的数据。 隔离级别为：读未提交 不可重复读：一个事务可以读到另一个事务提交的数据（产生两次读出不一样的问题）。 幻读：一个事务读到了另一个事务已提交的插入的数据，导致多次查询结果不一样。隔离级别：读已提交 隔离级别：可重复读，即使一个事务已提交数据的更改，但在另一个事务里数据仍不会变化，这是为了让事务与事务之间不产生相对影响。但是还是会产生幻读问题 隔离级别：可串行化：最高达隔离级别.当一个事务要操作一个表时，必须得等之前的事务提交了数据或者回滚了才能执行，否则会等待。 重复读是为了保证在一个事务中，相同查询条件下读取的数据值不发生改变，但是不能保证下次同样条件查询，结果记录数不会增加。 可串行化就是为了解决这个问题而存在的，他将这个查询范围都加锁了，所以就不能再往这个范围内插入数据，这就是SERIALIZABLE 隔离级别做的事情。 丢失更新：如果a和b事务都对同一个表进行了操作，那么第二次对数据的更新可能会导致第一次更新丢失。 解决方法: &gt;悲观锁：可以在查询的时候给查询语句后面加上 for update （数据库的锁机制： 排他锁） &gt;乐观锁：需要程序员自己控制，自己写代码比对，先前的事务有没有对数据进行更新，如果更新了，要重新查询。 数据库连接池 数据库的连接对象创建工作比较耗费性能。 一开始就在内存中开辟一块空间（集合），一开始先往池子里面放置多个连接对象，后面需要连接的话直接从池子里面去取，不要自己创建连接了，使用完毕，要记得归还连接，确保连接对象能够循环利用。 DBCP:数据库连接池，通过数据库连接池，可以让程序自动管理数据库的释放和断开。 C3P0:数据库连接池，实现了数据源和JNDI绑定，目前大量使用。 DBCP怎么使用： 导入jar文件 使用属性配置文件（指定使用哪个类型的数据库，使用哪个数据库，用户名和密码分别是多少）。 其余操作和之前相同（创建conn对象，创建prepareStatement对象，写sql语句，执行操作，释放连接（DBCP包装后的close方法）） C3P0怎么使用： 导入jar文件 导入属性配置文件 直接创建conn对象，使用，不需要用文件流导入配置文件了。 Commons DbUtils ：是Apache组织提供的一个对JDBC进行简单封装的开源工具类库，使用它能够简化JDBC应用程序开发，同时也不会影响程序的性能。 定义了通用的crud方法。 queryRunner.update(); queryRunner.query(); 查询时需要用到 ResultSetHandler ResultSetHandler 常用的实现类： BeanHandler 查询到的数据封装成一个对象 BeanListHandler 查询到的多个数据封装成一个List&lt;对象&gt; ArrayHandler, 查询到的单个数据封装成一个数组 ArrayListHandler 查询到的多个数据封装成一个集合，集合里面是数组 MapHandler,查询到的单个数据封装成一个map MapListHandler 查询到的多个数据封装成一个集合，集合里面的元素是map ColumnListHandler， KeyedHandler, ScalarHandler MySQL数据库引擎myisam：读取速度比较快，不占用大批量资源，但是又两个缺点，1、不支持事物，2、容错不好。硬盘崩溃了，数据就没了，如果说坚持要用在那个关键程序，要通过其复制特性实时的去备份数据，，MySQL能够支持这样的备份应用程序。MyISAM类型的二进制数据文件可以在不同操作系统中迁移。也就是可以直接从Windows系统拷贝到linux系统中使用。 Innodb：它提供了事务控制能力功能，它确保一组命令全部执行成功，或者当任何一个命令出现错误时所有命令的结果都被回退，在电子银行中事务控制能力是非常重要的。支持COMMIT、ROLLBACK和其他事务特性。目前数据库表结构设计的时候一般都选择这种存储引擎。但是速度慢，占用磁盘空间比较多。 MyISAM和InnoDB的区别: 存储结构 MyISAM：每个MyISAM在磁盘上存储成三个文件。第一个文件:名字以表的名字开始，扩展名指出文件类型.frm文件存储表定义(结构文件)。第二个文件:数据文件的扩展名为.MYD (MYData)。第三个文件:索引文件的扩展名是.MYI (MYIndex)。 InnoDB：所有的表都保存在同一个数据文件中（也可能是多个文件，或者是独立的表空间文件），InnoDB表的大小只受限于操作系统文件的大小，一般为2GB。 存储空间 MyISAM：可被压缩，存储空间较小。支持三种不同的存储格式：静态表(默认，但是注意数据末尾不能有空格，会被去掉)、动态表、压缩表。 InnoDB：需要更多的内存和存储，它会在主内存中建立其专用的缓冲池用于高速缓冲数据和索引。 可移植性,备份和恢复 MyISAM：数据是以文件的形式存储，所以在跨平台的数据转移中会很方便。在备份和恢复时可单独针对某个表进行操作。 InnoDB：免费的方案可以是拷贝数据文件、备份 binlog，或者用 mysqldump，在数据量达到几十G的时候就相对痛苦了。 事务支持 MyISAM：强调的是性能，每次查询具有原子性,其执行数度比InnoDB类型更快，但是不提供事务支持。 InnoDB：提供事务,支持事务，外部键等高级数据库功能。 具有事务(commit)、回滚(rollback)和崩溃修复能力(crash recovery capabilities)的事务安全(transaction-safe (ACID compliant))型表。 AUTO_INCREMENT MyISAM：可以和其他字段一起建立联合索引。引擎的自动增长列必须是索引，如果是组合索引，自动增长可以不是第一列，他可以根据前面几列进行排序后递增。 InnoDB：InnoDB中必须包含只有该字段的索引。引擎的自动增长列必须是索引，如果是组合索引也必须是组合索引的第一列。 表锁差异 MyISAM：只支持表级锁，用户在操作myisam表时，select，update，delete，insert语句都会给表自动加锁，如果加锁以后的表满足insert并发的情况下，可以在表的尾部插入新的数据。 InnoDB：支持事务和行级锁，是innodb的最大特色。行锁大幅度提高了多用户并发操作的性能。但是InnoDB的行锁，只是在WHERE的主键是有效的，非主键的WHERE都会锁全表的。 全文索引 MyISAM：支持 FULLTEXT类型的全文索引 InnoDB：不支持FULLTEXT类型的全文索引，但是innodb可以使用sphinx插件支持全文索引，并且效果更好。 表主键 MyISAM：允许没有任何索引和主键的表存在，索引都是保存行的地址。 InnoDB：如果没有设定主键或者非空唯一索引，就会自动生成一个6字节的主键(用户不可见)，数据是主索引的一部分，附加索引保存的是主索引的值。 表的具体行数 MyISAM：保存有表的总行数，如果select count(*) from table;会直接取出出该值。 InnoDB：没有保存表的总行数，如果使用select count(*) from table；就会遍历整个表，消耗相当大，但是在加了wehre条件后，myisam和innodb处理的方式都一样。 CRUD操作 MyISAM：如果执行大量的SELECT，MyISAM是更好的选择。 InnoDB：如果你的数据执行大量的INSERT或UPDATE，出于性能方面的考虑，应该使用InnoDB表。DELETE 从性能上InnoDB更优，但DELETE FROM table时，InnoDB不会重新建立表，而是一行一行的删除，在innodb上如果要清空保存有大量数据的表，最好使用truncate table这个命令。 外键 MyISAM：不支持 InnoDB：支持 通过上述的分析，基本上可以考虑使用InnoDB来替代MyISAM引擎了，原因是InnoDB自身很多良好的特点，比如事务支持、存储 过程、视图、行级锁定等等，在并发很多的情况下，相信InnoDB的表现肯定要比MyISAM强很多。另外，任何一种表都不是万能的，只用恰当的针对业务类型来选择合适的表类型，才能最大的发挥MySQL的性能优势。如果不是很复杂的Web应用，非关键应用，还是可以继续考虑MyISAM的，这个具体情况可以自己斟酌。 存储引擎选择的基本原则 采用MyISAM引擎 R/W &gt; 100:1 且update相对较少 并发不高 表数据量小 硬件资源有限 采用InnoDB引擎 R/W比较小，频繁更新大字段 表数据量超过1000万，并发高 安全性和可用性要求高 采用Memory引擎 有足够的内存 对数据一致性要求不高，如在线人数和session等应用 需要定期归档数据 Mysql索引 Redis数据库概念 redis是一款高性能的NOSQL系列的非关系型数据库 NoSQL(NoSQL = Not Only SQL)，意即“不仅仅是SQL”，是一项全新的数据库理念，泛指非关系型的数据库。 随着互联网web2.0网站的兴起，传统的关系数据库在应付web2.0网站，特别是超大规模和高并发的SNS类型的web2.0纯动态网站已经显得力不从心，暴露了很多难以克服的问题，而非关系型的数据库则由于其本身的特点得到了非常迅速的发展。NoSQL数据库的产生就是为了解决大规模数据集合多重数据种类带来的挑战，尤其是大数据应用难题。 NOSQL和关系型数据库的比较 优点： 成本：nosql数据库简单易部署，基本都是开源软件，不需要像使用oracle那样花费大量成本购买使用，相比关系型数据库价格便宜。 查询速度：nosql数据库将数据存储于缓存之中，关系型数据库将数据存储在硬盘中，自然查询速度远不及nosql数据库。 存储数据的格式：nosql的存储格式是key,value形式、文档形式、图片形式等等，所以可以存储基础类型以及对象或者是集合等各种格式，而数据库则只支持基础类型。 扩展性：关系型数据库有类似join这样的多表查询机制的限制导致扩展很艰难。 缺点: 维护的工具和资料有限，因为nosql是属于新的技术，不能和关系型数据库10几年的技术同日而语。 不提供对sql的支持，如果不支持sql这样的工业标准，将产生一定用户的学习和使用成本。 一部分不提供关系型数据库对事务的处理。 Redis概念 Redis是用C语言开发的一个开源的高性能键值对（key-value）数据库，官方提供测试数据，50个并发执行100000个请求,读的速度是110000次/s,写的速度是81000次/s ，且Redis通过提供多种键值数据类型来适应不同场景下的存储需求，目前为止Redis支持的键值数据类型如下： 字符串类型 string 哈希类型 hash 列表类型 list 集合类型 set 有序集合类型 sortedset redis的应用场景: 缓存（数据查询、短连接、新闻内容、商品内容等等） 聊天室的在线好友列表 任务队列。（秒杀、抢购、12306等等） 应用排行榜 网站访问统计 数据过期处理（可以精确到毫秒 分布式集群架构中的session分离 命令操作 redis的数据结构： redis存储的是：key,value格式的数据，其中key都是字符串，value有5种不同的数据结构 value的数据结构： 字符串类型 string 哈希类型 hash ： map格式 列表类型 list ： linkedlist格式。支持重复元素 集合类型 set ： 不允许重复元素 有序集合类型 sortedset：不允许重复元素，且元素有顺序 字符串类型 string 存储： set key value 127.0.0.1:6379&gt; set username zhangsan OK 获取： get key 127.0.0.1:6379&gt; get username “zhangsan” 删除： del key 127.0.0.1:6379&gt; del age (integer) 1 哈希类型 hash 存储： hset key field value 127.0.0.1:6379&gt; hset myhash username lisi (integer) 1 127.0.0.1:6379&gt; hset myhash password 123 (integer) 1 获取： hget key field: 获取指定的field对应的值 127.0.0.1:6379&gt; hget myhash username “lisi” hgetall key：获取所有的field和value 127.0.0.1:6379&gt; hgetall myhash 1) “username” 2) “lisi” 3) “password” 4) “123” 删除： hdel key field 127.0.0.1:6379&gt; hdel myhash username (integer) 1 列表类型 list:可以添加一个元素到列表的头部（左边）或者尾部（右边） 添加： lpush key value: 将元素加入列表左表 rpush key value：将元素加入列表右边 127.0.0.1:6379&gt; lpush myList a (integer) 1 127.0.0.1:6379&gt; lpush myList b (integer) 2 127.0.0.1:6379&gt; rpush myList c (integer) 3 获取： lrange key start end ：范围获取 127.0.0.1:6379&gt; lrange myList 0 -1 1) “b” 2) “a” 3) “c” 删除： lpop key： 删除列表最左边的元素，并将元素返回 rpop key： 删除列表最右边的元素，并将元素返回 集合类型 set ： 不允许重复元素 存储：sadd key value 127.0.0.1:6379&gt; sadd myset a (integer) 1 127.0.0.1:6379&gt; sadd myset a (integer) 0 2. 获取：smembers key:获取set集合中所有元素 127.0.0.1:6379&gt; smembers myset 1) &quot;a&quot; 3. 删除：srem key value:删除set集合中的某个元素 127.0.0.1:6379&gt; srem myset a (integer) 1 有序集合类型 sortedset：不允许重复元素，且元素有顺序.每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。 存储：zadd key score value 127.0.0.1:6379&gt; zadd mysort 60 zhangsan (integer) 1 127.0.0.1:6379&gt; zadd mysort 50 lisi (integer) 1 127.0.0.1:6379&gt; zadd mysort 80 wangwu (integer) 1 获取：zrange key start end [withscores] 127.0.0.1:6379&gt; zrange mysort 0 -1 1) &quot;lisi&quot; 2) &quot;zhangsan&quot; 3) &quot;wangwu&quot; 127.0.0.1:6379&gt; zrange mysort 0 -1 withscores 1) &quot;zhangsan&quot; 2) &quot;60&quot; 3) &quot;wangwu&quot; 4) &quot;80&quot; 5) &quot;lisi&quot; 6) &quot;500 3. 删除：zrem key value 127.0.0.1:6379&gt; zrem mysort lisi (integer) 1 通用命令 keys * : 查询所有的键 type key ： 获取键对应的value的类型 del key：删除指定的key value 持久化 redis是一个内存数据库，当redis服务器重启，获取电脑重启，数据会丢失，我们可以将redis内存中的数据持久化保存到硬盘的文件中。 redis持久化机制： RDB：默认方式，不需要进行配置，默认就使用这种机制 在一定的间隔时间中，检测key的变化情况，然后持久化数据 AOF：日志记录的方式，可以记录每一条命令的操作。可以每一次命令操作后，持久化数据 Java客户端Jedis Jedis: 一款java操作redis数据库的工具. 使用步骤： 下载jedis的jar包 使用 123456//1. 获取连接 Jedis jedis = new Jedis("localhost",6379);//2. 操作jedis.set("username","zhangsan");//3. 关闭连接jedis.close(); 1234567891011121314151617181) 字符串类型 string set get //1. 获取连接 Jedis jedis = new Jedis();//如果使用空参构造，默认值 "localhost",6379端口 //2. 操作 //存储 jedis.set("username","zhangsan"); //获取 String username = jedis.get("username"); System.out.println(username); //可以使用setex()方法存储可以指定过期时间的 key value jedis.setex("activecode",20,"hehe");//将activecode：hehe键值对存入redis，并且20秒后自动删除该键值对 //3. 关闭连接 jedis.close(); 123456789101112131415161718192021222324252627282) 哈希类型 hash ： map格式 hset hget hgetAll //1. 获取连接 Jedis jedis = new Jedis();//如果使用空参构造，默认值 "localhost",6379端口 //2. 操作 // 存储hash jedis.hset("user","name","lisi"); jedis.hset("user","age","23"); jedis.hset("user","gender","female"); // 获取hash String name = jedis.hget("user", "name"); System.out.println(name); // 获取hash的所有map中的数据 Map&lt;String, String&gt; user = jedis.hgetAll("user"); // keyset Set&lt;String&gt; keySet = user.keySet(); for (String key : keySet) &#123; //获取value String value = user.get(key); System.out.println(key + ":" + value); &#125; //3. 关闭连接 jedis.close(); 12345678910111213141516171819202122232425262728293) 列表类型 list ： linkedlist格式。支持重复元素 lpush / rpush lpop / rpop lrange start end : 范围获取 //1. 获取连接 Jedis jedis = new Jedis();//如果使用空参构造，默认值 "localhost",6379端口 //2. 操作 // list 存储 jedis.lpush("mylist","a","b","c");//从左边存 jedis.rpush("mylist","a","b","c");//从右边存 // list 范围获取 List&lt;String&gt; mylist = jedis.lrange("mylist", 0, -1); System.out.println(mylist); // list 弹出 String element1 = jedis.lpop("mylist");//c System.out.println(element1); String element2 = jedis.rpop("mylist");//c System.out.println(element2); // list 范围获取 List&lt;String&gt; mylist2 = jedis.lrange("mylist", 0, -1); System.out.println(mylist2); //3. 关闭连接 jedis.close(); 123456789101112131415164) 集合类型 set ： 不允许重复元素 sadd smembers:获取所有元素 //1. 获取连接 Jedis jedis = new Jedis();//如果使用空参构造，默认值 "localhost",6379端口 //2. 操作 // set 存储 jedis.sadd("myset","java","php","c++"); // set 获取 Set&lt;String&gt; myset = jedis.smembers("myset"); System.out.println(myset); //3. 关闭连接 jedis.close(); 1234567891011121314151617185) 有序集合类型 sortedset：不允许重复元素，且元素有顺序 zadd zrange //1. 获取连接 Jedis jedis = new Jedis();//如果使用空参构造，默认值 "localhost",6379端口 //2. 操作 // sortedset 存储 jedis.zadd("mysortedset",3,"亚瑟"); jedis.zadd("mysortedset",30,"后裔"); jedis.zadd("mysortedset",55,"孙悟空"); // sortedset 获取 Set&lt;String&gt; mysortedset = jedis.zrange("mysortedset", 0, -1); System.out.println(mysortedset); //3. 关闭连接 jedis.close(); Jdeis连接池 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950* jedis连接池： JedisPool * 使用： 1. 创建JedisPool连接池对象 2. 调用方法 getResource()方法获取Jedis连接 //0.创建一个配置对象 JedisPoolConfig config = new JedisPoolConfig(); config.setMaxTotal(50); config.setMaxIdle(10); //1.创建Jedis连接池对象 JedisPool jedisPool = new JedisPool(config,"localhost",6379); //2.获取连接 Jedis jedis = jedisPool.getResource(); //3. 使用 jedis.set("hehe","heihei"); //4. 关闭 归还到连接池中 jedis.close(); * 连接池工具类 public class JedisPoolUtils &#123; private static JedisPool jedisPool; static&#123; //读取配置文件 InputStream is = JedisPoolUtils.class.getClassLoader().getResourceAsStream("jedis.properties"); //创建Properties对象 Properties pro = new Properties(); //关联文件 try &#123; pro.load(is); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; //获取数据，设置到JedisPoolConfig中 JedisPoolConfig config = new JedisPoolConfig(); config.setMaxTotal(Integer.parseInt(pro.getProperty("maxTotal"))); config.setMaxIdle(Integer.parseInt(pro.getProperty("maxIdle"))); //初始化JedisPool jedisPool = new JedisPool(config,pro.getProperty("host"),Integer.parseInt(pro.getProperty("port"))); &#125; /** * 获取连接方法 */ public static Jedis getJedis()&#123; return jedisPool.getResource(); &#125; &#125;]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown]]></title>
    <url>%2F2019%2F04%2F13%2FMarkdown%2F</url>
    <content type="text"><![CDATA[Welcome to my first blog .I am very happy. Markdownmarkdown简介 Markdown是一种纯文本格式的标记语言。通过简单的标记语法，它可以使普通文本内容具有一定的格式。优点 因为是纯文本，所以只要支持Markdown的地方都能获得一样的编辑效果，可以让作者摆脱排版的困扰，专心写作。 操作简单。比如:WYSIWYG编辑时标记个标题，先选中内容，再点击导航栏的标题按钮，选择几级标题。要三个步骤。而Markdown只需要在标题内容前加#即可缺点 需要记一些语法（当然，是很简单。五分钟学会）。 有些平台不支持Markdown编辑模式。 语法一.标题在想要设置为标题的文字前面加#来表示 一个#是一级标题,有几个#就是几级标题 示例: 这是一级标题 这是二级标题 这是三级标题 这是四级标题 这是五级标题 这是六级标题二.字体 加粗 要加粗的文字左右分别用两个*包裹起来 斜体要倾斜的文字左右分别用一个*包裹起来 斜体加粗 要倾斜和加粗的文字和左右分别用三个*号包裹起来 删除线 要加删除线的文字左右分别用两个~~包裹起来 示例:这是加粗的文字这是倾斜的文字`这是斜体加粗的文字这是加删除线的文字 三.引用 在引用的文字前加&gt;即可。引用也可以嵌套，如加两个&gt;&gt;三个&gt;&gt;&gt;n个…貌似可以一直加下去，但没神马卵用 示例: 这是引用的内容 这是引用的内容 这是引用的内容 四.分割线 三个或者三个以上的 - 或者 * 都可以。 示例: 五.图片 图片alt就是显示在图片下面的文字,相当于对图片内容的解释. 图片title就是图片的标题,当鼠标移动到图片上时显示的内容,title可加可不加 示例: 六.超链接 超链接名 title可加可不加 示例:简书百度 注：Markdown本身语法不支持链接在新页面中打开，如果想要在新页面中打开的话可以用html语言的a标签代替。 github官网 七.列表 无序列表:无序列表用 - + * 任何一种都可以 有序列表:数字加点示例: 列表内容 列表内容 列表内容 注意：- + * 跟内容之间都要有一个空格 列表内容 列表内容 列表内容 注意：序号跟内容之间要有空格 列表嵌套 上一级和下一级之间敲三个空格即可 一级无序列表内容 二级无序列表内容 二级无序列表内容 二级无序列表内容 一级有序列表内容 级有序列表内容 级有序列表内容 级有序列表内容 八.表格语法加示例: 表头 表头 表头 内容 内容 内容 内容 内容 内容 第二行分割表头和内容。 有一个就行，为了对齐，多加了几个文字默认居左-两边加：表示文字居中-右边加：表示文字居右注：原生的语法两边都要用 | 包起来。此处省略 九.代码 单行代码：代码之间分别用一个反引号包起来 &apos;代码内容&apos; 代码块:代码之间分别用三个反引号包起来，且两边的反引号单独占一行 1234function fun()&#123; echo &quot;这是一句非常牛逼的代码&quot;;&#125;fun(); 十.流程图1234567st=&gt;start: 开始op=&gt;operation: My Operationcond=&gt;condition: Yes or No?e=&gt;endst-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op]]></content>
      <categories>
        <category>标记语言</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
</search>
