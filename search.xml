<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Ajax]]></title>
    <url>%2F2019%2F04%2F19%2FAjax%2F</url>
    <content type="text"><![CDATA[Ajax练习代码 Ajax:是什么? 使用css和XHTML来表示。 使用DOM模型来交互和动态显示。 使用XMLHttpRequest来和服务器进行异步通信。 使用JavaScript来绑定和调用。 有什么用? 咱们的网页如果想要刷新局部内容,那么需要重新载入整个网页,用户体验不是很好.就是为了解决局部刷新问题,其他部分不动,只改变更新了的地方. 数据请求: Get 创建对象: 123456789101112131415161718function ajaxFunction()&#123; var xmlHttp; try&#123; // Firefox, Opera 8.0+, Safari xmlHttp=new XMLHttpRequest(); &#125; catch (e)&#123; try&#123;// Internet Explorer xmlHttp=new ActiveXObject("Msxml2.XMLHTTP"); &#125; catch (e)&#123; try&#123; xmlHttp=new ActiveXObject("Microsoft.XMLHTTP"); &#125; catch (e)&#123;&#125; &#125; &#125;return xmlHttp;&#125; 发送请求: 123456789101112131415//执行get请求 function get() &#123; //1.创建xmlhttprequest 对象 var request = ajaxFunction(); //2.发送请求 /* 参数1:请求类型 GET or POST 参数2:请求的路径 参数3:是否同步 true or false */ request.open("GET","/ajax/DemoServlet01",true); request.send(); &#125; ​ 如果发送请求的同时,还想获取数据,那么代码如下: 12345678910111213141516 //执行get请求function get() &#123; //1.创建xmlhttprequest 对象 var request = ajaxFunction(); //2.发送请求 request.open("GET","/ajax/DemoServlet01?name=aa&amp;age=18",true); //3.获取响应数据 注册监听的意思,一会儿准备的状态发生了改变,那么就执行等号右边的方法 request.onreadystatechange = function()&#123; //前半段表示已经能够正常处理,再判断状态码是否是200 if(request.readyState == 4 &amp;&amp; request.status == 200) &#123; //弹出响应的信息 alert(request.responseText); &#125; &#125; request.send();&#125; 数据请求: Post 创建对象: 123456789101112131415161718function ajaxFunction()&#123; var xmlHttp; try&#123; // Firefox, Opera 8.0+, Safari xmlHttp=new XMLHttpRequest(); &#125; catch (e)&#123; try&#123;// Internet Explorer xmlHttp=new ActiveXObject("Msxml2.XMLHTTP"); &#125; catch (e)&#123; try&#123; xmlHttp=new ActiveXObject("Microsoft.XMLHTTP"); &#125; catch (e)&#123;&#125; &#125; &#125;return xmlHttp;&#125; 发送请求: 1234567891011121314151617181920212223 function post() &#123; //1.创建对象 var request = ajaxFunction(); //2.发送请求 request.open("POST","/ajax/DemoServlet01",true); request.send();&#125; 如果发送请求的同时要带数据过去: function post() &#123; //1.创建对象 var request = ajaxFunction(); //2.发送请求 request.open("POST","/ajax/DemoServlet01",true); //如果使用的是post方式带数据,那么要添加头,说明提交的数据类型是一个经过url编码的form表单数据 request.setRequestHeader("Content-type","application/x-www-form-urlencoded"); //要将数据发送到服务器 在send方法里写表单数据 request.send("name=bb&amp;age=19");&#125; ​ 如果发送请求的同时,还想获取数据,那么代码如下: 12345678910111213141516171819202122//执行post请求 有响应的function post() &#123; //1.创建对象 var request = ajaxFunction(); //2.发送请求 request.open("POST","/ajax/DemoServlet01",true); //获取服务器传送过来的数据,加一个状态的监听. request.onreadystatechange=function() &#123; if(request.readyState == 4 &amp;&amp; request.status == 200)&#123; alert("post:"+ request.responseText); &#125; &#125; //如果使用的是post方式带数据,那么要添加头,说明提交的数据类型是一个经过url编码的form表单数据 request.setRequestHeader("Content-type","application/x-www-form-urlencoded"); //要将数据发送到服务器 在send方法里写表单数据 request.send("name=bb&amp;age=19");&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>JavaWeb</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[servlet学习笔记]]></title>
    <url>%2F2019%2F04%2F16%2Fservlet%2F</url>
    <content type="text"><![CDATA[sevlet详细连接菜鸟教程 servlet相关概念 Servlet 为创建基于 web 的应用程序提供了基于组件、独立于平台的方法，可以不受 CGI 程序的性能限制。Servlet 有权限访问所有的 Java API，包括访问企业级数据库的 JDBC API. Java Servlet 是运行在 Web 服务器或应用服务器上的程序，它是作为来自 Web 浏览器或其他 HTTP 客户端的请求和 HTTP 服务器上的数据库或应用程序之间的中间层。 使用 Servlet，您可以收集来自网页表单的用户输入，呈现来自数据库或者其他源的记录，还可以动态创建网页。 架构图: Servlet任务 读取客户端（浏览器）发送的显式的数据。这包括网页上的 HTML 表单，或者也可以是来自 applet 或自定义的 HTTP 客户端程序的表单。 读取客户端（浏览器）发送的隐式的 HTTP 请求数据。这包括 cookies、媒体类型和浏览器能理解的压缩格式等等。 处理数据并生成结果。这个过程可能需要访问数据库，执行 RMI 或 CORBA 调用，调用 Web 服务，或者直接计算得出对应的响应。 发送显式的数据（即文档）到客户端（浏览器）。该文档的格式可以是多种多样的，包括文本文件（HTML 或 XML）、二进制文件（GIF 图像）、Excel 等。 发送隐式的 HTTP 响应到客户端（浏览器）。这包括告诉浏览器或其他客户端被返回的文档类型（例如 HTML），设置 cookies 和缓存参数，以及其他类似的任务。 Servlet 生命周期Servlet生命周期可被定义为从创建到毁灭的整个过程.以下是Servlet遵循的过程: Servlet 通过调用 init () 方法进行初始化。 Servlet 调用 service() 方法来处理客户端的请求。 Servlet 通过调用 destroy() 方法终止（结束）。 最后，Servlet 是由 JVM 的垃圾回收器进行垃圾回收的 Servlet 表单数据:很多情况下，需要传递一些信息，从浏览器到 Web 服务器，最终到后台程序。浏览器使用两种方法可将这些信息传递到 Web 服务器，分别为 GET 方法和 POST 方法。 GET方法:GET 方法向页面请求发送已编码的用户信息。页面和已编码的信息中间用 ? 字符分隔，如下所示： http://www.test.com/hello?key1=value1&amp;key2=value2 GET 方法是默认的从浏览器向 Web 服务器传递信息的方法，它会产生一个很长的字符串，出现在浏览器的地址栏中。如果您要向服务器传递的是密码或其他的敏感信息，请不要使用 GET 方法。GET 方法有大小限制：请求字符串中最多只能有 1024 个字符。 这些信息使用 QUERY_STRING 头传递，并可以通过 QUERY_STRING 环境变量访问，Servlet 使用 doGet() 方法处理这种类型的请求。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>JavaWeb</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql事务]]></title>
    <url>%2F2019%2F04%2F15%2Fmysql%E4%BA%8B%E5%8A%A1%2F</url>
    <content type="text"><![CDATA[事务练习代码 概念代码里面的事务主要是针对连接来的，是用来防止当出现异常时对数据库的增删改操作只完成了一般，另一半未做，造成数据的错误。关闭自动提交后，当出现异常时，已完成的一般也会被恢复。 设置方法 通过conn.setAutocommit (false)；来关闭自动提交的设置。 提交事务 conn.commit()。 回滚事务 conn.rollback(); 在catch中写明当出现问题时回滚。 事务的特性事务的特性：（ACID） 原子性： 指的是事务中包含的逻辑不可分割。 一致性： 指的是事务执行前后，数据的完整性保持一致。 隔离性： 指的是事务在执行期间不应该受到其他事务的影响。 持久性： 指的是事务执行成功，那么数据应该持久保持在磁盘上。 事务的安全隐患不考虑隔离级别设置，那么会出现以下问题 读： 脏读，不可重复读，幻读 脏读：一个事务读到了另一个事物还未提交的数据。 隔离级别为：读未提交不可重复读：一个事务可以读到另一个事务提交的数据（产生两次读出不一样的问题）。 隔离级别：读已提交隔离级别：可重复读，即使一个事务已提交数据的更改，但在另一个事务里数据仍不会变化，这是为了让事务与事务之间不产生相对影响。 幻读：一个事务读到了另一个事务已提交的插入的数据，导致多次查询结果不一样。 隔离级别：可串行化：最高达隔离级别.当一个事务要操作一个表时，必须得等之前的事务提交了数据或者回滚了才能执行，否则会等待。 丢失更新： 如果a和b事务都对同一个表进行了操作，那么第二次对数据的更新可能会导致第一次更新丢失。 解决方法: 悲观锁：可以在查询的时候给查询语句后面加上 for update （数据库的锁机制： 排他锁） 乐观锁：需要程序员自己控制，自己写代码比对，先前的事务有没有对数据进行更新，如果更新了，要重新查询。]]></content>
      <categories>
        <category>SQL</category>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>事务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Use Markdown]]></title>
    <url>%2F2019%2F04%2F13%2Fhardly%2F</url>
    <content type="text"><![CDATA[Welcome to my first blog .I am very happy. 从这里开始markdown简介 Markdown是一种纯文本格式的标记语言。通过简单的标记语法，它可以使普通文本内容具有一定的格式。优点 因为是纯文本，所以只要支持Markdown的地方都能获得一样的编辑效果，可以让作者摆脱排版的困扰，专心写作。 操作简单。比如:WYSIWYG编辑时标记个标题，先选中内容，再点击导航栏的标题按钮，选择几级标题。要三个步骤。而Markdown只需要在标题内容前加#即可缺点 需要记一些语法（当然，是很简单。五分钟学会）。 有些平台不支持Markdown编辑模式。 语法一.标题在想要设置为标题的文字前面加#来表示 一个#是一级标题,有几个#就是几级标题 示例: 这是一级标题 这是二级标题 这是三级标题 这是四级标题 这是五级标题 这是六级标题二.字体 加粗 要加粗的文字左右分别用两个*包裹起来 斜体要倾斜的文字左右分别用一个*包裹起来 斜体加粗 要倾斜和加粗的文字和左右分别用三个*号包裹起来 删除线 要加删除线的文字左右分别用两个~~包裹起来 示例:这是加粗的文字这是倾斜的文字`这是斜体加粗的文字这是加删除线的文字 三.引用 在引用的文字前加&gt;即可。引用也可以嵌套，如加两个&gt;&gt;三个&gt;&gt;&gt;n个…貌似可以一直加下去，但没神马卵用 示例: 这是引用的内容 这是引用的内容 这是引用的内容 四.分割线 三个或者三个以上的 - 或者 * 都可以。 示例: 五.图片 图片alt就是显示在图片下面的文字,相当于对图片内容的解释. 图片title就是图片的标题,当鼠标移动到图片上时显示的内容,title可加可不加 示例: 六.超链接 超链接名 title可加可不加 示例:简书百度 注：Markdown本身语法不支持链接在新页面中打开，如果想要在新页面中打开的话可以用html语言的a标签代替。 github官网 七.列表 无序列表:无序列表用 - + * 任何一种都可以 有序列表:数字加点示例: 列表内容 列表内容 列表内容 注意：- + * 跟内容之间都要有一个空格 列表内容 列表内容 列表内容 注意：序号跟内容之间要有空格 列表嵌套 上一级和下一级之间敲三个空格即可 一级无序列表内容 二级无序列表内容 二级无序列表内容 二级无序列表内容 一级有序列表内容 级有序列表内容 级有序列表内容 级有序列表内容 八.表格语法加示例: 表头 表头 表头 内容 内容 内容 内容 内容 内容 第二行分割表头和内容。 有一个就行，为了对齐，多加了几个文字默认居左-两边加：表示文字居中-右边加：表示文字居右注：原生的语法两边都要用 | 包起来。此处省略 九.代码 单行代码：代码之间分别用一个反引号包起来 &apos;代码内容&apos; 代码块:代码之间分别用三个反引号包起来，且两边的反引号单独占一行 1234function fun()&#123; echo &quot;这是一句非常牛逼的代码&quot;;&#125;fun(); 十.流程图1234567st=&gt;start: 开始op=&gt;operation: My Operationcond=&gt;condition: Yes or No?e=&gt;endst-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op]]></content>
      <categories>
        <category>标记语言</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F04%2F12%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <tags>
        <tag>HEXO</tag>
      </tags>
  </entry>
</search>
