<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Spring的相关配置]]></title>
    <url>%2F2019%2F04%2F29%2FSpring%E7%9A%84%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[XML提示的配置​ Scheme的配置 Bean的相关配置 标签的id和name的配置 大部分情况下作用相同 id :使用了约束中的唯一约束.里面不能出现特殊字符 name: 没有使用约束中的唯一约束(理论上可以出现重复的,但是实际开发不能出现的),name里面可以出现特殊字符 Bean的生命周期的配置 init-method :Bean被初始化的时候执行的方法 destroy :Bean被销毁的时候执行的方法 执行条件（1.Bean是单例创建的（默认就是单例创建的） 2.工厂关闭） 如果是多例模式下不知道销毁哪个所以就不会销毁。 Bean的作用范围的配置 scope :Bean的作用范围 singleton :默认的，Spring会采用单例模式来创建这个对象 prototype :多例模式 request :应用在web项目中，Spring创建这个类以后，将这个类存入到request范围中。 session :应用在web项目中，Spring创建这个类以后，将这个类存入到session范围中。 globalsession:应用在web项目中，必须在porlet环境下使用，如果没有这种环境，相当于session。 开发中常用的就是singleton和prototype Spring的属性注入（给Bean中的属性设置值）的方式 构造方法的方式属性注入: 123456 &lt;!-- Spring属性注入的方式 --&gt; &lt;!-- 构造方法的方式 --&gt; &lt;bean id="car" class="spring.demo3.Car"&gt; &lt;constructor-arg name="name" value="宝马"/&gt; &lt;constructor-arg name="price" value="800000"/&gt;&lt;/bean&gt; Set方法的方式的属性注入: 12345&lt;!-- set方法的方式 --&gt; &lt;bean id="car2" class="spring.demo3.Car2"&gt; &lt;property name="name" value="奔驰"/&gt; &lt;property name="price" value="1000000"/&gt; &lt;/bean&gt; 123456&lt;!-- set方法注入对象类型的属性 --&gt; &lt;bean id="employee" class="spring.demo3.Employee"&gt; &lt;property name="name" value="涛哥"/&gt; &lt;!-- value:设置普通属性类型的值 ref:用来设置其他类的id和name --&gt; &lt;property name="car2" ref="car2"/&gt; &lt;/bean&gt; P名称空间的属性注入(Spring2.0以后) 通过引入p名称空间完成属性的注入 写法: 普通属性: p:属性名=”值” 对象属性: p:属性名-ref=”值” 引入p名称空间 1xmlns:p="http://www.springframework.org/schema/p" 12&lt;!-- 改为p名称空间的方式 --&gt; &lt;bean id="car2" class="spring.demo3.Car2" p:name="奇瑞qq" p:price="30000"&gt;&lt;/bean&gt; ​ 12&lt;!-- p名称空间的方式来注入对象类型 --&gt; &lt;bean id="employee" class="spring.demo3.Employee" p:name="王东" p:car2-ref="car2"&gt;&lt;/bean&gt; SpEL的属性注入(Spring3.0以后) SpEL(Spring Expression Language) :Spring的表达式语言 语法: #{SpEL} 1234567891011121314 &lt;!-- SpEL方式属性注入 --&gt;&lt;bean id="carInfo" class="spring.demo3.CarInfo"&gt;&lt;/bean&gt;&lt;bean id="car2" class="spring.demo3.Car2"&gt; &lt;property name="name" value="#&#123;carInfo.name&#125;"&gt;&lt;/property&gt; &lt;property name="price" value="#&#123;carInfo.calculatorPrice()&#125;"&gt;&lt;/property&gt;&lt;/bean&gt; &lt;bean id="employee" class="spring.demo3.Employee"&gt; &lt;property name="name" value="#&#123;'张三'&#125;"&gt;&lt;/property&gt; &lt;property name="car2" value="#&#123;car2&#125;"&gt;&lt;/property&gt;&lt;/bean&gt; 集合类型属性的注入 数组类型,list类型,set类型,map类型 12345678910111213141516171819202122232425262728293031323334353637383940414243 &lt;!-- Spring的集合属性的注入 --&gt; &lt;bean id="collectionBean" class="spring.demo4.CollectionBean"&gt; &lt;!-- 注入数组类型 --&gt; &lt;property name="arrs" &gt; &lt;list&gt; &lt;!-- &lt;ref/&gt; 引入对象类型 --&gt; &lt;value&gt;王东&lt;/value&gt; &lt;!-- 引入一般类型 --&gt; &lt;value&gt;赵红&lt;/value&gt; &lt;value&gt;李冠希&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;!-- 注入List集合类型 --&gt; &lt;property name="list" &gt; &lt;list&gt; &lt;!-- &lt;ref/&gt; 引入对象类型 --&gt; &lt;value&gt;小明&lt;/value&gt; &lt;!-- 引入一般类型 --&gt; &lt;value&gt;小红&lt;/value&gt; &lt;value&gt;小狗&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;!-- 注入Set集合类型--&gt; &lt;property name="set" &gt; &lt;set&gt; &lt;!-- &lt;ref/&gt; 引入对象类型 --&gt; &lt;value&gt;aaa&lt;/value&gt; &lt;!-- 引入一般类型 --&gt; &lt;value&gt;bbb&lt;/value&gt; &lt;value&gt;ccc&lt;/value&gt; &lt;/set&gt; &lt;/property&gt; &lt;!-- 注入Map集合 --&gt; &lt;property name="map"&gt; &lt;map&gt; &lt;entry key="aaa" value="111"/&gt; &lt;entry key="bbb" value="222"/&gt; &lt;entry key="ccc" value="333"/&gt; &lt;/map&gt; &lt;/property&gt; &lt;/bean&gt; Spring分模块开发的配置 在加载配置文件的时候,加载多个 1ApplicationContext applicationContext = new ClassPathXmlApplicationContext("applicationContext.xml","applicationContext2.xml"); 在一个配置文件中引入多个配置文件 12&lt;!-- 引入多个配置文件 --&gt; &lt;import resource="applicationContext2.xml"/&gt;]]></content>
      <categories>
        <category>Java</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux使用心得]]></title>
    <url>%2F2019%2F04%2F27%2FLinux%E4%BD%BF%E7%94%A8%E5%BF%83%E5%BE%97%2F</url>
    <content type="text"></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式]]></title>
    <url>%2F2019%2F04%2F25%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[设计原则 找出应用中可能需要变化之处，把他们独立出来，不要和那些不需要变化的代码混在一起。 针对接口编程，而不是针对实现编程。 多用组合，少用继承。 为了交互对象之间的松耦合设计而努力。 类应该对扩展开放,对修改关闭。 设计模式策略模式 定义了算法族,分别封装起来,让他们之间可以互相替换,此模式让算法的变换独立于使用算法的客户。 观察者模式 定义了对象之间的一对多依赖，这样一来，当一个对象改变状态时，它的所有依赖者都会收到通知并自动更新。 装饰者模式​ 动态地将责任附加到对象上,若要扩展功能,装饰者提供了比继承更有弹性的替代方案。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>DesignMode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于java中的注解]]></title>
    <url>%2F2019%2F04%2F23%2F%E5%85%B3%E4%BA%8Ejava%E4%B8%AD%E7%9A%84%E6%B3%A8%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[什么是注解?定义 注解（Annotation），也叫元数据。一种代码级别的说明。它是JDK1.5及以后版本引入的一个特性，与类、接口、枚举是在同一个层次。它可以声明在包、类、字段、方法、局部变量、方法参数等的前面，用来对这些元素进行说明，注释。 练习代码 JDK中的三种注解 @Override 它的作用是对覆盖超类中方法的方法进行标记，如果被标记的方法并没有实际覆盖超类中的方法，则编译器会发出错误警告。 @Deprecated 它的作用是对不应该再使用的方法添加注解，当编程人员使用这些方法时，将会在编译时显示提示信息，它与javadoc里的@deprecated标记有相同的功能，准确的说，它还不如javadoc @deprecated，因为它不支持参数，使用@Deprecated的示例代码示例如下： @SuppressWarnings 其参数有：deprecation，使用了过时的类或方法时的警告unchecked，执行了未检查的转换时的警告fallthrough，当 switch 程序块直接通往下一种情况而没有 break 时的警告path，在类路径、源文件路径等中有不存在的路径时的警告serial，当在可序列化的类上缺少serialVersionUID 定义时的警告finally ，任何 finally 子句不能正常完成时的警告all，关于以上所有情况的警告12//以下注解的含义为: 抑制编译器发生警告信息(如果变量未使用或者未遵循泛型格式错误的不报警告) @SuppressWarnings(&#123; "unused", "rawtypes" &#125;) 注解的特点 注解和接口,类一样都是数据类型. 注解可以加在变量,方法,类上. 注解可以有属性也可以没有属性@override @Test(timeout=1000) 注解是有作用范围的(源码期间有效,编译期间有效,运行期间有效) 源码期间有效: String 类上的@Author,@Since,@See 作用:使用命令 javadoc 命令将当前的源码生成帮助文件,可以识别String类上的相关的注解. 编译期间有效:@Override,@Deprecated,@Suppresswarning 作用:告诉编译器部分信息 运行期间有效:@Test 作用当我们在我们当前的代码上以Junit方式运行时,Junit会运行方法上包含@Test注解的方法 自定义注解 格式: 12345678910public @interface 注解名称 &#123; //在注解中定义一个属性 public long timeout() default -1; //only primitive type, String, Class, annotation, enumeration are permitted or 1- dimensional arrays thereof //报错,原因是属性不支持自定义类类型 //public TestAnnotation aa(); //注解的属性支持的类型有:基本数据类型(4类8种),String,Class,Annotation(注解类型),枚举类型,以及以上类型的一维数组类型 &#125; 注解作用: 配置作用 配置:开发的时候部分信息不希望写死在程序中,例如数据库的用户名和密码,可以将用户名和密码存放在.txt,.properties,.xml文件中,利用程序来读取文件中的内容. 什么时候用注解来做配置 如果配置信息不会发生频繁的改动,例如Servlet路径,建议使用注解的形式. 如果配置信息需要发生频繁的修改,例如数据库的用户名和密码信息,建议采用传统方法(.txt,.xml,.properties).]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Java注解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ajax]]></title>
    <url>%2F2019%2F04%2F19%2FAjax%2F</url>
    <content type="text"><![CDATA[Ajax:是什么? 使用css和XHTML来表示。 使用DOM模型来交互和动态显示。 使用XMLHttpRequest来和服务器进行异步通信。 使用JavaScript来绑定和调用。 练习代码 有什么用? 咱们的网页如果想要刷新局部内容,那么需要重新载入整个网页,用户体验不是很好.就是为了解决局部刷新问题,其他部分不动,只改变更新了的地方. GET 还是 POST？与 POST 相比，GET 更简单也更快，并且在大部分情况下都能用。 然而，在以下情况中，请使用 POST 请求： 无法使用缓存文件（更新服务器上的文件或数据库） 向服务器发送大量数据（POST 没有数据量限制） 发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠 数据请求: Get 创建对象: 123456789101112131415161718function ajaxFunction()&#123; var xmlHttp; try&#123; // Firefox, Opera 8.0+, Safari xmlHttp=new XMLHttpRequest(); &#125; catch (e)&#123; try&#123;// Internet Explorer xmlHttp=new ActiveXObject("Msxml2.XMLHTTP"); &#125; catch (e)&#123; try&#123; xmlHttp=new ActiveXObject("Microsoft.XMLHTTP"); &#125; catch (e)&#123;&#125; &#125; &#125;return xmlHttp;&#125; 发送请求: 123456789101112131415//执行get请求 function get() &#123; //1.创建xmlhttprequest 对象 var request = ajaxFunction(); //2.发送请求 /* 参数1:请求类型 GET or POST 参数2:请求的路径 参数3:是否同步 true or false */ request.open("GET","/ajax/DemoServlet01",true); request.send(); &#125; ​ 如果发送请求的同时,还想获取数据,那么代码如下: 12345678910111213141516 //执行get请求function get() &#123; //1.创建xmlhttprequest 对象 var request = ajaxFunction(); //2.发送请求 request.open("GET","/ajax/DemoServlet01?name=aa&amp;age=18",true); //3.获取响应数据 注册监听的意思,一会儿准备的状态发生了改变,那么就执行等号右边的方法 request.onreadystatechange = function()&#123; //前半段表示已经能够正常处理,再判断状态码是否是200 if(request.readyState == 4 &amp;&amp; request.status == 200) &#123; //弹出响应的信息 alert(request.responseText); &#125; &#125; request.send();&#125; 数据请求: Post 创建对象: 123456789101112131415161718function ajaxFunction()&#123; var xmlHttp; try&#123; // Firefox, Opera 8.0+, Safari xmlHttp=new XMLHttpRequest(); &#125; catch (e)&#123; try&#123;// Internet Explorer xmlHttp=new ActiveXObject("Msxml2.XMLHTTP"); &#125; catch (e)&#123; try&#123; xmlHttp=new ActiveXObject("Microsoft.XMLHTTP"); &#125; catch (e)&#123;&#125; &#125; &#125;return xmlHttp;&#125; 发送请求: 1234567891011121314151617181920212223 function post() &#123; //1.创建对象 var request = ajaxFunction(); //2.发送请求 request.open("POST","/ajax/DemoServlet01",true); request.send();&#125; 如果发送请求的同时要带数据过去: function post() &#123; //1.创建对象 var request = ajaxFunction(); //2.发送请求 request.open("POST","/ajax/DemoServlet01",true); //如果使用的是post方式带数据,那么要添加头,说明提交的数据类型是一个经过url编码的form表单数据 request.setRequestHeader("Content-type","application/x-www-form-urlencoded"); //要将数据发送到服务器 在send方法里写表单数据 request.send("name=bb&amp;age=19");&#125; ​ 如果发送请求的同时,还想获取数据,那么代码如下: 12345678910111213141516171819202122//执行post请求 有响应的function post() &#123; //1.创建对象 var request = ajaxFunction(); //2.发送请求 request.open("POST","/ajax/DemoServlet01",true); //获取服务器传送过来的数据,加一个状态的监听. request.onreadystatechange=function() &#123; if(request.readyState == 4 &amp;&amp; request.status == 200)&#123; alert("post:"+ request.responseText); &#125; &#125; //如果使用的是post方式带数据,那么要添加头,说明提交的数据类型是一个经过url编码的form表单数据 request.setRequestHeader("Content-type","application/x-www-form-urlencoded"); //要将数据发送到服务器 在send方法里写表单数据 request.send("name=bb&amp;age=19");&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>JavaWeb</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[servlet学习笔记]]></title>
    <url>%2F2019%2F04%2F16%2Fservlet%2F</url>
    <content type="text"><![CDATA[sevlet详细连接菜鸟教程 servlet相关概念 Servlet 为创建基于 web 的应用程序提供了基于组件、独立于平台的方法，可以不受 CGI 程序的性能限制。Servlet 有权限访问所有的 Java API，包括访问企业级数据库的 JDBC API. Java Servlet 是运行在 Web 服务器或应用服务器上的程序，它是作为来自 Web 浏览器或其他 HTTP 客户端的请求和 HTTP 服务器上的数据库或应用程序之间的中间层。 使用 Servlet，您可以收集来自网页表单的用户输入，呈现来自数据库或者其他源的记录，还可以动态创建网页。 架构图: Servlet任务 读取客户端（浏览器）发送的显式的数据。这包括网页上的 HTML 表单，或者也可以是来自 applet 或自定义的 HTTP 客户端程序的表单。 读取客户端（浏览器）发送的隐式的 HTTP 请求数据。这包括 cookies、媒体类型和浏览器能理解的压缩格式等等。 处理数据并生成结果。这个过程可能需要访问数据库，执行 RMI 或 CORBA 调用，调用 Web 服务，或者直接计算得出对应的响应。 发送显式的数据（即文档）到客户端（浏览器）。该文档的格式可以是多种多样的，包括文本文件（HTML 或 XML）、二进制文件（GIF 图像）、Excel 等。 发送隐式的 HTTP 响应到客户端（浏览器）。这包括告诉浏览器或其他客户端被返回的文档类型（例如 HTML），设置 cookies 和缓存参数，以及其他类似的任务。 Servlet 生命周期Servlet生命周期可被定义为从创建到毁灭的整个过程.以下是Servlet遵循的过程: Servlet 通过调用 init () 方法进行初始化。 Servlet 调用 service() 方法来处理客户端的请求。 Servlet 通过调用 destroy() 方法终止（结束）。 最后，Servlet 是由 JVM 的垃圾回收器进行垃圾回收的 Servlet 表单数据:很多情况下，需要传递一些信息，从浏览器到 Web 服务器，最终到后台程序。浏览器使用两种方法可将这些信息传递到 Web 服务器，分别为 GET 方法和 POST 方法。 GET方法:GET 方法向页面请求发送已编码的用户信息。页面和已编码的信息中间用 ? 字符分隔，如下所示： http://www.test.com/hello?key1=value1&amp;key2=value2 GET 方法是默认的从浏览器向 Web 服务器传递信息的方法，它会产生一个很长的字符串，出现在浏览器的地址栏中。如果您要向服务器传递的是密码或其他的敏感信息，请不要使用 GET 方法。GET 方法有大小限制：请求字符串中最多只能有 1024 个字符。 这些信息使用 QUERY_STRING 头传递，并可以通过 QUERY_STRING 环境变量访问，Servlet 使用 doGet() 方法处理这种类型的请求。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>JavaWeb</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql事务]]></title>
    <url>%2F2019%2F04%2F15%2Fmysql%E4%BA%8B%E5%8A%A1%2F</url>
    <content type="text"><![CDATA[事务练习代码 概念代码里面的事务主要是针对连接来的，是用来防止当出现异常时对数据库的增删改操作只完成了一般，另一半未做，造成数据的错误。关闭自动提交后，当出现异常时，已完成的一般也会被恢复。 设置方法 通过conn.setAutocommit (false)；来关闭自动提交的设置。 提交事务 conn.commit()。 回滚事务 conn.rollback(); 在catch中写明当出现问题时回滚。 事务的特性事务的特性：（ACID） 原子性： 指的是事务中包含的逻辑不可分割。 一致性： 指的是事务执行前后，数据的完整性保持一致。 隔离性： 指的是事务在执行期间不应该受到其他事务的影响。 持久性： 指的是事务执行成功，那么数据应该持久保持在磁盘上。 事务的安全隐患不考虑隔离级别设置，那么会出现以下问题 读： 脏读，不可重复读，幻读 脏读：一个事务读到了另一个事物还未提交的数据。 隔离级别为：读未提交不可重复读：一个事务可以读到另一个事务提交的数据（产生两次读出不一样的问题）。 隔离级别：读已提交隔离级别：可重复读，即使一个事务已提交数据的更改，但在另一个事务里数据仍不会变化，这是为了让事务与事务之间不产生相对影响。 幻读：一个事务读到了另一个事务已提交的插入的数据，导致多次查询结果不一样。 隔离级别：可串行化：最高达隔离级别.当一个事务要操作一个表时，必须得等之前的事务提交了数据或者回滚了才能执行，否则会等待。 丢失更新： 如果a和b事务都对同一个表进行了操作，那么第二次对数据的更新可能会导致第一次更新丢失。 解决方法: 悲观锁：可以在查询的时候给查询语句后面加上 for update （数据库的锁机制： 排他锁） 乐观锁：需要程序员自己控制，自己写代码比对，先前的事务有没有对数据进行更新，如果更新了，要重新查询。]]></content>
      <categories>
        <category>SQL</category>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>事务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Use Markdown]]></title>
    <url>%2F2019%2F04%2F13%2Fhardly%2F</url>
    <content type="text"><![CDATA[Welcome to my first blog .I am very happy. 从这里开始markdown简介 Markdown是一种纯文本格式的标记语言。通过简单的标记语法，它可以使普通文本内容具有一定的格式。优点 因为是纯文本，所以只要支持Markdown的地方都能获得一样的编辑效果，可以让作者摆脱排版的困扰，专心写作。 操作简单。比如:WYSIWYG编辑时标记个标题，先选中内容，再点击导航栏的标题按钮，选择几级标题。要三个步骤。而Markdown只需要在标题内容前加#即可缺点 需要记一些语法（当然，是很简单。五分钟学会）。 有些平台不支持Markdown编辑模式。 语法一.标题在想要设置为标题的文字前面加#来表示 一个#是一级标题,有几个#就是几级标题 示例: 这是一级标题 这是二级标题 这是三级标题 这是四级标题 这是五级标题 这是六级标题二.字体 加粗 要加粗的文字左右分别用两个*包裹起来 斜体要倾斜的文字左右分别用一个*包裹起来 斜体加粗 要倾斜和加粗的文字和左右分别用三个*号包裹起来 删除线 要加删除线的文字左右分别用两个~~包裹起来 示例:这是加粗的文字这是倾斜的文字`这是斜体加粗的文字这是加删除线的文字 三.引用 在引用的文字前加&gt;即可。引用也可以嵌套，如加两个&gt;&gt;三个&gt;&gt;&gt;n个…貌似可以一直加下去，但没神马卵用 示例: 这是引用的内容 这是引用的内容 这是引用的内容 四.分割线 三个或者三个以上的 - 或者 * 都可以。 示例: 五.图片 图片alt就是显示在图片下面的文字,相当于对图片内容的解释. 图片title就是图片的标题,当鼠标移动到图片上时显示的内容,title可加可不加 示例: 六.超链接 超链接名 title可加可不加 示例:简书百度 注：Markdown本身语法不支持链接在新页面中打开，如果想要在新页面中打开的话可以用html语言的a标签代替。 github官网 七.列表 无序列表:无序列表用 - + * 任何一种都可以 有序列表:数字加点示例: 列表内容 列表内容 列表内容 注意：- + * 跟内容之间都要有一个空格 列表内容 列表内容 列表内容 注意：序号跟内容之间要有空格 列表嵌套 上一级和下一级之间敲三个空格即可 一级无序列表内容 二级无序列表内容 二级无序列表内容 二级无序列表内容 一级有序列表内容 级有序列表内容 级有序列表内容 级有序列表内容 八.表格语法加示例: 表头 表头 表头 内容 内容 内容 内容 内容 内容 第二行分割表头和内容。 有一个就行，为了对齐，多加了几个文字默认居左-两边加：表示文字居中-右边加：表示文字居右注：原生的语法两边都要用 | 包起来。此处省略 九.代码 单行代码：代码之间分别用一个反引号包起来 &apos;代码内容&apos; 代码块:代码之间分别用三个反引号包起来，且两边的反引号单独占一行 1234function fun()&#123; echo &quot;这是一句非常牛逼的代码&quot;;&#125;fun(); 十.流程图1234567st=&gt;start: 开始op=&gt;operation: My Operationcond=&gt;condition: Yes or No?e=&gt;endst-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op]]></content>
      <categories>
        <category>标记语言</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
</search>
